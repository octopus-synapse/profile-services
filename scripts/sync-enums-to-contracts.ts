/**
 * Sync Prisma Enums to Profile Contracts
 *
 * This script extracts enum definitions from Prisma schema files and generates
 * corresponding Zod schemas in profile-contracts for shared type definitions.
 *
 * Usage: npx ts-node scripts/sync-enums-to-contracts.ts [--check] [--output <path>]
 *
 * Options:
 *   --check   Validate that contracts are in sync (CI mode)
 *   --output  Custom output path (default: ../profile-contracts/src/generated/prisma-enums.ts)
 */

import * as fs from 'fs';
import * as path from 'path';

// Configuration
const PRISMA_SCHEMA_DIR = path.join(__dirname, '../prisma/schema');
const DEFAULT_OUTPUT_PATH = path.join(
  __dirname,
  '../../profile-contracts/src/generated/prisma-enums.ts',
);

// Enums to sync - only export enums that are needed in contracts
const ENUMS_TO_SYNC = [
  'ResumeTemplate',
  'ThemeCategory',
  'ThemeStatus',
  'SkillType',
  'TechAreaType',
];

interface PrismaEnum {
  name: string;
  values: string[];
  sourceFile: string;
}

/**
 * Parse a Prisma schema file and extract enum definitions
 */
function parsePrismaEnums(content: string, sourceFile: string): PrismaEnum[] {
  const enums: PrismaEnum[] = [];
  const enumRegex = /enum\s+(\w+)\s*\{([^}]+)\}/g;

  let match;
  while ((match = enumRegex.exec(content)) !== null) {
    const name = match[1];
    const valuesBlock = match[2];

    // Extract enum values (one per line, ignore comments)
    const values = valuesBlock
      .split('\n')
      .map((line) => line.trim())
      .filter((line) => line && !line.startsWith('//'))
      .map((line) => line.replace(/\/\/.*$/, '').trim()) // Remove inline comments
      .filter(Boolean);

    enums.push({ name, values, sourceFile });
  }

  return enums;
}

/**
 * Read all Prisma schema files and extract enums
 */
function extractAllEnums(): PrismaEnum[] {
  const allEnums: PrismaEnum[] = [];

  // Read all .prisma files in schema directory
  const files = fs
    .readdirSync(PRISMA_SCHEMA_DIR)
    .filter((f) => f.endsWith('.prisma'));

  for (const file of files) {
    const filePath = path.join(PRISMA_SCHEMA_DIR, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    const enums = parsePrismaEnums(content, file);
    allEnums.push(...enums);
  }

  return allEnums;
}

/**
 * Convert PascalCase to camelCase
 */
function toCamelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

/**
 * Convert SCREAMING_SNAKE_CASE to kebab-case
 */
function enumValueToKebab(value: string): string {
  return value.toLowerCase().replace(/_/g, '-');
}

/**
 * Generate Zod schema code for enums
 */
function generateZodSchemas(enums: PrismaEnum[]): string {
  const filteredEnums = enums.filter((e) => ENUMS_TO_SYNC.includes(e.name));

  const imports = `import { z } from "zod";\n\n`;

  const header = `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * 
 * Generated by: scripts/sync-enums-to-contracts.ts
 * Generated at: ${new Date().toISOString()}
 * 
 * These Zod schemas are synchronized from Prisma enum definitions.
 * To update, run: npm run sync:enums
 */\n\n`;

  const schemas = filteredEnums
    .map((enumDef) => {
      const { name, values, sourceFile } = enumDef;
      const schemaName = `Prisma${name}Schema`;
      const typeName = `Prisma${name}`;
      const camelName = toCamelCase(name);

      // Generate original SCREAMING_SNAKE values
      const originalValues = values.map((v) => `"${v}"`).join(', ');

      // Generate kebab-case values for DSL compatibility
      const kebabValues = values
        .map((v) => `"${enumValueToKebab(v)}"`)
        .join(', ');

      return `// Source: ${sourceFile}
export const ${schemaName} = z.enum([${originalValues}]);
export type ${typeName} = z.infer<typeof ${schemaName}>;

// Kebab-case version for DSL compatibility
export const ${schemaName}Kebab = z.enum([${kebabValues}]);
export type ${typeName}Kebab = z.infer<typeof ${schemaName}Kebab>;

// Mapping functions
export const ${camelName}ToKebab = (value: ${typeName}): ${typeName}Kebab => {
  const mapping: Record<${typeName}, ${typeName}Kebab> = {
${values.map((v) => `    "${v}": "${enumValueToKebab(v)}"`).join(',\n')},
  };
  return mapping[value];
};

export const ${camelName}FromKebab = (value: ${typeName}Kebab): ${typeName} => {
  const mapping: Record<${typeName}Kebab, ${typeName}> = {
${values.map((v) => `    "${enumValueToKebab(v)}": "${v}"`).join(',\n')},
  };
  return mapping[value];
};
`;
    })
    .join('\n');

  // Generate combined export
  const exports = `
// Combined types for convenience
export const PrismaEnums = {
${filteredEnums.map((e) => `  ${e.name}: Prisma${e.name}Schema`).join(',\n')},
} as const;

export const PrismaEnumsKebab = {
${filteredEnums.map((e) => `  ${e.name}: Prisma${e.name}SchemaKebab`).join(',\n')},
} as const;
`;

  return imports + header + schemas + exports;
}

/**
 * Ensure output directory exists
 */
function ensureDirectoryExists(filePath: string): void {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

/**
 * Compare generated content with existing file
 */
function checkSync(outputPath: string, generatedContent: string): boolean {
  if (!fs.existsSync(outputPath)) {
    console.error(`âŒ Generated file does not exist: ${outputPath}`);
    console.error('   Run without --check to generate the file.');
    return false;
  }

  const existingContent = fs.readFileSync(outputPath, 'utf-8');

  // Compare without timestamp line
  const normalizeContent = (content: string) =>
    content
      .split('\n')
      .filter((line) => !line.includes('Generated at:'))
      .join('\n');

  if (
    normalizeContent(existingContent) !== normalizeContent(generatedContent)
  ) {
    console.error('âŒ Prisma enums are out of sync with profile-contracts!');
    console.error('   Run: npm run sync:enums to update.');
    return false;
  }

  console.log('âœ… Prisma enums are in sync with profile-contracts.');
  return true;
}

/**
 * Main entry point
 */
function main(): void {
  const args = process.argv.slice(2);
  const checkMode = args.includes('--check');
  const outputIndex = args.indexOf('--output');
  const outputPath =
    outputIndex !== -1 && args[outputIndex + 1]
      ? args[outputIndex + 1]
      : DEFAULT_OUTPUT_PATH;

  console.log('ðŸ“¦ Syncing Prisma enums to profile-contracts...\n');

  // Extract enums
  const allEnums = extractAllEnums();
  console.log(`Found ${allEnums.length} enums in Prisma schema:`);
  allEnums.forEach((e) =>
    console.log(`  - ${e.name} (${e.values.length} values) [${e.sourceFile}]`),
  );

  // Filter to only synced enums
  const syncedEnums = allEnums.filter((e) => ENUMS_TO_SYNC.includes(e.name));
  console.log(
    `\nSyncing ${syncedEnums.length} enums: ${ENUMS_TO_SYNC.join(', ')}\n`,
  );

  // Generate Zod schemas
  const generatedContent = generateZodSchemas(allEnums);

  if (checkMode) {
    // CI mode: just check if in sync
    const isInSync = checkSync(outputPath, generatedContent);
    process.exit(isInSync ? 0 : 1);
  }

  // Write mode: generate the file
  ensureDirectoryExists(outputPath);
  fs.writeFileSync(outputPath, generatedContent);

  console.log(`âœ… Generated: ${outputPath}`);
  console.log('\nGenerated schemas:');
  syncedEnums.forEach((e) => {
    console.log(`  - Prisma${e.name}Schema`);
    console.log(`  - Prisma${e.name}SchemaKebab`);
    console.log(`  - ${toCamelCase(e.name)}ToKebab()`);
    console.log(`  - ${toCamelCase(e.name)}FromKebab()`);
  });
}

main();
