diff --git a/arningp b/arningp
new file mode 100644
index 0000000..e69de29
diff --git a/data/tech-skills-data.json b/data/tech-skills-data.json
new file mode 100644
index 0000000..1a8d48a
--- /dev/null
+++ b/data/tech-skills-data.json
@@ -0,0 +1,327 @@
+{
+  "techAreas": [
+    {
+      "type": "DEVELOPMENT",
+      "nameEn": "Development",
+      "namePtBr": "Desenvolvimento",
+      "descriptionEn": "Software development and programming",
+      "descriptionPtBr": "Desenvolvimento de software e programação",
+      "icon": "code",
+      "color": "#3B82F6",
+      "order": 1
+    },
+    {
+      "type": "DEVOPS",
+      "nameEn": "DevOps & Infrastructure",
+      "namePtBr": "DevOps e Infraestrutura",
+      "descriptionEn": "DevOps, cloud infrastructure, and operations",
+      "descriptionPtBr": "DevOps, infraestrutura cloud e operações",
+      "icon": "server",
+      "color": "#8B5CF6",
+      "order": 2
+    },
+    {
+      "type": "DATA",
+      "nameEn": "Data & AI",
+      "namePtBr": "Dados e IA",
+      "descriptionEn": "Data science, analytics, machine learning, and AI",
+      "descriptionPtBr": "Ciência de dados, analytics, machine learning e IA",
+      "icon": "database",
+      "color": "#10B981",
+      "order": 3
+    },
+    {
+      "type": "SECURITY",
+      "nameEn": "Security",
+      "namePtBr": "Segurança",
+      "descriptionEn": "Cybersecurity, penetration testing, and compliance",
+      "descriptionPtBr": "Cibersegurança, testes de penetração e conformidade",
+      "icon": "shield",
+      "color": "#EF4444",
+      "order": 4
+    },
+    {
+      "type": "DESIGN",
+      "nameEn": "Design",
+      "namePtBr": "Design",
+      "descriptionEn": "UI/UX design, product design, and visual design",
+      "descriptionPtBr": "Design UI/UX, design de produto e design visual",
+      "icon": "palette",
+      "color": "#EC4899",
+      "order": 5
+    },
+    {
+      "type": "PRODUCT",
+      "nameEn": "Product",
+      "namePtBr": "Produto",
+      "descriptionEn": "Product management, strategy, and growth",
+      "descriptionPtBr": "Gestão de produto, estratégia e crescimento",
+      "icon": "lightbulb",
+      "color": "#F59E0B",
+      "order": 6
+    },
+    {
+      "type": "QA",
+      "nameEn": "Quality Assurance",
+      "namePtBr": "Qualidade",
+      "descriptionEn": "Testing, quality assurance, and automation",
+      "descriptionPtBr": "Testes, garantia de qualidade e automação",
+      "icon": "check-circle",
+      "color": "#14B8A6",
+      "order": 7
+    },
+    {
+      "type": "INFRASTRUCTURE",
+      "nameEn": "Infrastructure",
+      "namePtBr": "Infraestrutura",
+      "descriptionEn": "Networks, systems administration, and hardware",
+      "descriptionPtBr": "Redes, administração de sistemas e hardware",
+      "icon": "network",
+      "color": "#6366F1",
+      "order": 8
+    },
+    {
+      "type": "OTHER",
+      "nameEn": "Other",
+      "namePtBr": "Outros",
+      "descriptionEn": "Other tech skills and tools",
+      "descriptionPtBr": "Outras habilidades e ferramentas tech",
+      "icon": "more-horizontal",
+      "color": "#64748B",
+      "order": 99
+    }
+  ],
+  "techNiches": [
+    {
+      "slug": "frontend",
+      "areaType": "DEVELOPMENT",
+      "nameEn": "Frontend",
+      "namePtBr": "Frontend",
+      "descriptionEn": "User interface and client-side development",
+      "descriptionPtBr": "Interface do usuário e desenvolvimento client-side",
+      "icon": "layout",
+      "color": "#3B82F6",
+      "order": 1
+    },
+    {
+      "slug": "backend",
+      "areaType": "DEVELOPMENT",
+      "nameEn": "Backend",
+      "namePtBr": "Backend",
+      "descriptionEn": "Server-side development and APIs",
+      "descriptionPtBr": "Desenvolvimento server-side e APIs",
+      "icon": "server",
+      "color": "#10B981",
+      "order": 2
+    },
+    {
+      "slug": "fullstack",
+      "areaType": "DEVELOPMENT",
+      "nameEn": "Fullstack",
+      "namePtBr": "Fullstack",
+      "descriptionEn": "Full-stack web development",
+      "descriptionPtBr": "Desenvolvimento web full-stack",
+      "icon": "layers",
+      "color": "#8B5CF6",
+      "order": 3
+    },
+    {
+      "slug": "mobile",
+      "areaType": "DEVELOPMENT",
+      "nameEn": "Mobile",
+      "namePtBr": "Mobile",
+      "descriptionEn": "iOS, Android, and cross-platform mobile development",
+      "descriptionPtBr": "Desenvolvimento mobile iOS, Android e multiplataforma",
+      "icon": "smartphone",
+      "color": "#F59E0B",
+      "order": 4
+    },
+    {
+      "slug": "game-dev",
+      "areaType": "DEVELOPMENT",
+      "nameEn": "Game Development",
+      "namePtBr": "Desenvolvimento de Jogos",
+      "descriptionEn": "Video game development",
+      "descriptionPtBr": "Desenvolvimento de jogos",
+      "icon": "gamepad",
+      "color": "#EF4444",
+      "order": 5
+    },
+    {
+      "slug": "embedded",
+      "areaType": "DEVELOPMENT",
+      "nameEn": "Embedded Systems",
+      "namePtBr": "Sistemas Embarcados",
+      "descriptionEn": "Embedded and IoT development",
+      "descriptionPtBr": "Desenvolvimento embarcado e IoT",
+      "icon": "cpu",
+      "color": "#6366F1",
+      "order": 6
+    },
+    {
+      "slug": "blockchain",
+      "areaType": "DEVELOPMENT",
+      "nameEn": "Blockchain",
+      "namePtBr": "Blockchain",
+      "descriptionEn": "Blockchain and Web3 development",
+      "descriptionPtBr": "Desenvolvimento blockchain e Web3",
+      "icon": "link",
+      "color": "#14B8A6",
+      "order": 7
+    },
+    {
+      "slug": "devops",
+      "areaType": "DEVOPS",
+      "nameEn": "DevOps",
+      "namePtBr": "DevOps",
+      "descriptionEn": "CI/CD, automation, and DevOps practices",
+      "descriptionPtBr": "CI/CD, automação e práticas DevOps",
+      "icon": "git-branch",
+      "color": "#8B5CF6",
+      "order": 1
+    },
+    {
+      "slug": "cloud",
+      "areaType": "DEVOPS",
+      "nameEn": "Cloud",
+      "namePtBr": "Cloud",
+      "descriptionEn": "Cloud platforms and services",
+      "descriptionPtBr": "Plataformas e serviços cloud",
+      "icon": "cloud",
+      "color": "#3B82F6",
+      "order": 2
+    },
+    {
+      "slug": "sre",
+      "areaType": "DEVOPS",
+      "nameEn": "Site Reliability",
+      "namePtBr": "Confiabilidade de Site",
+      "descriptionEn": "Site reliability engineering and monitoring",
+      "descriptionPtBr": "Engenharia de confiabilidade e monitoramento",
+      "icon": "activity",
+      "color": "#EF4444",
+      "order": 3
+    },
+    {
+      "slug": "data-science",
+      "areaType": "DATA",
+      "nameEn": "Data Science",
+      "namePtBr": "Ciência de Dados",
+      "descriptionEn": "Data analysis and statistical modeling",
+      "descriptionPtBr": "Análise de dados e modelagem estatística",
+      "icon": "bar-chart",
+      "color": "#10B981",
+      "order": 1
+    },
+    {
+      "slug": "machine-learning",
+      "areaType": "DATA",
+      "nameEn": "Machine Learning",
+      "namePtBr": "Machine Learning",
+      "descriptionEn": "Machine learning and deep learning",
+      "descriptionPtBr": "Machine learning e deep learning",
+      "icon": "brain",
+      "color": "#8B5CF6",
+      "order": 2
+    },
+    {
+      "slug": "data-engineering",
+      "areaType": "DATA",
+      "nameEn": "Data Engineering",
+      "namePtBr": "Engenharia de Dados",
+      "descriptionEn": "Data pipelines and infrastructure",
+      "descriptionPtBr": "Pipelines de dados e infraestrutura",
+      "icon": "database",
+      "color": "#F59E0B",
+      "order": 3
+    },
+    {
+      "slug": "data-analytics",
+      "areaType": "DATA",
+      "nameEn": "Data Analytics",
+      "namePtBr": "Análise de Dados",
+      "descriptionEn": "Business intelligence and analytics",
+      "descriptionPtBr": "Business intelligence e analytics",
+      "icon": "pie-chart",
+      "color": "#3B82F6",
+      "order": 4
+    },
+    {
+      "slug": "security",
+      "areaType": "SECURITY",
+      "nameEn": "Security",
+      "namePtBr": "Segurança",
+      "descriptionEn": "Application and infrastructure security",
+      "descriptionPtBr": "Segurança de aplicações e infraestrutura",
+      "icon": "shield",
+      "color": "#EF4444",
+      "order": 1
+    },
+    {
+      "slug": "pentesting",
+      "areaType": "SECURITY",
+      "nameEn": "Penetration Testing",
+      "namePtBr": "Teste de Penetração",
+      "descriptionEn": "Ethical hacking and vulnerability assessment",
+      "descriptionPtBr": "Hacking ético e avaliação de vulnerabilidades",
+      "icon": "target",
+      "color": "#DC2626",
+      "order": 2
+    },
+    {
+      "slug": "design",
+      "areaType": "DESIGN",
+      "nameEn": "UI/UX Design",
+      "namePtBr": "Design UI/UX",
+      "descriptionEn": "User interface and experience design",
+      "descriptionPtBr": "Design de interface e experiência do usuário",
+      "icon": "figma",
+      "color": "#EC4899",
+      "order": 1
+    },
+    {
+      "slug": "qa",
+      "areaType": "QA",
+      "nameEn": "QA Testing",
+      "namePtBr": "Testes QA",
+      "descriptionEn": "Manual and automated testing",
+      "descriptionPtBr": "Testes manuais e automatizados",
+      "icon": "check-square",
+      "color": "#14B8A6",
+      "order": 1
+    },
+    {
+      "slug": "test-automation",
+      "areaType": "QA",
+      "nameEn": "Test Automation",
+      "namePtBr": "Automação de Testes",
+      "descriptionEn": "Test automation frameworks and tools",
+      "descriptionPtBr": "Frameworks e ferramentas de automação de testes",
+      "icon": "play-circle",
+      "color": "#10B981",
+      "order": 2
+    },
+    {
+      "slug": "networks",
+      "areaType": "INFRASTRUCTURE",
+      "nameEn": "Networks",
+      "namePtBr": "Redes",
+      "descriptionEn": "Network administration and architecture",
+      "descriptionPtBr": "Administração e arquitetura de redes",
+      "icon": "wifi",
+      "color": "#6366F1",
+      "order": 1
+    },
+    {
+      "slug": "sysadmin",
+      "areaType": "INFRASTRUCTURE",
+      "nameEn": "System Administration",
+      "namePtBr": "Administração de Sistemas",
+      "descriptionEn": "Server and system administration",
+      "descriptionPtBr": "Administração de servidores e sistemas",
+      "icon": "terminal",
+      "color": "#64748B",
+      "order": 2
+    }
+  ]
+}
diff --git a/eslint.config.mjs b/eslint.config.mjs
index 32465cc..179aa9c 100644
--- a/eslint.config.mjs
+++ b/eslint.config.mjs
@@ -5,9 +5,19 @@ import globals from 'globals';
 import tseslint from 'typescript-eslint';
 
 export default tseslint.config(
+  // Global ignores
   {
-    ignores: ['eslint.config.mjs'],
+    ignores: [
+      'eslint.config.mjs',
+      'dist/**',
+      'node_modules/**',
+      'coverage/**',
+      '*.config.js',
+      '*.config.mjs',
+    ],
   },
+
+  // Base configuration for all files
   eslint.configs.recommended,
   ...tseslint.configs.recommendedTypeChecked,
   eslintPluginPrettierRecommended,
@@ -25,11 +35,89 @@ export default tseslint.config(
       },
     },
   },
+
+  // Production code rules (STRICT - maximum rigor)
   {
+    files: ['src/**/*.ts'],
+    ignores: [
+      '**/*.spec.ts',
+      '**/*.e2e-spec.ts',
+      '**/*.smoke.spec.ts',
+      '**/__mocks__/**',
+    ],
     rules: {
+      // Type safety - STRICT for production
+      '@typescript-eslint/no-explicit-any': 'error',
+      '@typescript-eslint/no-unsafe-assignment': 'error',
+      '@typescript-eslint/no-unsafe-argument': 'error',
+      '@typescript-eslint/no-unsafe-member-access': 'error',
+      '@typescript-eslint/no-unsafe-call': 'error',
+      '@typescript-eslint/no-unsafe-return': 'error',
+      '@typescript-eslint/no-floating-promises': 'error',
+      '@typescript-eslint/no-misused-promises': 'error',
+
+      // Code quality - STRICT for production
+      '@typescript-eslint/unbound-method': 'error',
+      '@typescript-eslint/no-unused-vars': [
+        'error',
+        {
+          argsIgnorePattern: '^_',
+          varsIgnorePattern: '^_',
+          caughtErrorsIgnorePattern: '^_',
+        },
+      ],
+      '@typescript-eslint/require-await': 'error',
+      '@typescript-eslint/no-base-to-string': 'error',
+      '@typescript-eslint/restrict-template-expressions': 'error',
+      '@typescript-eslint/no-require-imports': 'error',
+
+      // Best practices - warnings for production
+      '@typescript-eslint/prefer-nullish-coalescing': 'warn',
+      '@typescript-eslint/prefer-optional-chain': 'warn',
+      '@typescript-eslint/no-unnecessary-condition': 'warn',
+      '@typescript-eslint/no-non-null-assertion': 'warn',
+    },
+  },
+
+  // Test files rules (RELAXED - pragmatic for testing)
+  {
+    files: [
+      '**/*.spec.ts',
+      '**/*.e2e-spec.ts',
+      '**/*.smoke.spec.ts',
+      'test/**/*.ts',
+      '**/__mocks__/**/*.ts',
+    ],
+    rules: {
+      // Type safety - RELAXED for tests (mocks often use 'any')
       '@typescript-eslint/no-explicit-any': 'off',
-      '@typescript-eslint/no-floating-promises': 'warn',
-      '@typescript-eslint/no-unsafe-argument': 'warn'
+      '@typescript-eslint/no-unsafe-assignment': 'off',
+      '@typescript-eslint/no-unsafe-argument': 'off',
+      '@typescript-eslint/no-unsafe-member-access': 'off',
+      '@typescript-eslint/no-unsafe-call': 'off',
+      '@typescript-eslint/no-unsafe-return': 'off',
+      '@typescript-eslint/no-floating-promises': 'warn', // Still warn, but not error
+      '@typescript-eslint/no-misused-promises': 'warn',
+
+      // Code quality - RELAXED for tests
+      '@typescript-eslint/unbound-method': 'off', // Jest mocks often trigger this
+      '@typescript-eslint/no-unused-vars': [
+        'warn', // Warn instead of error
+        {
+          argsIgnorePattern: '^_',
+          varsIgnorePattern: '^_',
+          caughtErrorsIgnorePattern: '^_',
+        },
+      ],
+      '@typescript-eslint/require-await': 'off', // Test setup often doesn't need await
+      '@typescript-eslint/no-base-to-string': 'off', // Jest matchers often trigger this
+      '@typescript-eslint/restrict-template-expressions': 'off', // Test messages often use any
+      '@typescript-eslint/no-require-imports': 'off', // Some test utilities use require
+
+      // Test-specific relaxations
+      '@typescript-eslint/no-non-null-assertion': 'warn', // Common in tests
+      '@typescript-eslint/ban-ts-comment': 'warn', // Sometimes needed in tests
+      '@typescript-eslint/no-empty-function': 'off', // Mock functions are often empty
     },
   },
-);
\ No newline at end of file
+);
diff --git a/prisma.config.ts b/prisma.config.ts
new file mode 100644
index 0000000..5ceaf73
--- /dev/null
+++ b/prisma.config.ts
@@ -0,0 +1,6 @@
+import * as path from 'node:path';
+
+export default {
+  schema: path.join('prisma', 'schema'),
+};
+
diff --git a/prisma/schema.prisma b/prisma/schema.prisma.backup
similarity index 100%
rename from prisma/schema.prisma
rename to prisma/schema.prisma.backup
diff --git a/prisma/schema/auth.prisma b/prisma/schema/auth.prisma
new file mode 100644
index 0000000..b85ef1e
--- /dev/null
+++ b/prisma/schema/auth.prisma
@@ -0,0 +1,39 @@
+// NextAuth Models - Authentication
+
+model Account {
+  id                String  @id @default(cuid())
+  userId            String
+  type              String
+  provider          String
+  providerAccountId String
+  refresh_token     String? @db.Text
+  access_token      String? @db.Text
+  expires_at        Int?
+  token_type        String?
+  scope             String?
+  id_token          String? @db.Text
+  session_state     String?
+
+  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
+
+  @@unique([provider, providerAccountId])
+  @@index([userId])
+}
+
+model Session {
+  id           String   @id @default(cuid())
+  sessionToken String   @unique
+  userId       String
+  expires      DateTime
+  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
+
+  @@index([userId])
+}
+
+model VerificationToken {
+  identifier String
+  token      String   @unique
+  expires    DateTime
+
+  @@unique([identifier, token])
+}
diff --git a/prisma/schema/catalog.prisma b/prisma/schema/catalog.prisma
new file mode 100644
index 0000000..af27099
--- /dev/null
+++ b/prisma/schema/catalog.prisma
@@ -0,0 +1,158 @@
+// Tech Skills Catalog - Pre-populated skills data
+
+model TechArea {
+  id   String       @id @default(cuid())
+  type TechAreaType @unique
+
+  // Translations
+  nameEn          String
+  namePtBr        String
+  descriptionEn   String?
+  descriptionPtBr String?
+
+  icon     String?
+  color    String?
+  order    Int     @default(0)
+  isActive Boolean @default(true)
+
+  niches TechNiche[]
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([type])
+  @@index([order])
+  @@index([isActive])
+}
+
+model TechNiche {
+  id   String @id @default(cuid())
+  slug String @unique
+
+  // Translations
+  nameEn          String
+  namePtBr        String
+  descriptionEn   String?
+  descriptionPtBr String?
+
+  icon     String?
+  color    String?
+  order    Int     @default(0)
+  isActive Boolean @default(true)
+
+  // Relations
+  areaId String
+  area   TechArea    @relation(fields: [areaId], references: [id], onDelete: Cascade)
+  skills TechSkill[]
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([areaId])
+  @@index([slug])
+  @@index([order])
+  @@index([isActive])
+}
+
+model TechSkill {
+  id   String @id @default(cuid())
+  slug String @unique
+
+  // Translations
+  nameEn          String
+  namePtBr        String
+  descriptionEn   String?
+  descriptionPtBr String?
+
+  type SkillType @default(OTHER)
+
+  // Metadata
+  icon    String?
+  color   String?
+  website String?
+
+  // Categorization
+  nicheId String?
+  niche   TechNiche? @relation(fields: [nicheId], references: [id], onDelete: SetNull)
+
+  // Search optimization
+  aliases  String[]
+  keywords String[]
+
+  // Popularity/ordering
+  popularity Int     @default(0)
+  order      Int     @default(0)
+  isActive   Boolean @default(true)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([nicheId])
+  @@index([type])
+  @@index([slug])
+  @@index([popularity])
+  @@index([order])
+  @@index([isActive])
+}
+
+// Spoken Languages Catalog
+model SpokenLanguage {
+  id   String @id @default(cuid())
+  code String @unique
+
+  // Translations for the language name
+  nameEn   String
+  namePtBr String
+  nameEs   String
+
+  // Native name
+  nativeName String?
+
+  // Ordering and status
+  order    Int     @default(0)
+  isActive Boolean @default(true)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([code])
+  @@index([order])
+  @@index([isActive])
+}
+
+// Programming Languages Catalog
+model ProgrammingLanguage {
+  id   String @id @default(cuid())
+  slug String @unique
+
+  // Translations
+  nameEn          String
+  namePtBr        String
+  descriptionEn   String?
+  descriptionPtBr String?
+
+  // Metadata
+  icon    String?
+  color   String?
+  website String?
+
+  // Typing
+  paradigms String[]
+  typing    String?
+
+  // Search
+  aliases        String[]
+  fileExtensions String[]
+
+  popularity Int     @default(0)
+  order      Int     @default(0)
+  isActive   Boolean @default(true)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([slug])
+  @@index([popularity])
+  @@index([order])
+  @@index([isActive])
+}
diff --git a/prisma/schema/enums.prisma b/prisma/schema/enums.prisma
new file mode 100644
index 0000000..7b1f24f
--- /dev/null
+++ b/prisma/schema/enums.prisma
@@ -0,0 +1,58 @@
+// Enums shared across models
+
+enum UserRole {
+  USER
+  ADMIN
+  APPROVER
+}
+
+enum ThemeStatus {
+  DRAFT
+  PRIVATE
+  PENDING_APPROVAL
+  PUBLISHED
+  REJECTED
+}
+
+enum ThemeCategory {
+  PROFESSIONAL
+  CREATIVE
+  TECHNICAL
+  ACADEMIC
+  MINIMAL
+  MODERN
+  CLASSIC
+  EXECUTIVE
+}
+
+enum MecSyncStatus {
+  RUNNING
+  SUCCESS
+  FAILED
+  PARTIAL
+}
+
+enum TechAreaType {
+  DEVELOPMENT
+  DEVOPS
+  DATA
+  SECURITY
+  DESIGN
+  PRODUCT
+  QA
+  INFRASTRUCTURE
+  OTHER
+}
+
+enum SkillType {
+  LANGUAGE
+  FRAMEWORK
+  LIBRARY
+  DATABASE
+  TOOL
+  PLATFORM
+  METHODOLOGY
+  SOFT_SKILL
+  CERTIFICATION
+  OTHER
+}
diff --git a/prisma/schema/main.prisma b/prisma/schema/main.prisma
new file mode 100644
index 0000000..7f9f9d2
--- /dev/null
+++ b/prisma/schema/main.prisma
@@ -0,0 +1,11 @@
+// Prisma Generator and Datasource Configuration
+// Prisma 5.15+ supports multi-file schemas natively (no preview feature needed)
+
+generator client {
+  provider = "prisma-client-js"
+}
+
+datasource db {
+  provider = "postgresql"
+  url      = env("DATABASE_URL")
+}
diff --git a/prisma/schema/mec.prisma b/prisma/schema/mec.prisma
new file mode 100644
index 0000000..fd78d48
--- /dev/null
+++ b/prisma/schema/mec.prisma
@@ -0,0 +1,80 @@
+// MEC Data - Brazilian Higher Education
+
+model MecInstitution {
+  id              String @id @default(cuid())
+  codigoIes       Int    @unique
+  codigoMunicipio Int?
+
+  nome        String
+  sigla       String?
+  organizacao String?
+  categoria   String?
+
+  uf        String
+  municipio String?
+
+  isActive Boolean     @default(true)
+  courses  MecCourse[]
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([nome])
+  @@index([sigla])
+  @@index([uf])
+  @@index([categoria])
+  @@index([isActive])
+  @@index([codigoMunicipio])
+}
+
+model MecCourse {
+  id          String @id @default(cuid())
+  codigoCurso Int    @unique
+  codigoIes   Int
+
+  nome             String
+  grau             String?
+  modalidade       String?
+  areaConhecimento String?
+  cargaHoraria     Int?
+  situacao         String?
+  isActive         Boolean @default(true)
+
+  institution MecInstitution @relation(fields: [codigoIes], references: [codigoIes])
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([nome])
+  @@index([codigoIes])
+  @@index([grau])
+  @@index([modalidade])
+  @@index([areaConhecimento])
+  @@index([isActive])
+  @@index([situacao])
+}
+
+model MecSyncLog {
+  id          String        @id @default(cuid())
+  status      MecSyncStatus
+  startedAt   DateTime      @default(now())
+  completedAt DateTime?
+
+  institutionsInserted Int @default(0)
+  institutionsUpdated  Int @default(0)
+  coursesInserted      Int @default(0)
+  coursesUpdated       Int @default(0)
+
+  errorMessage       String? @db.Text
+  errorDetails       Json?
+  sourceUrl          String?
+  sourceFileSize     Int?
+  totalRowsProcessed Int?
+  triggeredBy        String?
+
+  createdAt DateTime @default(now())
+
+  @@index([status])
+  @@index([startedAt])
+  @@index([createdAt])
+}
diff --git a/prisma/schema/resume-personality.prisma b/prisma/schema/resume-personality.prisma
new file mode 100644
index 0000000..b9753d8
--- /dev/null
+++ b/prisma/schema/resume-personality.prisma
@@ -0,0 +1,149 @@
+// Resume Personality - Advanced sections for tech professionals
+
+model Achievement {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  type            String
+  title           String
+  description     String?  @db.Text
+  badgeUrl        String?
+  verificationUrl String?
+  achievedAt      DateTime
+  value           Int?
+  rank            String?
+  order           Int      @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([resumeId, type])
+  @@index([resumeId, order])
+}
+
+model Publication {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  title           String
+  publisher       String
+  publicationType String
+  url             String?
+  publishedAt     DateTime
+  abstract        String?  @db.Text
+  coAuthors       String[]
+  citations       Int?     @default(0)
+  order           Int      @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([resumeId, order])
+  @@index([publicationType])
+}
+
+model Talk {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  title       String
+  event       String
+  eventType   String
+  location    String?
+  date        DateTime
+  description String?  @db.Text
+  slidesUrl   String?
+  videoUrl    String?
+  attendees   Int?
+  order       Int      @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([resumeId, order])
+  @@index([eventType])
+}
+
+model OpenSourceContribution {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  projectName  String
+  projectUrl   String
+  role         String
+  description  String?   @db.Text
+  technologies String[]
+  commits      Int?      @default(0)
+  prsCreated   Int?      @default(0)
+  prsMerged    Int?      @default(0)
+  issuesClosed Int?      @default(0)
+  stars        Int?      @default(0)
+  startDate    DateTime
+  endDate      DateTime?
+  isCurrent    Boolean   @default(false)
+  order        Int       @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([resumeId, order])
+  @@index([role])
+}
+
+model BugBounty {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  platform          String
+  company           String
+  severity          String
+  vulnerabilityType String
+  cveId             String?
+  reward            Float?
+  currency          String?   @default("USD")
+  reportUrl         String?
+  reportedAt        DateTime
+  resolvedAt        DateTime?
+  order             Int       @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([resumeId, order])
+  @@index([severity])
+}
+
+model Hackathon {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  name         String
+  organizer    String
+  position     String?
+  projectName  String
+  description  String?  @db.Text
+  technologies String[]
+  teamSize     Int?
+  demoUrl      String?
+  repoUrl      String?
+  date         DateTime
+  prize        String?
+  order        Int      @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([resumeId, order])
+}
diff --git a/prisma/schema/resume-sections.prisma b/prisma/schema/resume-sections.prisma
new file mode 100644
index 0000000..63be3e8
--- /dev/null
+++ b/prisma/schema/resume-sections.prisma
@@ -0,0 +1,181 @@
+// Resume Sections - Basic sections (Experience, Education, Skills, etc.)
+
+model Experience {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  company     String
+  position    String
+  startDate   DateTime
+  endDate     DateTime?
+  isCurrent   Boolean   @default(false)
+  location    String?
+  description String?   @db.Text
+  skills      String[]
+  order       Int       @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([order])
+  @@index([resumeId, order])
+  @@index([isCurrent])
+}
+
+model Education {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  institution String
+  degree      String
+  field       String
+  startDate   DateTime
+  endDate     DateTime?
+  isCurrent   Boolean   @default(false)
+  location    String?
+  description String?   @db.Text
+  gpa         String?
+  order       Int       @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([order])
+  @@index([resumeId, order])
+  @@index([isCurrent])
+}
+
+model Skill {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  name     String
+  category String
+  level    Int?
+  order    Int    @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([category])
+  @@index([resumeId, category])
+  @@index([resumeId, order])
+}
+
+model Language {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  name      String
+  level     String
+  cefrLevel String?
+  order     Int     @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([resumeId, order])
+}
+
+model Project {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  name         String
+  description  String?   @db.Text
+  url          String?
+  startDate    DateTime?
+  endDate      DateTime?
+  isCurrent    Boolean   @default(false)
+  technologies String[]
+  order        Int       @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([resumeId, order])
+  @@index([isCurrent])
+}
+
+model Certification {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  name          String
+  issuer        String
+  issueDate     DateTime
+  expiryDate    DateTime?
+  credentialId  String?
+  credentialUrl String?
+  order         Int       @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([resumeId, order])
+}
+
+model Award {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  title       String
+  issuer      String
+  date        DateTime
+  description String?  @db.Text
+  order       Int      @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([order])
+}
+
+model Recommendation {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  author   String
+  position String?
+  company  String?
+  content  String    @db.Text
+  date     DateTime?
+  order    Int       @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([order])
+}
+
+model Interest {
+  id       String @id @default(cuid())
+  resumeId String
+  resume   Resume @relation(fields: [resumeId], references: [id], onDelete: Cascade)
+
+  name        String
+  description String? @db.Text
+  order       Int     @default(0)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([resumeId])
+  @@index([order])
+}
diff --git a/prisma/schema/resume.prisma b/prisma/schema/resume.prisma
new file mode 100644
index 0000000..a03d198
--- /dev/null
+++ b/prisma/schema/resume.prisma
@@ -0,0 +1,88 @@
+// Resume Model - Core resume entity
+
+model Resume {
+  id     String @id @default(cuid())
+  userId String
+  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
+
+  title    String?
+  template String  @default("professional")
+  language String  @default("pt-br")
+  isPublic Boolean @default(false)
+  slug     String? @unique
+
+  // Bilingual content
+  contentPtBr     Json?
+  contentEn       Json?
+  primaryLanguage String @default("pt-br")
+
+  // Tech Persona
+  techPersona     String?
+  techArea        String?
+  primaryStack    String[]
+  experienceYears Int?     @default(0)
+
+  // Contact info
+  fullName     String?
+  jobTitle     String?
+  phone        String?
+  emailContact String?
+  location     String?
+  linkedin     String?
+  github       String?
+  website      String?
+  summary      String? @db.Text
+
+  currentCompanyLogo String?
+
+  // Social links
+  twitter       String?
+  medium        String?
+  devto         String?
+  stackoverflow String?
+  kaggle        String?
+  hackerrank    String?
+  leetcode      String?
+
+  // Visual customization
+  accentColor String? @default("#3B82F6")
+  customTheme Json?
+
+  // Theme System
+  activeThemeId String?
+  activeTheme   ResumeTheme? @relation("ResumeActiveTheme", fields: [activeThemeId], references: [id], onDelete: SetNull)
+
+  // Stats
+  profileViews Int @default(0)
+  totalStars   Int @default(0)
+  totalCommits Int @default(0)
+
+  createdAt   DateTime  @default(now())
+  updatedAt   DateTime  @updatedAt
+  publishedAt DateTime?
+
+  // Relations
+  experiences     Experience[]
+  education       Education[]
+  skills          Skill[]
+  languages       Language[]
+  projects        Project[]
+  certifications  Certification[]
+  awards          Award[]
+  recommendations Recommendation[]
+  interests       Interest[]
+  achievements    Achievement[]
+  publications    Publication[]
+  talks           Talk[]
+  openSource      OpenSourceContribution[]
+  bugBounties     BugBounty[]
+  hackathons      Hackathon[]
+
+  @@index([userId])
+  @@index([slug])
+  @@index([isPublic])
+  @@index([createdAt])
+  @@index([techPersona])
+  @@index([activeThemeId])
+  @@index([primaryLanguage])
+}
diff --git a/prisma/schema/theme.prisma b/prisma/schema/theme.prisma
new file mode 100644
index 0000000..8f85988
--- /dev/null
+++ b/prisma/schema/theme.prisma
@@ -0,0 +1,53 @@
+// Theme System - Customizable resume themes
+
+model ResumeTheme {
+  id String @id @default(cuid())
+
+  name        String
+  description String? @db.Text
+
+  authorId String
+  author   User   @relation("ThemeAuthor", fields: [authorId], references: [id], onDelete: Cascade)
+
+  category    ThemeCategory @default(MODERN)
+  tags        String[]
+  styleConfig Json
+
+  thumbnailUrl  String?
+  previewImages String[]
+
+  status        ThemeStatus @default(PRIVATE)
+  isSystemTheme Boolean     @default(false)
+
+  // Approval workflow
+  approvedById    String?
+  approvedBy      User?     @relation("ThemeApprover", fields: [approvedById], references: [id], onDelete: SetNull)
+  approvedAt      DateTime?
+  rejectionReason String?   @db.Text
+
+  // Stats
+  usageCount  Int    @default(0)
+  rating      Float?
+  ratingCount Int    @default(0)
+
+  // Versioning
+  version       String        @default("1.0.0")
+  parentThemeId String?
+  parentTheme   ResumeTheme?  @relation("ThemeForks", fields: [parentThemeId], references: [id], onDelete: SetNull)
+  forks         ResumeTheme[] @relation("ThemeForks")
+
+  createdAt   DateTime  @default(now())
+  updatedAt   DateTime  @updatedAt
+  publishedAt DateTime?
+
+  resumes Resume[] @relation("ResumeActiveTheme")
+
+  @@index([authorId])
+  @@index([status])
+  @@index([category])
+  @@index([isSystemTheme])
+  @@index([usageCount])
+  @@index([rating])
+  @@index([createdAt])
+  @@index([publishedAt])
+}
diff --git a/prisma/schema/user.prisma b/prisma/schema/user.prisma
new file mode 100644
index 0000000..16f4b16
--- /dev/null
+++ b/prisma/schema/user.prisma
@@ -0,0 +1,114 @@
+// User and Preferences Models
+
+model User {
+  id            String    @id @default(cuid())
+  name          String?
+  email         String?   @unique
+  emailVerified DateTime?
+  image         String?
+  password      String?
+  role          UserRole  @default(USER)
+
+  accounts Account[]
+  sessions Session[]
+
+  // Profile fields
+  username          String?   @unique
+  usernameUpdatedAt DateTime?
+  displayName       String?
+  photoURL          String?
+  bio               String?   @db.Text
+  location          String?
+  phone             String?
+  website           String?
+  linkedin          String?
+  github            String?
+
+  // Legacy preference fields
+  bannerColor String?
+  palette     String?
+
+  // Onboarding tracking
+  hasCompletedOnboarding Boolean   @default(false)
+  onboardingCompletedAt  DateTime?
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  resumes            Resume[]
+  preferences        UserPreferences?
+  onboardingProgress OnboardingProgress?
+
+  // Theme system
+  createdThemes  ResumeTheme[] @relation("ThemeAuthor")
+  approvedThemes ResumeTheme[] @relation("ThemeApprover")
+
+  @@index([username])
+  @@index([email])
+  @@index([role])
+  @@index([hasCompletedOnboarding])
+}
+
+model UserPreferences {
+  id     String @id @default(cuid())
+  userId String @unique
+  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
+
+  // Appearance
+  theme       String  @default("dark")
+  palette     String  @default("ocean")
+  bannerColor String?
+
+  // Localization
+  language   String @default("en")
+  dateFormat String @default("MM/DD/YYYY")
+  timezone   String @default("UTC")
+
+  // Notifications
+  emailNotifications Boolean @default(true)
+  resumeExpiryAlerts Boolean @default(true)
+  weeklyDigest       Boolean @default(false)
+  marketingEmails    Boolean @default(false)
+
+  // Privacy
+  profileVisibility      String  @default("private")
+  showEmail              Boolean @default(false)
+  showPhone              Boolean @default(false)
+  allowSearchEngineIndex Boolean @default(false)
+
+  // Export defaults
+  defaultExportFormat  String  @default("pdf")
+  includePhotoInExport Boolean @default(true)
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([userId])
+}
+
+model OnboardingProgress {
+  id     String @id @default(cuid())
+  userId String @unique
+  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
+
+  currentStep    String   @default("welcome")
+  completedSteps String[] @default([])
+  username       String?
+
+  // Form data (JSON)
+  personalInfo        Json?
+  professionalProfile Json?
+  experiences         Json?
+  noExperience        Boolean @default(false)
+  education           Json?
+  noEducation         Boolean @default(false)
+  skills              Json?
+  noSkills            Boolean @default(false)
+  languages           Json?
+  templateSelection   Json?
+
+  createdAt DateTime @default(now())
+  updatedAt DateTime @updatedAt
+
+  @@index([userId])
+}
diff --git a/src/admin/admin.controller.ts b/src/admin/admin.controller.ts
index 376eed4..187f884 100644
--- a/src/admin/admin.controller.ts
+++ b/src/admin/admin.controller.ts
@@ -1,205 +1,11 @@
-import {
-  Controller,
-  Get,
-  Post,
-  Patch,
-  Delete,
-  Body,
-  Param,
-  Query,
-  UseGuards,
-  HttpCode,
-  HttpStatus,
-} from '@nestjs/common';
-import {
-  ApiTags,
-  ApiOperation,
-  ApiResponse,
-  ApiBearerAuth,
-  ApiQuery,
-} from '@nestjs/swagger';
-import { AdminService } from './admin.service';
-import { CreateUserDto } from './dto/create-user.dto';
-import { UpdateUserDto } from './dto/update-user.dto';
-import { AdminResetPasswordDto } from './dto/reset-password.dto';
-import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
-import { RolesGuard } from '../common/guards/roles.guard';
-import { Roles } from '../common/decorators/roles.decorator';
-import { UserRole } from '../common/enums/user-role.enum';
-
-@ApiTags('admin')
-@ApiBearerAuth('JWT-auth')
-@Controller('admin')
-@UseGuards(JwtAuthGuard, RolesGuard)
-@Roles(UserRole.ADMIN)
-export class AdminController {
-  constructor(private readonly adminService: AdminService) {}
-
-  @Get('users')
-  @ApiOperation({ summary: 'Get all users (Admin only)' })
-  @ApiQuery({ name: 'page', required: false, type: Number })
-  @ApiQuery({ name: 'limit', required: false, type: Number })
-  @ApiQuery({ name: 'search', required: false, type: String })
-  @ApiQuery({ name: 'role', required: false, enum: UserRole })
-  @ApiResponse({ status: 200, description: 'Users retrieved successfully' })
-  @ApiResponse({ status: 401, description: 'Unauthorized' })
-  @ApiResponse({ status: 403, description: 'Forbidden - Admin only' })
-  async getAllUsers(
-    @Query('page') page?: number,
-    @Query('limit') limit?: number,
-    @Query('search') search?: string,
-    @Query('role') role?: UserRole,
-  ) {
-    return this.adminService.getAllUsers({
-      page: page ? Number(page) : 1,
-      limit: limit ? Number(limit) : 20,
-      search,
-      role,
-    });
-  }
-
-  @Get('users/:id')
-  @ApiOperation({ summary: 'Get user by ID with full details (Admin only)' })
-  @ApiResponse({ status: 200, description: 'User retrieved successfully' })
-  @ApiResponse({ status: 401, description: 'Unauthorized' })
-  @ApiResponse({ status: 403, description: 'Forbidden - Admin only' })
-  @ApiResponse({ status: 404, description: 'User not found' })
-  async getUserById(@Param('id') id: string) {
-    return this.adminService.getUserById(id);
-  }
-
-  @Post('users')
-  @HttpCode(HttpStatus.CREATED)
-  @ApiOperation({ summary: 'Create new user (Admin only)' })
-  @ApiResponse({ status: 201, description: 'User created successfully' })
-  @ApiResponse({ status: 400, description: 'Invalid input data' })
-  @ApiResponse({ status: 401, description: 'Unauthorized' })
-  @ApiResponse({ status: 403, description: 'Forbidden - Admin only' })
-  @ApiResponse({ status: 409, description: 'Email already exists' })
-  async createUser(@Body() createUserDto: CreateUserDto) {
-    return this.adminService.createUser(createUserDto);
-  }
-
-  @Patch('users/:id')
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({ summary: 'Update user (Admin only)' })
-  @ApiResponse({ status: 200, description: 'User updated successfully' })
-  @ApiResponse({ status: 400, description: 'Invalid input data' })
-  @ApiResponse({ status: 401, description: 'Unauthorized' })
-  @ApiResponse({ status: 403, description: 'Forbidden - Admin only' })
-  @ApiResponse({ status: 404, description: 'User not found' })
-  async updateUser(
-    @Param('id') id: string,
-    @Body() updateUserDto: UpdateUserDto,
-  ) {
-    return this.adminService.updateUser(id, updateUserDto);
-  }
-
-  @Delete('users/:id')
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({ summary: 'Delete user (Admin only)' })
-  @ApiResponse({ status: 200, description: 'User deleted successfully' })
-  @ApiResponse({ status: 401, description: 'Unauthorized' })
-  @ApiResponse({ status: 403, description: 'Forbidden - Admin only' })
-  @ApiResponse({ status: 404, description: 'User not found' })
-  async deleteUser(@Param('id') id: string) {
-    return this.adminService.deleteUser(id);
-  }
-
-  @Post('users/:id/reset-password')
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({ summary: 'Reset user password (Admin only)' })
-  @ApiResponse({ status: 200, description: 'Password reset successfully' })
-  @ApiResponse({ status: 400, description: 'Invalid input data' })
-  @ApiResponse({ status: 401, description: 'Unauthorized' })
-  @ApiResponse({ status: 403, description: 'Forbidden - Admin only' })
-  @ApiResponse({ status: 404, description: 'User not found' })
-  async resetUserPassword(
-    @Param('id') id: string,
-    @Body() dto: AdminResetPasswordDto,
-  ) {
-    return this.adminService.resetUserPassword(id, dto);
-  }
-
-  @Get('stats')
-  @ApiOperation({ summary: 'Get platform statistics (Admin only)' })
-  @ApiResponse({
-    status: 200,
-    description: 'Statistics retrieved successfully',
-  })
-  @ApiResponse({ status: 401, description: 'Unauthorized' })
-  @ApiResponse({ status: 403, description: 'Forbidden - Admin only' })
-  async getStats() {
-    return this.adminService.getStats();
-  }
-
-  // ==================== Resume Management ====================
-
-  @Get('users/:userId/resumes')
-  @ApiOperation({ summary: 'Get all resumes for a user (Admin only)' })
-  @ApiResponse({ status: 200, description: 'Resumes retrieved successfully' })
-  @ApiResponse({ status: 404, description: 'User not found' })
-  async getUserResumes(@Param('userId') userId: string) {
-    return this.adminService.getUserResumes(userId);
-  }
-
-  @Get('resumes/:resumeId')
-  @ApiOperation({ summary: 'Get resume by ID with all details (Admin only)' })
-  @ApiResponse({ status: 200, description: 'Resume retrieved successfully' })
-  @ApiResponse({ status: 404, description: 'Resume not found' })
-  async getResumeById(@Param('resumeId') resumeId: string) {
-    return this.adminService.getResumeById(resumeId);
-  }
-
-  @Delete('resumes/:resumeId')
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({ summary: 'Delete resume (Admin only)' })
-  @ApiResponse({ status: 200, description: 'Resume deleted successfully' })
-  @ApiResponse({ status: 404, description: 'Resume not found' })
-  async deleteResume(@Param('resumeId') resumeId: string) {
-    return this.adminService.deleteResume(resumeId);
-  }
-
-  // ==================== Skills Management ====================
-
-  @Get('resumes/:resumeId/skills')
-  @ApiOperation({ summary: 'Get all skills for a resume (Admin only)' })
-  @ApiResponse({ status: 200, description: 'Skills retrieved successfully' })
-  @ApiResponse({ status: 404, description: 'Resume not found' })
-  async getResumeSkills(@Param('resumeId') resumeId: string) {
-    return this.adminService.getResumeSkills(resumeId);
-  }
-
-  @Post('resumes/:resumeId/skills')
-  @HttpCode(HttpStatus.CREATED)
-  @ApiOperation({ summary: 'Add skill to resume (Admin only)' })
-  @ApiResponse({ status: 201, description: 'Skill added successfully' })
-  @ApiResponse({ status: 404, description: 'Resume not found' })
-  async addSkillToResume(
-    @Param('resumeId') resumeId: string,
-    @Body() skillData: { name: string; category: string; level?: number },
-  ) {
-    return this.adminService.addSkillToResume(resumeId, skillData);
-  }
-
-  @Patch('skills/:skillId')
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({ summary: 'Update skill (Admin only)' })
-  @ApiResponse({ status: 200, description: 'Skill updated successfully' })
-  @ApiResponse({ status: 404, description: 'Skill not found' })
-  async updateSkill(
-    @Param('skillId') skillId: string,
-    @Body() skillData: { name?: string; category?: string; level?: number },
-  ) {
-    return this.adminService.updateSkill(skillId, skillData);
-  }
-
-  @Delete('skills/:skillId')
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({ summary: 'Delete skill (Admin only)' })
-  @ApiResponse({ status: 200, description: 'Skill deleted successfully' })
-  @ApiResponse({ status: 404, description: 'Skill not found' })
-  async deleteSkill(@Param('skillId') skillId: string) {
-    return this.adminService.deleteSkill(skillId);
-  }
-}
+/**
+ * Admin Controller
+ * Re-exports specialized controllers for backward compatibility
+ * @deprecated Import from './controllers' instead
+ */
+
+export {
+  AdminUsersController,
+  AdminResumesController,
+  AdminSkillsController,
+} from './controllers';
diff --git a/src/admin/admin.module.ts b/src/admin/admin.module.ts
index 712b6de..d826668 100644
--- a/src/admin/admin.module.ts
+++ b/src/admin/admin.module.ts
@@ -1,12 +1,37 @@
 import { Module } from '@nestjs/common';
-import { AdminController } from './admin.controller';
+import {
+  AdminUsersController,
+  AdminResumesController,
+  AdminSkillsController,
+} from './controllers';
 import { AdminService } from './admin.service';
 import { PrismaModule } from '../prisma/prisma.module';
+import { AuthModule } from '../auth/auth.module';
+import {
+  UserAdminService,
+  UserAdminQueryService,
+  UserAdminMutationService,
+  AdminStatsService,
+  ResumeAdminService,
+  SkillAdminService,
+} from './services';
 
 @Module({
-  imports: [PrismaModule],
-  controllers: [AdminController],
-  providers: [AdminService],
+  imports: [PrismaModule, AuthModule],
+  controllers: [
+    AdminUsersController,
+    AdminResumesController,
+    AdminSkillsController,
+  ],
+  providers: [
+    AdminService,
+    UserAdminQueryService,
+    UserAdminMutationService,
+    UserAdminService,
+    AdminStatsService,
+    ResumeAdminService,
+    SkillAdminService,
+  ],
   exports: [AdminService],
 })
 export class AdminModule {}
diff --git a/src/admin/admin.service.ts b/src/admin/admin.service.ts
index 5010e33..e1ab50e 100644
--- a/src/admin/admin.service.ts
+++ b/src/admin/admin.service.ts
@@ -1,457 +1,92 @@
-import {
-  Injectable,
-  NotFoundException,
-  ConflictException,
-  BadRequestException,
-} from '@nestjs/common';
-import { PrismaService } from '../prisma/prisma.service';
+/**
+ * Admin Service (Refactored)
+ * Single Responsibility: Facade that delegates to specialized admin services
+ */
+
+import { Injectable } from '@nestjs/common';
 import { CreateUserDto } from './dto/create-user.dto';
 import { UpdateUserDto } from './dto/update-user.dto';
 import { AdminResetPasswordDto } from './dto/reset-password.dto';
-import { UserRole } from '../common/enums/user-role.enum';
-import * as bcrypt from 'bcryptjs';
-
-interface GetAllUsersOptions {
-  page: number;
-  limit: number;
-  search?: string;
-  role?: UserRole;
-}
+import {
+  UserAdminService,
+  GetAllUsersOptions,
+  AdminStatsService,
+  ResumeAdminService,
+  SkillAdminService,
+  CreateSkillData,
+  UpdateSkillData,
+} from './services';
 
 @Injectable()
 export class AdminService {
-  constructor(private prisma: PrismaService) {}
-
-  async getAllUsers(options: GetAllUsersOptions) {
-    const { page, limit, search, role } = options;
-    const skip = (page - 1) * limit;
-
-    const where: any = {};
+  constructor(
+    private readonly userAdminService: UserAdminService,
+    private readonly statsService: AdminStatsService,
+    private readonly resumeAdminService: ResumeAdminService,
+    private readonly skillAdminService: SkillAdminService,
+  ) {}
 
-    if (search) {
-      where.OR = [
-        { email: { contains: search, mode: 'insensitive' } },
-        { name: { contains: search, mode: 'insensitive' } },
-        { username: { contains: search, mode: 'insensitive' } },
-      ];
-    }
+  // ==================== User Management ====================
 
-    if (role) {
-      where.role = role;
-    }
-
-    const [users, total] = await Promise.all([
-      this.prisma.user.findMany({
-        where,
-        skip,
-        take: limit,
-        select: {
-          id: true,
-          email: true,
-          name: true,
-          username: true,
-          role: true,
-          hasCompletedOnboarding: true,
-          createdAt: true,
-          updatedAt: true,
-          image: true,
-          emailVerified: true,
-          _count: {
-            select: {
-              resumes: true,
-            },
-          },
-        },
-        orderBy: { createdAt: 'desc' },
-      }),
-      this.prisma.user.count({ where }),
-    ]);
-
-    return {
-      users,
-      pagination: {
-        page,
-        limit,
-        total,
-        totalPages: Math.ceil(total / limit),
-      },
-    };
+  async getAllUsers(options: GetAllUsersOptions) {
+    return this.userAdminService.getAll(options);
   }
 
   async getUserById(id: string) {
-    const user = await this.prisma.user.findUnique({
-      where: { id },
-      include: {
-        resumes: {
-          select: {
-            id: true,
-            title: true,
-            template: true,
-            isPublic: true,
-            createdAt: true,
-            updatedAt: true,
-          },
-        },
-        preferences: true,
-        _count: {
-          select: {
-            accounts: true,
-            sessions: true,
-            resumes: true,
-          },
-        },
-      },
-    });
-
-    if (!user) {
-      throw new NotFoundException('User not found');
-    }
-
-    // Don't return password
-    const { password, ...userWithoutPassword } = user;
-
-    return userWithoutPassword;
+    return this.userAdminService.getById(id);
   }
 
   async createUser(createUserDto: CreateUserDto) {
-    const { email, password, name, role } = createUserDto;
-
-    // Check if email already exists
-    const existingUser = await this.prisma.user.findUnique({
-      where: { email },
-    });
-
-    if (existingUser) {
-      throw new ConflictException('Email already registered');
-    }
-
-    // Hash password
-    const saltRounds = parseInt(process.env.BCRYPT_SALT_ROUNDS || '10', 10);
-    const hashedPassword = await bcrypt.hash(password, saltRounds);
-
-    // Create user
-    const user = await this.prisma.user.create({
-      data: {
-        email,
-        password: hashedPassword,
-        name,
-        role: role || UserRole.USER,
-      },
-      select: {
-        id: true,
-        email: true,
-        name: true,
-        role: true,
-        createdAt: true,
-      },
-    });
-
-    return {
-      success: true,
-      user,
-      message: 'User created successfully',
-    };
+    return this.userAdminService.create(createUserDto);
   }
 
   async updateUser(id: string, updateUserDto: UpdateUserDto) {
-    const user = await this.prisma.user.findUnique({ where: { id } });
-
-    if (!user) {
-      throw new NotFoundException('User not found');
-    }
-
-    // If updating email, check if new email is already taken
-    if (updateUserDto.email && updateUserDto.email !== user.email) {
-      const existingUser = await this.prisma.user.findUnique({
-        where: { email: updateUserDto.email },
-      });
-
-      if (existingUser) {
-        throw new ConflictException('Email already in use');
-      }
-    }
-
-    // If updating username, check if new username is already taken
-    if (updateUserDto.username && updateUserDto.username !== user.username) {
-      const existingUser = await this.prisma.user.findUnique({
-        where: { username: updateUserDto.username },
-      });
-
-      if (existingUser) {
-        throw new ConflictException('Username already in use');
-      }
-    }
-
-    const updatedUser = await this.prisma.user.update({
-      where: { id },
-      data: updateUserDto,
-      select: {
-        id: true,
-        email: true,
-        name: true,
-        username: true,
-        role: true,
-        hasCompletedOnboarding: true,
-        updatedAt: true,
-      },
-    });
-
-    return {
-      success: true,
-      user: updatedUser,
-      message: 'User updated successfully',
-    };
+    return this.userAdminService.update(id, updateUserDto);
   }
 
   async deleteUser(id: string) {
-    const user = await this.prisma.user.findUnique({ where: { id } });
-
-    if (!user) {
-      throw new NotFoundException('User not found');
-    }
-
-    // Prevent deleting the last admin
-    if (user.role === UserRole.ADMIN) {
-      const adminCount = await this.prisma.user.count({
-        where: { role: UserRole.ADMIN },
-      });
-
-      if (adminCount <= 1) {
-        throw new BadRequestException('Cannot delete the last admin user');
-      }
-    }
-
-    await this.prisma.user.delete({ where: { id } });
-
-    return {
-      success: true,
-      message: 'User deleted successfully',
-    };
+    return this.userAdminService.delete(id);
   }
 
   async resetUserPassword(id: string, dto: AdminResetPasswordDto) {
-    const user = await this.prisma.user.findUnique({ where: { id } });
-
-    if (!user) {
-      throw new NotFoundException('User not found');
-    }
-
-    const saltRounds = parseInt(process.env.BCRYPT_SALT_ROUNDS || '10', 10);
-    const hashedPassword = await bcrypt.hash(dto.newPassword, saltRounds);
-
-    await this.prisma.user.update({
-      where: { id },
-      data: { password: hashedPassword },
-    });
-
-    return {
-      success: true,
-      message: 'Password reset successfully',
-    };
+    return this.userAdminService.resetPassword(id, dto);
   }
 
-  async getStats() {
-    const [
-      totalUsers,
-      totalAdmins,
-      totalResumes,
-      usersWithOnboarding,
-      recentUsers,
-    ] = await Promise.all([
-      this.prisma.user.count(),
-      this.prisma.user.count({ where: { role: UserRole.ADMIN } }),
-      this.prisma.resume.count(),
-      this.prisma.user.count({ where: { hasCompletedOnboarding: true } }),
-      this.prisma.user.count({
-        where: {
-          createdAt: {
-            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // Last 7 days
-          },
-        },
-      }),
-    ]);
+  // ==================== Stats ====================
 
-    return {
-      users: {
-        total: totalUsers,
-        admins: totalAdmins,
-        regular: totalUsers - totalAdmins,
-        withOnboarding: usersWithOnboarding,
-        recentSignups: recentUsers,
-      },
-      resumes: {
-        total: totalResumes,
-      },
-    };
+  async getStats() {
+    return this.statsService.getStats();
   }
 
   // ==================== Resume Management ====================
 
   async getUserResumes(userId: string) {
-    const user = await this.prisma.user.findUnique({ where: { id: userId } });
-    if (!user) {
-      throw new NotFoundException('User not found');
-    }
-
-    const resumes = await this.prisma.resume.findMany({
-      where: { userId },
-      include: {
-        skills: true,
-        experiences: true,
-        education: true,
-        _count: {
-          select: {
-            skills: true,
-            experiences: true,
-            education: true,
-            projects: true,
-            certifications: true,
-          },
-        },
-      },
-      orderBy: { updatedAt: 'desc' },
-    });
-
-    return { resumes };
+    return this.resumeAdminService.getUserResumes(userId);
   }
 
   async getResumeById(resumeId: string) {
-    const resume = await this.prisma.resume.findUnique({
-      where: { id: resumeId },
-      include: {
-        user: {
-          select: {
-            id: true,
-            email: true,
-            name: true,
-          },
-        },
-        skills: { orderBy: { order: 'asc' } },
-        experiences: { orderBy: { order: 'asc' } },
-        education: { orderBy: { order: 'asc' } },
-        projects: { orderBy: { order: 'asc' } },
-        certifications: { orderBy: { order: 'asc' } },
-        languages: { orderBy: { order: 'asc' } },
-        awards: { orderBy: { order: 'asc' } },
-      },
-    });
-
-    if (!resume) {
-      throw new NotFoundException('Resume not found');
-    }
-
-    return resume;
+    return this.resumeAdminService.getById(resumeId);
   }
 
   async deleteResume(resumeId: string) {
-    const resume = await this.prisma.resume.findUnique({
-      where: { id: resumeId },
-    });
-
-    if (!resume) {
-      throw new NotFoundException('Resume not found');
-    }
-
-    await this.prisma.resume.delete({ where: { id: resumeId } });
-
-    return {
-      success: true,
-      message: 'Resume deleted successfully',
-    };
+    return this.resumeAdminService.delete(resumeId);
   }
 
   // ==================== Skills Management ====================
 
   async getResumeSkills(resumeId: string) {
-    const resume = await this.prisma.resume.findUnique({
-      where: { id: resumeId },
-    });
-
-    if (!resume) {
-      throw new NotFoundException('Resume not found');
-    }
-
-    const skills = await this.prisma.skill.findMany({
-      where: { resumeId },
-      orderBy: [{ category: 'asc' }, { order: 'asc' }],
-    });
-
-    return { skills };
+    return this.skillAdminService.getByResume(resumeId);
   }
 
-  async addSkillToResume(
-    resumeId: string,
-    data: { name: string; category: string; level?: number },
-  ) {
-    const resume = await this.prisma.resume.findUnique({
-      where: { id: resumeId },
-    });
-
-    if (!resume) {
-      throw new NotFoundException('Resume not found');
-    }
-
-    // Get the highest order number for this resume's skills
-    const lastSkill = await this.prisma.skill.findFirst({
-      where: { resumeId },
-      orderBy: { order: 'desc' },
-    });
-
-    const skill = await this.prisma.skill.create({
-      data: {
-        resumeId,
-        name: data.name,
-        category: data.category,
-        level: data.level,
-        order: (lastSkill?.order ?? -1) + 1,
-      },
-    });
-
-    return {
-      success: true,
-      skill,
-      message: 'Skill added successfully',
-    };
+  async addSkillToResume(resumeId: string, data: CreateSkillData) {
+    return this.skillAdminService.addToResume(resumeId, data);
   }
 
-  async updateSkill(
-    skillId: string,
-    data: { name?: string; category?: string; level?: number },
-  ) {
-    const skill = await this.prisma.skill.findUnique({
-      where: { id: skillId },
-    });
-
-    if (!skill) {
-      throw new NotFoundException('Skill not found');
-    }
-
-    const updatedSkill = await this.prisma.skill.update({
-      where: { id: skillId },
-      data,
-    });
-
-    return {
-      success: true,
-      skill: updatedSkill,
-      message: 'Skill updated successfully',
-    };
+  async updateSkill(skillId: string, data: UpdateSkillData) {
+    return this.skillAdminService.update(skillId, data);
   }
 
   async deleteSkill(skillId: string) {
-    const skill = await this.prisma.skill.findUnique({
-      where: { id: skillId },
-    });
-
-    if (!skill) {
-      throw new NotFoundException('Skill not found');
-    }
-
-    await this.prisma.skill.delete({ where: { id: skillId } });
-
-    return {
-      success: true,
-      message: 'Skill deleted successfully',
-    };
+    return this.skillAdminService.delete(skillId);
   }
 }
diff --git a/src/admin/controllers/admin-resumes.controller.ts b/src/admin/controllers/admin-resumes.controller.ts
new file mode 100644
index 0000000..5ad0a78
--- /dev/null
+++ b/src/admin/controllers/admin-resumes.controller.ts
@@ -0,0 +1,59 @@
+/**
+ * Admin Resumes Controller
+ * Single Responsibility: Admin operations for resume management
+ */
+
+import {
+  Controller,
+  Get,
+  Delete,
+  Param,
+  UseGuards,
+  HttpCode,
+  HttpStatus,
+} from '@nestjs/common';
+import {
+  ApiTags,
+  ApiOperation,
+  ApiResponse,
+  ApiBearerAuth,
+} from '@nestjs/swagger';
+import { AdminService } from '../admin.service';
+import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
+import { RolesGuard } from 'src/common/guards/roles.guard';
+import { Roles } from 'src/common/decorators/roles.decorator';
+import { UserRole } from 'src/common/enums/user-role.enum';
+
+@ApiTags('admin')
+@ApiBearerAuth('JWT-auth')
+@Controller('admin')
+@UseGuards(JwtAuthGuard, RolesGuard)
+@Roles(UserRole.ADMIN)
+export class AdminResumesController {
+  constructor(private readonly adminService: AdminService) {}
+
+  @Get('users/:userId/resumes')
+  @ApiOperation({ summary: 'Get all resumes for a user (Admin only)' })
+  @ApiResponse({ status: 200, description: 'Resumes retrieved successfully' })
+  @ApiResponse({ status: 404, description: 'User not found' })
+  async getUserResumes(@Param('userId') userId: string) {
+    return this.adminService.getUserResumes(userId);
+  }
+
+  @Get('resumes/:resumeId')
+  @ApiOperation({ summary: 'Get resume by ID with all details (Admin only)' })
+  @ApiResponse({ status: 200, description: 'Resume retrieved successfully' })
+  @ApiResponse({ status: 404, description: 'Resume not found' })
+  async getResumeById(@Param('resumeId') resumeId: string) {
+    return this.adminService.getResumeById(resumeId);
+  }
+
+  @Delete('resumes/:resumeId')
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({ summary: 'Delete resume (Admin only)' })
+  @ApiResponse({ status: 200, description: 'Resume deleted successfully' })
+  @ApiResponse({ status: 404, description: 'Resume not found' })
+  async deleteResume(@Param('resumeId') resumeId: string) {
+    return this.adminService.deleteResume(resumeId);
+  }
+}
diff --git a/src/admin/controllers/admin-skills.controller.ts b/src/admin/controllers/admin-skills.controller.ts
new file mode 100644
index 0000000..11ee87c
--- /dev/null
+++ b/src/admin/controllers/admin-skills.controller.ts
@@ -0,0 +1,77 @@
+/**
+ * Admin Skills Controller
+ * Single Responsibility: Admin operations for skill management
+ */
+
+import {
+  Controller,
+  Get,
+  Post,
+  Patch,
+  Delete,
+  Body,
+  Param,
+  UseGuards,
+  HttpCode,
+  HttpStatus,
+} from '@nestjs/common';
+import {
+  ApiTags,
+  ApiOperation,
+  ApiResponse,
+  ApiBearerAuth,
+} from '@nestjs/swagger';
+import { AdminService } from '../admin.service';
+import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
+import { RolesGuard } from 'src/common/guards/roles.guard';
+import { Roles } from 'src/common/decorators/roles.decorator';
+import { UserRole } from 'src/common/enums/user-role.enum';
+
+@ApiTags('admin')
+@ApiBearerAuth('JWT-auth')
+@Controller('admin')
+@UseGuards(JwtAuthGuard, RolesGuard)
+@Roles(UserRole.ADMIN)
+export class AdminSkillsController {
+  constructor(private readonly adminService: AdminService) {}
+
+  @Get('resumes/:resumeId/skills')
+  @ApiOperation({ summary: 'Get all skills for a resume (Admin only)' })
+  @ApiResponse({ status: 200, description: 'Skills retrieved successfully' })
+  @ApiResponse({ status: 404, description: 'Resume not found' })
+  async getResumeSkills(@Param('resumeId') resumeId: string) {
+    return this.adminService.getResumeSkills(resumeId);
+  }
+
+  @Post('resumes/:resumeId/skills')
+  @HttpCode(HttpStatus.CREATED)
+  @ApiOperation({ summary: 'Add skill to resume (Admin only)' })
+  @ApiResponse({ status: 201, description: 'Skill added successfully' })
+  @ApiResponse({ status: 404, description: 'Resume not found' })
+  async addSkillToResume(
+    @Param('resumeId') resumeId: string,
+    @Body() skillData: { name: string; category: string; level?: number },
+  ) {
+    return this.adminService.addSkillToResume(resumeId, skillData);
+  }
+
+  @Patch('skills/:skillId')
+  @ApiOperation({ summary: 'Update skill (Admin only)' })
+  @ApiResponse({ status: 200, description: 'Skill updated successfully' })
+  @ApiResponse({ status: 404, description: 'Skill not found' })
+  async updateSkill(
+    @Param('skillId') skillId: string,
+    @Body() skillData: { name?: string; category?: string; level?: number },
+  ) {
+    return this.adminService.updateSkill(skillId, skillData);
+  }
+
+  @Delete('skills/:skillId')
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({ summary: 'Delete skill (Admin only)' })
+  @ApiResponse({ status: 200, description: 'Skill deleted successfully' })
+  @ApiResponse({ status: 404, description: 'Skill not found' })
+  async deleteSkill(@Param('skillId') skillId: string) {
+    return this.adminService.deleteSkill(skillId);
+  }
+}
diff --git a/src/admin/controllers/admin-users.controller.ts b/src/admin/controllers/admin-users.controller.ts
new file mode 100644
index 0000000..bf4cbfe
--- /dev/null
+++ b/src/admin/controllers/admin-users.controller.ts
@@ -0,0 +1,117 @@
+/**
+ * Admin Users Controller
+ * Single Responsibility: Admin operations for user management
+ */
+
+import {
+  Controller,
+  Get,
+  Post,
+  Patch,
+  Delete,
+  Body,
+  Param,
+  Query,
+  UseGuards,
+  HttpCode,
+  HttpStatus,
+} from '@nestjs/common';
+import {
+  ApiTags,
+  ApiOperation,
+  ApiResponse,
+  ApiBearerAuth,
+  ApiQuery,
+} from '@nestjs/swagger';
+import { AdminService } from '../admin.service';
+import { CreateUserDto } from '../dto/create-user.dto';
+import { UpdateUserDto } from '../dto/update-user.dto';
+import { AdminResetPasswordDto } from '../dto/reset-password.dto';
+import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
+import { RolesGuard } from 'src/common/guards/roles.guard';
+import { Roles } from 'src/common/decorators/roles.decorator';
+import { UserRole } from 'src/common/enums/user-role.enum';
+
+@ApiTags('admin')
+@ApiBearerAuth('JWT-auth')
+@Controller('admin')
+@UseGuards(JwtAuthGuard, RolesGuard)
+@Roles(UserRole.ADMIN)
+export class AdminUsersController {
+  constructor(private readonly adminService: AdminService) {}
+
+  @Get('users')
+  @ApiOperation({ summary: 'Get all users (Admin only)' })
+  @ApiQuery({ name: 'page', required: false, type: Number })
+  @ApiQuery({ name: 'limit', required: false, type: Number })
+  @ApiQuery({ name: 'search', required: false, type: String })
+  @ApiQuery({ name: 'role', required: false, enum: UserRole })
+  @ApiResponse({ status: 200, description: 'Users retrieved successfully' })
+  async getAllUsers(
+    @Query('page') page?: number,
+    @Query('limit') limit?: number,
+    @Query('search') search?: string,
+    @Query('role') role?: UserRole,
+  ) {
+    return this.adminService.getAllUsers({
+      page: page ? Number(page) : 1,
+      limit: limit ? Number(limit) : 20,
+      search,
+      role,
+    });
+  }
+
+  @Get('users/:id')
+  @ApiOperation({ summary: 'Get user by ID with full details (Admin only)' })
+  @ApiResponse({ status: 200, description: 'User retrieved successfully' })
+  @ApiResponse({ status: 404, description: 'User not found' })
+  async getUserById(@Param('id') id: string) {
+    return this.adminService.getUserById(id);
+  }
+
+  @Post('users')
+  @HttpCode(HttpStatus.CREATED)
+  @ApiOperation({ summary: 'Create new user (Admin only)' })
+  @ApiResponse({ status: 201, description: 'User created successfully' })
+  @ApiResponse({ status: 409, description: 'Email already exists' })
+  async createUser(@Body() createUserDto: CreateUserDto) {
+    return this.adminService.createUser(createUserDto);
+  }
+
+  @Patch('users/:id')
+  @ApiOperation({ summary: 'Update user (Admin only)' })
+  @ApiResponse({ status: 200, description: 'User updated successfully' })
+  @ApiResponse({ status: 404, description: 'User not found' })
+  async updateUser(
+    @Param('id') id: string,
+    @Body() updateUserDto: UpdateUserDto,
+  ) {
+    return this.adminService.updateUser(id, updateUserDto);
+  }
+
+  @Delete('users/:id')
+  @ApiOperation({ summary: 'Delete user (Admin only)' })
+  @ApiResponse({ status: 200, description: 'User deleted successfully' })
+  @ApiResponse({ status: 404, description: 'User not found' })
+  async deleteUser(@Param('id') id: string) {
+    return this.adminService.deleteUser(id);
+  }
+
+  @Post('users/:id/reset-password')
+  @ApiOperation({ summary: 'Reset user password (Admin only)' })
+  @ApiResponse({ status: 200, description: 'Password reset successfully' })
+  @ApiResponse({ status: 404, description: 'User not found' })
+  async resetUserPassword(
+    @Param('id') id: string,
+    @Body() dto: AdminResetPasswordDto,
+  ) {
+    return this.adminService.resetUserPassword(id, dto);
+  }
+
+  @Get('stats')
+  @ApiOperation({ summary: 'Get platform statistics (Admin only)' })
+  @ApiResponse({ status: 200, description: 'Statistics retrieved' })
+  async getStats() {
+    return this.adminService.getStats();
+  }
+}
diff --git a/src/admin/controllers/index.ts b/src/admin/controllers/index.ts
new file mode 100644
index 0000000..5e35bfa
--- /dev/null
+++ b/src/admin/controllers/index.ts
@@ -0,0 +1,7 @@
+/**
+ * Admin Controllers Barrel Export
+ */
+
+export { AdminUsersController } from './admin-users.controller';
+export { AdminResumesController } from './admin-resumes.controller';
+export { AdminSkillsController } from './admin-skills.controller';
diff --git a/src/admin/services/admin-stats.service.spec.ts b/src/admin/services/admin-stats.service.spec.ts
new file mode 100644
index 0000000..874c4ba
--- /dev/null
+++ b/src/admin/services/admin-stats.service.spec.ts
@@ -0,0 +1,76 @@
+/**
+ * Admin Stats Service Tests
+ */
+
+import { Test, TestingModule } from '@nestjs/testing';
+import { AdminStatsService } from './admin-stats.service';
+import { PrismaService } from '../../prisma/prisma.service';
+
+describe('AdminStatsService', () => {
+  let service: AdminStatsService;
+  let prisma: jest.Mocked<PrismaService>;
+
+  beforeEach(async () => {
+    const mockPrismaService = {
+      user: {
+        count: jest.fn(),
+      },
+      resume: {
+        count: jest.fn(),
+      },
+    };
+
+    const module: TestingModule = await Test.createTestingModule({
+      providers: [
+        AdminStatsService,
+        { provide: PrismaService, useValue: mockPrismaService },
+      ],
+    }).compile();
+
+    service = module.get<AdminStatsService>(AdminStatsService);
+    prisma = module.get(PrismaService);
+  });
+
+  describe('getStats', () => {
+    it('should return correct statistics', async () => {
+      (prisma.user.count as jest.Mock)
+        .mockResolvedValueOnce(100) // totalUsers
+        .mockResolvedValueOnce(5) // totalAdmins
+        .mockResolvedValueOnce(80) // usersWithOnboarding
+        .mockResolvedValueOnce(15); // recentUsers
+
+      (prisma.resume.count as jest.Mock).mockResolvedValue(200);
+
+      const result = await service.getStats();
+
+      expect(result).toEqual({
+        users: {
+          total: 100,
+          admins: 5,
+          regular: 95,
+          withOnboarding: 80,
+          recentSignups: 15,
+        },
+        resumes: {
+          total: 200,
+        },
+      });
+    });
+
+    it('should filter admins correctly', async () => {
+      (prisma.user.count as jest.Mock).mockImplementation(
+        (args: { where?: { role?: string } }) => {
+          if (args?.where?.role === 'ADMIN') return Promise.resolve(3);
+          return Promise.resolve(50);
+        },
+      );
+      (prisma.resume.count as jest.Mock).mockResolvedValue(100);
+
+      await service.getStats();
+
+      expect(prisma.user.count).toHaveBeenCalledWith({
+        where: { role: 'ADMIN' },
+      });
+    });
+  });
+});
diff --git a/src/admin/services/admin-stats.service.ts b/src/admin/services/admin-stats.service.ts
new file mode 100644
index 0000000..f41ecd8
--- /dev/null
+++ b/src/admin/services/admin-stats.service.ts
@@ -0,0 +1,55 @@
+/**
+ * Admin Stats Service
+ * Single Responsibility: Dashboard statistics for admin panel
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { UserRole } from '../../common/enums/user-role.enum';
+import { TIME_MS } from '../../common/constants/app.constants';
+
+const DAYS_FOR_RECENT = 7;
+
+@Injectable()
+export class AdminStatsService {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async getStats() {
+    const [
+      totalUsers,
+      totalAdmins,
+      totalResumes,
+      usersWithOnboarding,
+      recentUsers,
+    ] = await Promise.all([
+      this.prisma.user.count(),
+      this.prisma.user.count({ where: { role: UserRole.ADMIN } }),
+      this.prisma.resume.count(),
+      this.prisma.user.count({ where: { hasCompletedOnboarding: true } }),
+      this.getRecentUsersCount(),
+    ]);
+
+    return {
+      users: {
+        total: totalUsers,
+        admins: totalAdmins,
+        regular: totalUsers - totalAdmins,
+        withOnboarding: usersWithOnboarding,
+        recentSignups: recentUsers,
+      },
+      resumes: {
+        total: totalResumes,
+      },
+    };
+  }
+
+  private async getRecentUsersCount(): Promise<number> {
+    const recentDate = new Date(Date.now() - DAYS_FOR_RECENT * TIME_MS.DAY);
+
+    return this.prisma.user.count({
+      where: {
+        createdAt: { gte: recentDate },
+      },
+    });
+  }
+}
diff --git a/src/admin/services/index.ts b/src/admin/services/index.ts
new file mode 100644
index 0000000..104348f
--- /dev/null
+++ b/src/admin/services/index.ts
@@ -0,0 +1,15 @@
+/**
+ * Admin Services Index
+ * Barrel export for all admin services
+ */
+
+export { UserAdminService, GetAllUsersOptions } from './user-admin.service';
+export { UserAdminQueryService } from './user-admin-query.service';
+export { UserAdminMutationService } from './user-admin-mutation.service';
+export { AdminStatsService } from './admin-stats.service';
+export { ResumeAdminService } from './resume-admin.service';
+export {
+  SkillAdminService,
+  CreateSkillData,
+  UpdateSkillData,
+} from './skill-admin.service';
diff --git a/src/admin/services/resume-admin.service.ts b/src/admin/services/resume-admin.service.ts
new file mode 100644
index 0000000..f618f60
--- /dev/null
+++ b/src/admin/services/resume-admin.service.ts
@@ -0,0 +1,93 @@
+/**
+ * Resume Admin Service
+ * Single Responsibility: Admin operations on resumes
+ */
+
+import { Injectable, NotFoundException } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
+
+@Injectable()
+export class ResumeAdminService {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async getUserResumes(userId: string) {
+    await this.ensureUserExists(userId);
+
+    const resumes = await this.prisma.resume.findMany({
+      where: { userId },
+      include: {
+        skills: true,
+        experiences: true,
+        education: true,
+        _count: {
+          select: {
+            skills: true,
+            experiences: true,
+            education: true,
+            projects: true,
+            certifications: true,
+          },
+        },
+      },
+      orderBy: { updatedAt: 'desc' },
+    });
+
+    return { resumes };
+  }
+
+  async getById(resumeId: string) {
+    const resume = await this.prisma.resume.findUnique({
+      where: { id: resumeId },
+      include: {
+        user: {
+          select: {
+            id: true,
+            email: true,
+            name: true,
+          },
+        },
+        skills: { orderBy: { order: 'asc' } },
+        experiences: { orderBy: { order: 'asc' } },
+        education: { orderBy: { order: 'asc' } },
+        projects: { orderBy: { order: 'asc' } },
+        certifications: { orderBy: { order: 'asc' } },
+        languages: { orderBy: { order: 'asc' } },
+        awards: { orderBy: { order: 'asc' } },
+      },
+    });
+
+    if (!resume) {
+      throw new NotFoundException('Resume not found');
+    }
+
+    return resume;
+  }
+
+  async delete(resumeId: string) {
+    await this.ensureResumeExists(resumeId);
+
+    await this.prisma.resume.delete({ where: { id: resumeId } });
+
+    return {
+      success: true,
+      message: 'Resume deleted successfully',
+    };
+  }
+
+  private async ensureUserExists(userId: string): Promise<void> {
+    const user = await this.prisma.user.findUnique({ where: { id: userId } });
+    if (!user) {
+      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
+    }
+  }
+
+  private async ensureResumeExists(resumeId: string): Promise<void> {
+    const resume = await this.prisma.resume.findUnique({
+      where: { id: resumeId },
+    });
+    if (!resume) {
+      throw new NotFoundException(ERROR_MESSAGES.RESUME_NOT_FOUND);
+    }
+  }
+}
diff --git a/src/admin/services/skill-admin.service.ts b/src/admin/services/skill-admin.service.ts
new file mode 100644
index 0000000..c54038e
--- /dev/null
+++ b/src/admin/services/skill-admin.service.ts
@@ -0,0 +1,111 @@
+/**
+ * Skill Admin Service
+ * Single Responsibility: Admin operations on skills
+ */
+
+import { Injectable, NotFoundException } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
+
+export interface CreateSkillData {
+  name: string;
+  category: string;
+  level?: number;
+}
+
+export interface UpdateSkillData {
+  name?: string;
+  category?: string;
+  level?: number;
+}
+
+@Injectable()
+export class SkillAdminService {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async getByResume(resumeId: string) {
+    await this.ensureResumeExists(resumeId);
+
+    const skills = await this.prisma.skill.findMany({
+      where: { resumeId },
+      orderBy: [{ category: 'asc' }, { order: 'asc' }],
+    });
+
+    return { skills };
+  }
+
+  async addToResume(resumeId: string, data: CreateSkillData) {
+    await this.ensureResumeExists(resumeId);
+
+    const order = await this.getNextOrder(resumeId);
+
+    const skill = await this.prisma.skill.create({
+      data: {
+        resumeId,
+        name: data.name,
+        category: data.category,
+        level: data.level,
+        order,
+      },
+    });
+
+    return {
+      success: true,
+      skill,
+      message: 'Skill added successfully',
+    };
+  }
+
+  async update(skillId: string, data: UpdateSkillData) {
+    await this.ensureSkillExists(skillId);
+
+    const updatedSkill = await this.prisma.skill.update({
+      where: { id: skillId },
+      data,
+    });
+
+    return {
+      success: true,
+      skill: updatedSkill,
+      message: 'Skill updated successfully',
+    };
+  }
+
+  async delete(skillId: string) {
+    await this.ensureSkillExists(skillId);
+
+    await this.prisma.skill.delete({ where: { id: skillId } });
+
+    return {
+      success: true,
+      message: 'Skill deleted successfully',
+    };
+  }
+
+  private async getNextOrder(resumeId: string): Promise<number> {
+    const lastSkill = await this.prisma.skill.findFirst({
+      where: { resumeId },
+      orderBy: { order: 'desc' },
+    });
+
+    return (lastSkill?.order ?? -1) + 1;
+  }
+
+  private async ensureResumeExists(resumeId: string): Promise<void> {
+    const resume = await this.prisma.resume.findUnique({
+      where: { id: resumeId },
+    });
+    if (!resume) {
+      throw new NotFoundException(ERROR_MESSAGES.RESUME_NOT_FOUND);
+    }
+  }
+
+  private async ensureSkillExists(skillId: string): Promise<void> {
+    const skill = await this.prisma.skill.findUnique({
+      where: { id: skillId },
+    });
+    if (!skill) {
+      throw new NotFoundException(ERROR_MESSAGES.SKILL_NOT_FOUND);
+    }
+  }
+}
diff --git a/src/admin/services/user-admin-mutation.service.ts b/src/admin/services/user-admin-mutation.service.ts
new file mode 100644
index 0000000..3e8af60
--- /dev/null
+++ b/src/admin/services/user-admin-mutation.service.ts
@@ -0,0 +1,148 @@
+/**
+ * User Admin Mutation Service
+ * Single Responsibility: Create, Update, Delete operations for admin user management
+ */
+
+import {
+  Injectable,
+  NotFoundException,
+  ConflictException,
+  BadRequestException,
+} from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { CreateUserDto } from '../dto/create-user.dto';
+import { UpdateUserDto } from '../dto/update-user.dto';
+import { AdminResetPasswordDto } from '../dto/reset-password.dto';
+import { UserRole } from '../../common/enums/user-role.enum';
+import { PasswordService } from '../../auth/services/password.service';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
+
+@Injectable()
+export class UserAdminMutationService {
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly passwordService: PasswordService,
+  ) {}
+
+  async create(dto: CreateUserDto) {
+    const { email, password, name, role } = dto;
+
+    await this.ensureEmailNotExists(email);
+
+    const hashedPassword = await this.passwordService.hash(password);
+
+    const user = await this.prisma.user.create({
+      data: {
+        email,
+        password: hashedPassword,
+        name,
+        role: role ?? UserRole.USER,
+      },
+      select: {
+        id: true,
+        email: true,
+        name: true,
+        role: true,
+        createdAt: true,
+      },
+    });
+
+    return { success: true, user, message: 'User created successfully' };
+  }
+
+  async update(id: string, dto: UpdateUserDto) {
+    const user = await this.findUserOrThrow(id);
+    await this.ensureUniqueFields(dto, user);
+
+    const updatedUser = await this.prisma.user.update({
+      where: { id },
+      data: dto,
+      select: {
+        id: true,
+        email: true,
+        name: true,
+        username: true,
+        role: true,
+        hasCompletedOnboarding: true,
+        updatedAt: true,
+      },
+    });
+
+    return {
+      success: true,
+      user: updatedUser,
+      message: 'User updated successfully',
+    };
+  }
+
+  async delete(id: string) {
+    const user = await this.findUserOrThrow(id);
+    await this.preventLastAdminDeletion(user.role as UserRole);
+
+    await this.prisma.user.delete({ where: { id } });
+
+    return { success: true, message: 'User deleted successfully' };
+  }
+
+  async resetPassword(id: string, dto: AdminResetPasswordDto) {
+    await this.findUserOrThrow(id);
+
+    const hashedPassword = await this.passwordService.hash(dto.newPassword);
+
+    await this.prisma.user.update({
+      where: { id },
+      data: { password: hashedPassword },
+    });
+
+    return { success: true, message: 'Password reset successfully' };
+  }
+
+  private async findUserOrThrow(id: string) {
+    const user = await this.prisma.user.findUnique({ where: { id } });
+    if (!user) {
+      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
+    }
+    return user;
+  }
+
+  private async ensureEmailNotExists(email: string): Promise<void> {
+    const existingUser = await this.prisma.user.findUnique({
+      where: { email },
+    });
+    if (existingUser) {
+      throw new ConflictException(ERROR_MESSAGES.EMAIL_ALREADY_EXISTS);
+    }
+  }
+
+  private async ensureUniqueFields(
+    dto: UpdateUserDto,
+    currentUser: { email: string | null; username: string | null },
+  ): Promise<void> {
+    if (dto.email && dto.email !== currentUser.email) {
+      const existing = await this.prisma.user.findUnique({
+        where: { email: dto.email },
+      });
+      if (existing)
+        throw new ConflictException(ERROR_MESSAGES.EMAIL_ALREADY_IN_USE);
+    }
+
+    if (dto.username && dto.username !== currentUser.username) {
+      const existing = await this.prisma.user.findUnique({
+        where: { username: dto.username },
+      });
+      if (existing)
+        throw new ConflictException(ERROR_MESSAGES.USERNAME_ALREADY_IN_USE);
+    }
+  }
+
+  private async preventLastAdminDeletion(role: UserRole): Promise<void> {
+    if (role !== UserRole.ADMIN) return;
+
+    const adminCount = await this.prisma.user.count({
+      where: { role: UserRole.ADMIN },
+    });
+    if (adminCount <= 1) {
+      throw new BadRequestException(ERROR_MESSAGES.CANNOT_DELETE_LAST_ADMIN);
+    }
+  }
+}
diff --git a/src/admin/services/user-admin-query.service.ts b/src/admin/services/user-admin-query.service.ts
new file mode 100644
index 0000000..79a5f73
--- /dev/null
+++ b/src/admin/services/user-admin-query.service.ts
@@ -0,0 +1,113 @@
+/**
+ * User Admin Query Service
+ * Single Responsibility: Read operations for admin user management
+ */
+
+import { Injectable, NotFoundException } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { Prisma } from '@prisma/client';
+import { UserRole } from '../../common/enums/user-role.enum';
+
+export interface GetAllUsersOptions {
+  page: number;
+  limit: number;
+  search?: string;
+  role?: UserRole;
+}
+
+const USER_LIST_SELECT = {
+  id: true,
+  email: true,
+  name: true,
+  username: true,
+  role: true,
+  hasCompletedOnboarding: true,
+  createdAt: true,
+  updatedAt: true,
+  image: true,
+  emailVerified: true,
+  _count: {
+    select: {
+      resumes: true,
+    },
+  },
+} as const;
+
+@Injectable()
+export class UserAdminQueryService {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async getAll(options: GetAllUsersOptions) {
+    const { page, limit, search, role } = options;
+    const skip = (page - 1) * limit;
+
+    const where = this.buildWhereClause(search, role);
+
+    const [users, total] = await Promise.all([
+      this.prisma.user.findMany({
+        where,
+        skip,
+        take: limit,
+        select: USER_LIST_SELECT,
+        orderBy: { createdAt: 'desc' },
+      }),
+      this.prisma.user.count({ where }),
+    ]);
+
+    return {
+      users,
+      pagination: { page, limit, total, totalPages: Math.ceil(total / limit) },
+    };
+  }
+
+  async getById(id: string) {
+    const user = await this.prisma.user.findUnique({
+      where: { id },
+      include: {
+        resumes: {
+          select: {
+            id: true,
+            title: true,
+            template: true,
+            isPublic: true,
+            createdAt: true,
+            updatedAt: true,
+          },
+        },
+        preferences: true,
+        _count: {
+          select: { accounts: true, sessions: true, resumes: true },
+        },
+      },
+    });
+
+    if (!user) {
+      throw new NotFoundException('User not found');
+    }
+
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars
+    const { password, ...userWithoutPassword } = user;
+    return userWithoutPassword;
+  }
+
+  private buildWhereClause(
+    search?: string,
+    role?: UserRole,
+  ): Prisma.UserWhereInput {
+    const where: Prisma.UserWhereInput = {};
+
+    if (search) {
+      where.OR = [
+        { email: { contains: search, mode: 'insensitive' } },
+        { name: { contains: search, mode: 'insensitive' } },
+        { username: { contains: search, mode: 'insensitive' } },
+      ];
+    }
+
+    if (role) {
+      where.role = role;
+    }
+
+    return where;
+  }
+}
diff --git a/src/admin/services/user-admin.service.ts b/src/admin/services/user-admin.service.ts
new file mode 100644
index 0000000..8e1ab86
--- /dev/null
+++ b/src/admin/services/user-admin.service.ts
@@ -0,0 +1,54 @@
+/**
+ * User Admin Service (Facade)
+ * Provides unified API for admin user management
+ * Delegates to specialized services for implementation
+ */
+
+import { Injectable } from '@nestjs/common';
+import {
+  UserAdminQueryService,
+  GetAllUsersOptions,
+} from './user-admin-query.service';
+import { UserAdminMutationService } from './user-admin-mutation.service';
+import { CreateUserDto } from '../dto/create-user.dto';
+import { UpdateUserDto } from '../dto/update-user.dto';
+import { AdminResetPasswordDto } from '../dto/reset-password.dto';
+
+// Re-export for backward compatibility
+export { GetAllUsersOptions };
+
+@Injectable()
+export class UserAdminService {
+  constructor(
+    private readonly queryService: UserAdminQueryService,
+    private readonly mutationService: UserAdminMutationService,
+  ) {}
+
+  // ==================== Query Operations ====================
+
+  async getAll(options: GetAllUsersOptions) {
+    return this.queryService.getAll(options);
+  }
+
+  async getById(id: string) {
+    return this.queryService.getById(id);
+  }
+
+  // ==================== Mutation Operations ====================
+
+  async create(dto: CreateUserDto) {
+    return this.mutationService.create(dto);
+  }
+
+  async update(id: string, dto: UpdateUserDto) {
+    return this.mutationService.update(id, dto);
+  }
+
+  async delete(id: string) {
+    return this.mutationService.delete(id);
+  }
+
+  async resetPassword(id: string, dto: AdminResetPasswordDto) {
+    return this.mutationService.resetPassword(id, dto);
+  }
+}
diff --git a/src/auth/auth.controller.ts b/src/auth/auth.controller.ts
deleted file mode 100644
index e0dfa3d..0000000
--- a/src/auth/auth.controller.ts
+++ /dev/null
@@ -1,219 +0,0 @@
-import {
-  Controller,
-  Post,
-  Body,
-  UseGuards,
-  HttpCode,
-  HttpStatus,
-} from '@nestjs/common';
-import {
-  ApiTags,
-  ApiOperation,
-  ApiResponse,
-  ApiBearerAuth,
-} from '@nestjs/swagger';
-import { Throttle, SkipThrottle } from '@nestjs/throttler';
-import { AuthService } from './auth.service';
-import { SignupDto } from './dto/signup.dto';
-import { LoginDto } from './dto/login.dto';
-import { ChangeEmailDto } from './dto/change-email.dto';
-import { DeleteAccountDto } from './dto/delete-account.dto';
-import {
-  RequestVerificationDto,
-  VerifyEmailDto,
-  ForgotPasswordDto,
-  ResetPasswordDto,
-  ChangePasswordDto,
-} from './dto/verification.dto';
-import { Public } from './decorators/public.decorator';
-import { JwtAuthGuard } from './guards/jwt-auth.guard';
-import { CurrentUser } from '../common/decorators/current-user.decorator';
-import { UserPayload } from './interfaces/auth-request.interface';
-import { APP_CONSTANTS } from '../common/constants/app.constants';
-
-@ApiTags('auth')
-@Controller('auth')
-export class AuthController {
-  constructor(private readonly authService: AuthService) {}
-
-  @Public()
-  @Post('signup')
-  @Throttle({
-    default: { ttl: 60000, limit: APP_CONSTANTS.AUTH_RATE_LIMIT_MAX_REQUESTS },
-  })
-  @HttpCode(HttpStatus.CREATED)
-  @ApiOperation({ summary: 'Register a new user' })
-  @ApiResponse({
-    status: 201,
-    description: 'User successfully registered',
-    schema: {
-      example: {
-        success: true,
-        user: {
-          id: 'cuid123',
-          email: 'user@example.com',
-          name: 'John Doe',
-          hasCompletedOnboarding: false,
-        },
-        token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
-      },
-    },
-  })
-  @ApiResponse({ status: 409, description: 'Email already registered' })
-  @ApiResponse({ status: 400, description: 'Invalid input data' })
-  @ApiResponse({ status: 429, description: 'Too many requests' })
-  async signup(@Body() signupDto: SignupDto) {
-    return this.authService.signup(signupDto);
-  }
-
-  @Public()
-  @Post('login')
-  @Throttle({
-    default: { ttl: 60000, limit: APP_CONSTANTS.AUTH_RATE_LIMIT_MAX_REQUESTS },
-  })
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({ summary: 'Login with email and password' })
-  @ApiResponse({
-    status: 200,
-    description: 'Login successful',
-    schema: {
-      example: {
-        success: true,
-        user: {
-          id: 'cuid123',
-          email: 'user@example.com',
-          name: 'John Doe',
-          hasCompletedOnboarding: true,
-        },
-        token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
-      },
-    },
-  })
-  @ApiResponse({ status: 401, description: 'Invalid credentials' })
-  @ApiResponse({ status: 400, description: 'Invalid input data' })
-  @ApiResponse({ status: 429, description: 'Too many requests' })
-  async login(@Body() loginDto: LoginDto) {
-    return this.authService.login(loginDto);
-  }
-
-  @UseGuards(JwtAuthGuard)
-  @SkipThrottle()
-  @Post('refresh')
-  @HttpCode(HttpStatus.OK)
-  @ApiBearerAuth('JWT-auth')
-  @ApiOperation({ summary: 'Refresh JWT token' })
-  @ApiResponse({
-    status: 200,
-    description: 'Token refreshed successfully',
-    schema: {
-      example: {
-        success: true,
-        token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
-        user: {
-          id: 'cuid123',
-          email: 'user@example.com',
-          name: 'John Doe',
-          hasCompletedOnboarding: true,
-        },
-      },
-    },
-  })
-  @ApiResponse({ status: 401, description: 'Unauthorized' })
-  async refreshToken(@CurrentUser() user: UserPayload) {
-    return this.authService.refreshToken(user.userId);
-  }
-
-  // ==================== Email Verification ====================
-
-  @Public()
-  @Post('verify-email/request')
-  @Throttle({ default: { ttl: 60000, limit: 3 } })
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({ summary: 'Request email verification' })
-  @ApiResponse({ status: 200, description: 'Verification email sent' })
-  @ApiResponse({ status: 429, description: 'Too many requests' })
-  async requestEmailVerification(@Body() dto: RequestVerificationDto) {
-    return this.authService.requestEmailVerification(dto);
-  }
-
-  @Public()
-  @Post('verify-email')
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({ summary: 'Verify email with token' })
-  @ApiResponse({ status: 200, description: 'Email verified successfully' })
-  @ApiResponse({ status: 400, description: 'Invalid or expired token' })
-  async verifyEmail(@Body() dto: VerifyEmailDto) {
-    return this.authService.verifyEmail(dto);
-  }
-
-  // ==================== Password Reset ====================
-
-  @Public()
-  @Post('forgot-password')
-  @Throttle({ default: { ttl: 60000, limit: 3 } })
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({ summary: 'Request password reset' })
-  @ApiResponse({ status: 200, description: 'Password reset email sent' })
-  @ApiResponse({ status: 429, description: 'Too many requests' })
-  async forgotPassword(@Body() dto: ForgotPasswordDto) {
-    return this.authService.forgotPassword(dto);
-  }
-
-  @Public()
-  @Post('reset-password')
-  @Throttle({
-    default: { ttl: 60000, limit: APP_CONSTANTS.AUTH_RATE_LIMIT_MAX_REQUESTS },
-  })
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({ summary: 'Reset password with token' })
-  @ApiResponse({ status: 200, description: 'Password reset successfully' })
-  @ApiResponse({ status: 400, description: 'Invalid or expired token' })
-  @ApiResponse({ status: 429, description: 'Too many requests' })
-  async resetPassword(@Body() dto: ResetPasswordDto) {
-    return this.authService.resetPassword(dto);
-  }
-
-  @UseGuards(JwtAuthGuard)
-  @Post('change-password')
-  @HttpCode(HttpStatus.OK)
-  @ApiBearerAuth('JWT-auth')
-  @ApiOperation({ summary: 'Change password (authenticated)' })
-  @ApiResponse({ status: 200, description: 'Password changed successfully' })
-  @ApiResponse({ status: 401, description: 'Current password is incorrect' })
-  async changePassword(
-    @CurrentUser() user: UserPayload,
-    @Body() dto: ChangePasswordDto,
-  ) {
-    return this.authService.changePassword(user.userId, dto);
-  }
-
-  @UseGuards(JwtAuthGuard)
-  @Post('change-email')
-  @HttpCode(HttpStatus.OK)
-  @ApiBearerAuth('JWT-auth')
-  @ApiOperation({ summary: 'Change email address (authenticated)' })
-  @ApiResponse({ status: 200, description: 'Email changed successfully' })
-  @ApiResponse({ status: 400, description: 'Invalid email or password' })
-  @ApiResponse({ status: 401, description: 'Unauthorized' })
-  @ApiResponse({ status: 409, description: 'Email already in use' })
-  async changeEmail(
-    @CurrentUser() user: UserPayload,
-    @Body() dto: ChangeEmailDto,
-  ) {
-    return this.authService.changeEmail(user.userId, dto);
-  }
-
-  @UseGuards(JwtAuthGuard)
-  @Post('delete-account')
-  @HttpCode(HttpStatus.OK)
-  @ApiBearerAuth('JWT-auth')
-  @ApiOperation({ summary: 'Delete own account (authenticated)' })
-  @ApiResponse({ status: 200, description: 'Account deleted successfully' })
-  @ApiResponse({ status: 401, description: 'Password is incorrect' })
-  async deleteAccount(
-    @CurrentUser() user: UserPayload,
-    @Body() dto: DeleteAccountDto,
-  ) {
-    return this.authService.deleteAccount(user.userId, dto);
-  }
-}
diff --git a/src/auth/auth.module.ts b/src/auth/auth.module.ts
index 340cf8a..768b968 100644
--- a/src/auth/auth.module.ts
+++ b/src/auth/auth.module.ts
@@ -3,12 +3,27 @@ import { JwtModule } from '@nestjs/jwt';
 import { PassportModule } from '@nestjs/passport';
 import { ConfigModule, ConfigService } from '@nestjs/config';
 import { AuthService } from './auth.service';
-import { AuthController } from './auth.controller';
+import {
+  AuthCoreController,
+  AuthVerificationController,
+  AuthPasswordController,
+  AuthAccountController,
+} from './controllers';
 import { JwtStrategy } from './strategies/jwt.strategy';
 import { LocalStrategy } from './strategies/local.strategy';
 import { PrismaModule } from '../prisma/prisma.module';
 import { EmailModule } from '../common/email/email.module';
 import { LoggerModule } from '../common/logger/logger.module';
+import {
+  TokenService,
+  PasswordService,
+  VerificationTokenService,
+  EmailVerificationService,
+  PasswordResetService,
+  AccountManagementService,
+  AuthCoreService,
+  TokenRefreshService,
+} from './services';
 
 @Module({
   imports: [
@@ -27,15 +42,36 @@ import { LoggerModule } from '../common/logger/logger.module';
         return {
           secret,
           signOptions: {
-            expiresIn: configService.get('JWT_EXPIRES_IN') || '7d',
+            expiresIn: configService.get('JWT_EXPIRES_IN') ?? '7d',
           },
         };
       },
       inject: [ConfigService],
     }),
   ],
-  controllers: [AuthController],
-  providers: [AuthService, JwtStrategy, LocalStrategy],
-  exports: [AuthService, JwtModule],
+  controllers: [
+    AuthCoreController,
+    AuthVerificationController,
+    AuthPasswordController,
+    AuthAccountController,
+  ],
+  providers: [
+    // Core services
+    TokenService,
+    PasswordService,
+    VerificationTokenService,
+    // Feature services
+    AuthCoreService,
+    TokenRefreshService,
+    EmailVerificationService,
+    PasswordResetService,
+    AccountManagementService,
+    // Facade
+    AuthService,
+    // Strategies
+    JwtStrategy,
+    LocalStrategy,
+  ],
+  exports: [AuthService, JwtModule, TokenService, PasswordService],
 })
 export class AuthModule {}
diff --git a/src/auth/auth.service.spec.ts b/src/auth/auth.service.spec.ts
index 888af58..ce2678e 100644
--- a/src/auth/auth.service.spec.ts
+++ b/src/auth/auth.service.spec.ts
@@ -1,529 +1,233 @@
 import { Test, TestingModule } from '@nestjs/testing';
-import {
-  ConflictException,
-  UnauthorizedException,
-  BadRequestException,
-} from '@nestjs/common';
-import { JwtService } from '@nestjs/jwt';
-import * as bcrypt from 'bcryptjs';
 import { AuthService } from './auth.service';
-import { PrismaService } from '../prisma/prisma.service';
-import { AppLoggerService } from '../common/logger/logger.service';
-import { EmailService } from '../common/email/email.service';
+import {
+  AuthCoreService,
+  TokenRefreshService,
+  EmailVerificationService,
+  PasswordResetService,
+  AccountManagementService,
+} from './services';
 
 describe('AuthService', () => {
   let service: AuthService;
-  let prisma: PrismaService;
-  let jwtService: JwtService;
-  let logger: AppLoggerService;
-  let emailService: EmailService;
-
-  const mockPrismaService = {
-    user: {
-      findUnique: jest.fn(),
-      create: jest.fn(),
-      update: jest.fn(),
-    },
-    verificationToken: {
-      upsert: jest.fn(),
-      findUnique: jest.fn(),
-      delete: jest.fn(),
-    },
+  let authCoreService: jest.Mocked<AuthCoreService>;
+  let tokenRefreshService: jest.Mocked<TokenRefreshService>;
+  let emailVerificationService: jest.Mocked<EmailVerificationService>;
+  let passwordResetService: jest.Mocked<PasswordResetService>;
+  let accountManagementService: jest.Mocked<AccountManagementService>;
+
+  const mockAuthCoreService = {
+    signup: jest.fn(),
+    validateUser: jest.fn(),
+    login: jest.fn(),
+  };
+
+  const mockTokenRefreshService = {
+    refreshToken: jest.fn(),
   };
 
-  const mockJwtService = {
-    sign: jest.fn(),
+  const mockEmailVerificationService = {
+    requestVerification: jest.fn(),
+    verifyEmail: jest.fn(),
   };
 
-  const mockLoggerService = {
-    log: jest.fn(),
-    warn: jest.fn(),
-    error: jest.fn(),
-    debug: jest.fn(),
+  const mockPasswordResetService = {
+    forgotPassword: jest.fn(),
+    resetPassword: jest.fn(),
+    changePassword: jest.fn(),
   };
 
-  const mockEmailService = {
-    sendVerificationEmail: jest.fn(),
-    sendPasswordResetEmail: jest.fn(),
-    sendWelcomeEmail: jest.fn(),
-    sendPasswordChangedEmail: jest.fn(),
+  const mockAccountManagementService = {
+    changeEmail: jest.fn(),
+    deleteAccount: jest.fn(),
   };
 
   beforeEach(async () => {
+    jest.clearAllMocks();
+
     const module: TestingModule = await Test.createTestingModule({
       providers: [
         AuthService,
         {
-          provide: PrismaService,
-          useValue: mockPrismaService,
+          provide: AuthCoreService,
+          useValue: mockAuthCoreService,
+        },
+        {
+          provide: TokenRefreshService,
+          useValue: mockTokenRefreshService,
         },
         {
-          provide: JwtService,
-          useValue: mockJwtService,
+          provide: EmailVerificationService,
+          useValue: mockEmailVerificationService,
         },
         {
-          provide: AppLoggerService,
-          useValue: mockLoggerService,
+          provide: PasswordResetService,
+          useValue: mockPasswordResetService,
         },
         {
-          provide: EmailService,
-          useValue: mockEmailService,
+          provide: AccountManagementService,
+          useValue: mockAccountManagementService,
         },
       ],
     }).compile();
 
     service = module.get<AuthService>(AuthService);
-    prisma = module.get<PrismaService>(PrismaService);
-    jwtService = module.get<JwtService>(JwtService);
-    logger = module.get<AppLoggerService>(AppLoggerService);
-    emailService = module.get<EmailService>(EmailService);
-  });
-
-  afterEach(() => {
-    jest.clearAllMocks();
+    authCoreService = module.get(AuthCoreService);
+    tokenRefreshService = module.get(TokenRefreshService);
+    emailVerificationService = module.get(EmailVerificationService);
+    passwordResetService = module.get(PasswordResetService);
+    accountManagementService = module.get(AccountManagementService);
   });
 
   describe('signup', () => {
-    it('should successfully register a new user', async () => {
-      const signupDto = {
-        email: 'test@example.com',
-        password: 'password123',
-        name: 'Test User',
-      };
-
-      const hashedPassword = 'hashedPassword123';
-      const mockUser = {
-        id: 'user-123',
-        email: signupDto.email,
-        name: signupDto.name,
-        password: hashedPassword,
-        hasCompletedOnboarding: false,
-      };
-
-      mockPrismaService.user.findUnique.mockResolvedValue(null);
-      mockPrismaService.user.create.mockResolvedValue(mockUser);
-      mockJwtService.sign.mockReturnValue('mock-jwt-token');
-
-      jest
-        .spyOn(bcrypt, 'hash')
-        .mockImplementation(() => Promise.resolve(hashedPassword as never));
-
-      const result = await service.signup(signupDto);
-
-      expect(result).toEqual({
+    const signupDto = {
+      email: 'test@example.com',
+      password: 'password123',
+      name: 'Test User',
+    };
+
+    it('should delegate to authCoreService', async () => {
+      const mockResult = {
         success: true,
-        user: {
-          id: mockUser.id,
-          email: mockUser.email,
-          name: mockUser.name,
-          hasCompletedOnboarding: false,
-        },
         token: 'mock-jwt-token',
-      });
-
-      expect(mockPrismaService.user.findUnique).toHaveBeenCalledWith({
-        where: { email: signupDto.email },
-      });
-      expect(mockPrismaService.user.create).toHaveBeenCalled();
-      expect(mockJwtService.sign).toHaveBeenCalled();
-    });
-
-    it('should throw ConflictException if email already exists', async () => {
-      const signupDto = {
-        email: 'existing@example.com',
-        password: 'password123',
-        name: 'Test User',
+        user: { id: 'user-123', email: signupDto.email },
       };
+      mockAuthCoreService.signup.mockResolvedValue(mockResult);
 
-      mockPrismaService.user.findUnique.mockResolvedValue({
-        id: 'existing-user',
-        email: signupDto.email,
-      });
+      const result = await service.signup(signupDto);
 
-      await expect(service.signup(signupDto)).rejects.toThrow(
-        ConflictException,
-      );
-      expect(mockPrismaService.user.create).not.toHaveBeenCalled();
+      expect(result).toEqual(mockResult);
+      expect(authCoreService.signup).toHaveBeenCalledWith(signupDto);
     });
   });
 
   describe('login', () => {
-    it('should successfully login with valid credentials', async () => {
-      const loginDto = {
-        email: 'test@example.com',
-        password: 'password123',
-      };
-
-      const hashedPassword = await bcrypt.hash(loginDto.password, 12);
-      const mockUser = {
-        id: 'user-123',
-        email: loginDto.email,
-        name: 'Test User',
-        password: hashedPassword,
-        hasCompletedOnboarding: true,
-      };
-
-      mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
-      mockJwtService.sign.mockReturnValue('mock-jwt-token');
-
-      jest
-        .spyOn(bcrypt, 'compare')
-        .mockImplementation(() => Promise.resolve(true as never));
-
-      const result = await service.login(loginDto);
+    const loginDto = { email: 'test@example.com', password: 'password123' };
 
-      expect(result).toEqual({
+    it('should delegate to authCoreService', async () => {
+      const mockResult = {
         success: true,
-        user: {
-          id: mockUser.id,
-          email: mockUser.email,
-          name: mockUser.name,
-          hasCompletedOnboarding: true,
-        },
         token: 'mock-jwt-token',
-      });
-
-      expect(mockPrismaService.user.findUnique).toHaveBeenCalledWith({
-        where: { email: loginDto.email },
-      });
-    });
-
-    it('should throw UnauthorizedException with invalid credentials', async () => {
-      const loginDto = {
-        email: 'test@example.com',
-        password: 'wrongpassword',
-      };
-
-      mockPrismaService.user.findUnique.mockResolvedValue(null);
-
-      await expect(service.login(loginDto)).rejects.toThrow(
-        UnauthorizedException,
-      );
-    });
-
-    it('should throw UnauthorizedException with invalid password', async () => {
-      const loginDto = {
-        email: 'test@example.com',
-        password: 'wrongpassword',
-      };
-
-      const mockUser = {
-        id: 'user-123',
-        email: loginDto.email,
-        password: 'hashedPassword',
+        user: { id: 'user-123', email: loginDto.email },
       };
+      mockAuthCoreService.login.mockResolvedValue(mockResult);
 
-      mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
-      jest
-        .spyOn(bcrypt, 'compare')
-        .mockImplementation(() => Promise.resolve(false as never));
+      const result = await service.login(loginDto);
 
-      await expect(service.login(loginDto)).rejects.toThrow(
-        UnauthorizedException,
-      );
+      expect(result).toEqual(mockResult);
+      expect(authCoreService.login).toHaveBeenCalledWith(loginDto);
     });
   });
 
   describe('refreshToken', () => {
-    it('should successfully refresh token for valid user', async () => {
-      const userId = 'user-123';
-      const mockUser = {
-        id: userId,
-        email: 'test@example.com',
-        name: 'Test User',
-        hasCompletedOnboarding: true,
-      };
-
-      mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
-      mockJwtService.sign.mockReturnValue('new-jwt-token');
-
-      const result = await service.refreshToken(userId);
-
-      expect(result).toEqual({
+    it('should delegate to tokenRefreshService', async () => {
+      const mockResult = {
         success: true,
-        token: 'new-jwt-token',
-        user: mockUser,
-      });
-
-      expect(mockPrismaService.user.findUnique).toHaveBeenCalledWith({
-        where: { id: userId },
-        select: {
-          id: true,
-          email: true,
-          name: true,
-          role: true,
-          hasCompletedOnboarding: true,
-        },
-      });
-    });
+        token: 'new-mock-jwt-token',
+      };
+      mockTokenRefreshService.refreshToken.mockResolvedValue(mockResult);
 
-    it('should throw UnauthorizedException if user not found', async () => {
-      mockPrismaService.user.findUnique.mockResolvedValue(null);
+      const result = await service.refreshToken('user-123');
 
-      await expect(service.refreshToken('invalid-id')).rejects.toThrow(
-        UnauthorizedException,
-      );
+      expect(result).toEqual(mockResult);
+      expect(tokenRefreshService.refreshToken).toHaveBeenCalledWith('user-123');
     });
   });
 
-  describe('requestEmailVerification', () => {
-    it('should create verification token and send email', async () => {
+  describe('email verification', () => {
+    it('should delegate requestEmailVerification to EmailVerificationService', async () => {
       const dto = { email: 'test@example.com' };
-      const mockUser = {
-        id: 'user-123',
-        email: dto.email,
-        name: 'Test User',
-        emailVerified: null,
-      };
-
-      mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
-      mockPrismaService.verificationToken.upsert.mockResolvedValue({
-        identifier: dto.email,
-        token: 'verification-token',
-        expires: new Date(),
+      mockEmailVerificationService.requestVerification.mockResolvedValue({
+        success: true,
       });
 
-      const result = await service.requestEmailVerification(dto);
+      await service.requestEmailVerification(dto);
 
-      expect(result.success).toBe(true);
-      expect(result.message).toBe('Verification email sent');
-      expect(mockPrismaService.verificationToken.upsert).toHaveBeenCalled();
-      expect(emailService.sendVerificationEmail).toHaveBeenCalledWith(
-        dto.email,
-        mockUser.name,
-        expect.any(String),
+      expect(emailVerificationService.requestVerification).toHaveBeenCalledWith(
+        dto,
       );
     });
 
-    it('should return success even if user not found (prevent email enumeration)', async () => {
-      const dto = { email: 'nonexistent@example.com' };
-      mockPrismaService.user.findUnique.mockResolvedValue(null);
-
-      const result = await service.requestEmailVerification(dto);
-
-      expect(result.success).toBe(true);
-      expect(mockPrismaService.verificationToken.upsert).not.toHaveBeenCalled();
-      expect(emailService.sendVerificationEmail).not.toHaveBeenCalled();
-    });
-
-    it('should not send email if already verified', async () => {
-      const dto = { email: 'verified@example.com' };
-      const mockUser = {
-        id: 'user-123',
-        email: dto.email,
-        emailVerified: new Date(),
-      };
-
-      mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
+    it('should delegate verifyEmail to EmailVerificationService', async () => {
+      const dto = { token: 'verification-token' };
+      mockEmailVerificationService.verifyEmail.mockResolvedValue({
+        success: true,
+      });
 
-      const result = await service.requestEmailVerification(dto);
+      await service.verifyEmail(dto);
 
-      expect(result.success).toBe(true);
-      expect(result.message).toBe('Email is already verified');
-      expect(emailService.sendVerificationEmail).not.toHaveBeenCalled();
+      expect(emailVerificationService.verifyEmail).toHaveBeenCalledWith(dto);
     });
   });
 
-  describe('verifyEmail', () => {
-    it('should verify email and send welcome email', async () => {
-      const dto = { token: 'valid-token' };
-      const mockToken = {
-        identifier: 'test@example.com',
-        token: dto.token,
-        expires: new Date(Date.now() + 24 * 60 * 60 * 1000),
-      };
-      const mockUser = {
-        id: 'user-123',
-        email: 'test@example.com',
-        name: 'Test User',
-      };
-
-      mockPrismaService.verificationToken.findUnique.mockResolvedValue(
-        mockToken,
-      );
-      mockPrismaService.user.update.mockResolvedValue(mockUser);
-      mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
-      mockPrismaService.verificationToken.delete.mockResolvedValue(mockToken);
-
-      const result = await service.verifyEmail(dto);
-
-      expect(result.success).toBe(true);
-      expect(result.message).toBe('Email verified successfully');
-      expect(mockPrismaService.user.update).toHaveBeenCalled();
-      expect(mockPrismaService.verificationToken.delete).toHaveBeenCalled();
-      expect(emailService.sendWelcomeEmail).toHaveBeenCalledWith(
-        mockUser.email,
-        mockUser.name,
-      );
-    });
-
-    it('should throw BadRequestException for invalid token', async () => {
-      const dto = { token: 'invalid-token' };
-      mockPrismaService.verificationToken.findUnique.mockResolvedValue(null);
-
-      await expect(service.verifyEmail(dto)).rejects.toThrow(
-        BadRequestException,
-      );
-    });
-
-    it('should throw BadRequestException for expired token', async () => {
-      const dto = { token: 'expired-token' };
-      const mockToken = {
-        identifier: 'test@example.com',
-        token: dto.token,
-        expires: new Date(Date.now() - 1000), // Expired
-      };
-
-      mockPrismaService.verificationToken.findUnique.mockResolvedValue(
-        mockToken,
-      );
-      mockPrismaService.verificationToken.delete.mockResolvedValue(mockToken);
-
-      await expect(service.verifyEmail(dto)).rejects.toThrow(
-        BadRequestException,
-      );
-      expect(mockPrismaService.verificationToken.delete).toHaveBeenCalled();
-    });
-  });
-
-  describe('forgotPassword', () => {
-    it('should create reset token and send email', async () => {
+  describe('password reset', () => {
+    it('should delegate forgotPassword to PasswordResetService', async () => {
       const dto = { email: 'test@example.com' };
-      const mockUser = {
-        id: 'user-123',
-        email: dto.email,
-        name: 'Test User',
-      };
-
-      mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
-      mockPrismaService.verificationToken.upsert.mockResolvedValue({
-        identifier: `reset:${dto.email}`,
-        token: 'reset-token',
-        expires: new Date(),
+      mockPasswordResetService.forgotPassword.mockResolvedValue({
+        success: true,
       });
 
-      const result = await service.forgotPassword(dto);
+      await service.forgotPassword(dto);
 
-      expect(result.success).toBe(true);
-      expect(result.message).toBe('Password reset email sent');
-      expect(mockPrismaService.verificationToken.upsert).toHaveBeenCalled();
-      expect(emailService.sendPasswordResetEmail).toHaveBeenCalledWith(
-        dto.email,
-        mockUser.name,
-        expect.any(String),
-      );
+      expect(passwordResetService.forgotPassword).toHaveBeenCalledWith(dto);
     });
 
-    it('should return success even if user not found', async () => {
-      const dto = { email: 'nonexistent@example.com' };
-      mockPrismaService.user.findUnique.mockResolvedValue(null);
+    it('should delegate resetPassword to PasswordResetService', async () => {
+      const dto = { token: 'reset-token', password: 'newpass123' };
+      mockPasswordResetService.resetPassword.mockResolvedValue({
+        success: true,
+      });
 
-      const result = await service.forgotPassword(dto);
+      await service.resetPassword(dto);
 
-      expect(result.success).toBe(true);
-      expect(mockPrismaService.verificationToken.upsert).not.toHaveBeenCalled();
-      expect(emailService.sendPasswordResetEmail).not.toHaveBeenCalled();
+      expect(passwordResetService.resetPassword).toHaveBeenCalledWith(dto);
     });
-  });
 
-  describe('resetPassword', () => {
-    it('should reset password successfully', async () => {
-      const dto = { token: 'reset-token', password: 'newpassword123' };
-      const mockToken = {
-        identifier: 'reset:test@example.com',
-        token: dto.token,
-        expires: new Date(Date.now() + 60 * 60 * 1000),
+    it('should delegate changePassword to PasswordResetService', async () => {
+      const dto = {
+        currentPassword: 'oldpass',
+        newPassword: 'newpass123',
       };
+      mockPasswordResetService.changePassword.mockResolvedValue({
+        success: true,
+      });
 
-      mockPrismaService.verificationToken.findUnique.mockResolvedValue(
-        mockToken,
-      );
-      mockPrismaService.user.update.mockResolvedValue({});
-      mockPrismaService.verificationToken.delete.mockResolvedValue(mockToken);
-
-      jest
-        .spyOn(bcrypt, 'hash')
-        .mockImplementation(() =>
-          Promise.resolve('hashed-new-password' as never),
-        );
-
-      const result = await service.resetPassword(dto);
-
-      expect(result.success).toBe(true);
-      expect(result.message).toBe('Password reset successfully');
-      expect(mockPrismaService.user.update).toHaveBeenCalled();
-      expect(mockPrismaService.verificationToken.delete).toHaveBeenCalled();
-    });
-
-    it('should throw BadRequestException for invalid token', async () => {
-      const dto = { token: 'invalid-token', password: 'newpassword123' };
-      mockPrismaService.verificationToken.findUnique.mockResolvedValue(null);
+      await service.changePassword('user-123', dto);
 
-      await expect(service.resetPassword(dto)).rejects.toThrow(
-        BadRequestException,
+      expect(passwordResetService.changePassword).toHaveBeenCalledWith(
+        'user-123',
+        dto,
       );
     });
   });
 
-  describe('changePassword', () => {
-    it('should change password and send notification email', async () => {
-      const userId = 'user-123';
-      const dto = {
-        currentPassword: 'oldpassword',
-        newPassword: 'newpassword123',
-      };
-      const mockUser = {
-        id: userId,
-        email: 'test@example.com',
-        name: 'Test User',
-        password: 'hashed-old-password',
-      };
+  describe('account management', () => {
+    it('should delegate changeEmail to AccountManagementService', async () => {
+      const dto = { newEmail: 'new@example.com', currentPassword: 'password' };
+      mockAccountManagementService.changeEmail.mockResolvedValue({
+        success: true,
+      });
+
+      await service.changeEmail('user-123', dto);
 
-      mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
-      mockPrismaService.user.update.mockResolvedValue(mockUser);
-
-      jest
-        .spyOn(bcrypt, 'compare')
-        .mockImplementation(() => Promise.resolve(true as never));
-      jest
-        .spyOn(bcrypt, 'hash')
-        .mockImplementation(() =>
-          Promise.resolve('hashed-new-password' as never),
-        );
-
-      const result = await service.changePassword(userId, dto);
-
-      expect(result.success).toBe(true);
-      expect(result.message).toBe('Password changed successfully');
-      expect(mockPrismaService.user.update).toHaveBeenCalled();
-      expect(emailService.sendPasswordChangedEmail).toHaveBeenCalledWith(
-        mockUser.email,
-        mockUser.name,
+      expect(accountManagementService.changeEmail).toHaveBeenCalledWith(
+        'user-123',
+        dto,
       );
     });
 
-    it('should throw UnauthorizedException if current password is incorrect', async () => {
-      const userId = 'user-123';
-      const dto = {
-        currentPassword: 'wrongpassword',
-        newPassword: 'newpassword123',
-      };
-      const mockUser = {
-        id: userId,
-        email: 'test@example.com',
-        password: 'hashed-password',
-      };
+    it('should delegate deleteAccount to AccountManagementService', async () => {
+      const dto = { password: 'password123' };
+      mockAccountManagementService.deleteAccount.mockResolvedValue({
+        success: true,
+      });
 
-      mockPrismaService.user.findUnique.mockResolvedValue(mockUser);
-      jest
-        .spyOn(bcrypt, 'compare')
-        .mockImplementation(() => Promise.resolve(false as never));
+      await service.deleteAccount('user-123', dto);
 
-      await expect(service.changePassword(userId, dto)).rejects.toThrow(
-        UnauthorizedException,
+      expect(accountManagementService.deleteAccount).toHaveBeenCalledWith(
+        'user-123',
+        dto,
       );
-      expect(mockPrismaService.user.update).not.toHaveBeenCalled();
-      expect(emailService.sendPasswordChangedEmail).not.toHaveBeenCalled();
     });
   });
 });
diff --git a/src/auth/auth.service.ts b/src/auth/auth.service.ts
index f4bc300..a7541ca 100644
--- a/src/auth/auth.service.ts
+++ b/src/auth/auth.service.ts
@@ -1,17 +1,11 @@
-import {
-  Injectable,
-  ConflictException,
-  UnauthorizedException,
-  BadRequestException,
-  NotFoundException,
-} from '@nestjs/common';
-import { JwtService } from '@nestjs/jwt';
-import * as bcrypt from 'bcryptjs';
-import * as crypto from 'crypto';
+/**
+ * Auth Service (Facade)
+ * Provides unified API for authentication operations
+ * Delegates to specialized services for implementation
+ */
+
+import { Injectable } from '@nestjs/common';
 import { User } from '@prisma/client';
-import { PrismaService } from '../prisma/prisma.service';
-import { AppLoggerService } from '../common/logger/logger.service';
-import { EmailService } from '../common/email/email.service';
 import { SignupDto } from './dto/signup.dto';
 import { LoginDto } from './dto/login.dto';
 import {
@@ -21,566 +15,80 @@ import {
   ResetPasswordDto,
   ChangePasswordDto,
 } from './dto/verification.dto';
+import { ChangeEmailDto } from './dto/change-email.dto';
+import { DeleteAccountDto } from './dto/delete-account.dto';
 import {
-  APP_CONSTANTS,
-  ERROR_MESSAGES,
-} from '../common/constants/app.constants';
+  AuthCoreService,
+  TokenRefreshService,
+  EmailVerificationService,
+  PasswordResetService,
+  AccountManagementService,
+} from './services';
 
-// Type for a user object without the password field
 type ValidatedUser = Omit<User, 'password'>;
-// Type for the user data we encode in the JWT
-type JwtUserPayload = Pick<
-  User,
-  'id' | 'email' | 'role' | 'hasCompletedOnboarding'
->;
 
 @Injectable()
 export class AuthService {
   constructor(
-    private readonly prisma: PrismaService,
-    private readonly jwtService: JwtService,
-    private readonly logger: AppLoggerService,
-    private readonly emailService: EmailService,
+    private readonly authCoreService: AuthCoreService,
+    private readonly tokenRefreshService: TokenRefreshService,
+    private readonly emailVerificationService: EmailVerificationService,
+    private readonly passwordResetService: PasswordResetService,
+    private readonly accountManagementService: AccountManagementService,
   ) {}
 
-  async signup(signupDto: SignupDto) {
-    const { email, password, name } = signupDto;
-
-    const existingUser = await this.prisma.user.findUnique({
-      where: { email },
-    });
-
-    if (existingUser) {
-      this.logger.warn(`Signup attempt for existing email`, 'AuthService', {
-        email,
-      });
-      throw new ConflictException(ERROR_MESSAGES.EMAIL_ALREADY_EXISTS);
-    }
-
-    const hashedPassword = await bcrypt.hash(
-      password,
-      APP_CONSTANTS.BCRYPT_ROUNDS,
-    );
+  // ==================== Core Authentication ====================
 
-    const user = await this.prisma.user.create({
-      data: {
-        email,
-        name: name || email.split('@')[0],
-        password: hashedPassword,
-        hasCompletedOnboarding: false,
-      },
-    });
-
-    this.logger.log(`User registered successfully`, 'AuthService', {
-      userId: user.id,
-      email,
-    });
-
-    const token = this.generateToken({
-      id: user.id,
-      email: user.email!, // email is non-null after creation
-      role: user.role,
-      hasCompletedOnboarding: user.hasCompletedOnboarding,
-    });
-
-    return {
-      success: true,
-      user: {
-        id: user.id,
-        email: user.email,
-        name: user.name,
-        role: user.role,
-        username: user.username,
-        image: user.image,
-        hasCompletedOnboarding: user.hasCompletedOnboarding,
-      },
-      token,
-    };
+  async signup(dto: SignupDto) {
+    return this.authCoreService.signup(dto);
   }
 
   async validateUser(
     email: string,
     password: string,
   ): Promise<ValidatedUser | null> {
-    const user = await this.prisma.user.findUnique({
-      where: { email },
-    });
-
-    if (!user || !user.password) {
-      this.logger.warn(`Failed login attempt - user not found`, 'AuthService', {
-        email,
-      });
-      return null;
-    }
-
-    const isPasswordValid = await bcrypt.compare(password, user.password);
-
-    if (!isPasswordValid) {
-      this.logger.warn(
-        `Failed login attempt - invalid password`,
-        'AuthService',
-        { email },
-      );
-      return null;
-    }
-
-    // eslint-disable-next-line @typescript-eslint/no-unused-vars
-    const { password: _, ...result } = user;
-    return result;
+    return this.authCoreService.validateUser(email, password);
   }
 
-  async login(loginDto: LoginDto) {
-    const user = await this.validateUser(loginDto.email, loginDto.password);
-
-    if (!user) {
-      throw new UnauthorizedException(ERROR_MESSAGES.INVALID_CREDENTIALS);
-    }
-
-    const token = this.generateToken({
-      id: user.id,
-      email: user.email!, // email is non-null for a validated user
-      role: user.role,
-      hasCompletedOnboarding: user.hasCompletedOnboarding,
-    });
-
-    this.logger.log(`User logged in successfully`, 'AuthService', {
-      userId: user.id,
-      email: user.email,
-    });
-
-    return {
-      success: true,
-      user: {
-        id: user.id,
-        email: user.email,
-        name: user.name,
-        role: user.role,
-        username: user.username,
-        image: user.image,
-        hasCompletedOnboarding: user.hasCompletedOnboarding,
-      },
-      token,
-    };
+  async login(dto: LoginDto) {
+    return this.authCoreService.login(dto);
   }
 
   async refreshToken(userId: string) {
-    const user = await this.prisma.user.findUnique({
-      where: { id: userId },
-      select: {
-        id: true,
-        email: true,
-        name: true,
-        role: true,
-        hasCompletedOnboarding: true,
-      },
-    });
-
-    if (!user || !user.email) {
-      this.logger.warn(`Token refresh failed - user not found`, 'AuthService', {
-        userId,
-      });
-      throw new UnauthorizedException(ERROR_MESSAGES.USER_NOT_FOUND);
-    }
-
-    const token = this.generateToken({
-      id: user.id,
-      email: user.email,
-      role: user.role,
-      hasCompletedOnboarding: user.hasCompletedOnboarding,
-    });
-
-    this.logger.debug(`Token refreshed`, 'AuthService', { userId });
-
-    return {
-      success: true,
-      token,
-      user: {
-        id: user.id,
-        email: user.email,
-        name: user.name,
-        hasCompletedOnboarding: user.hasCompletedOnboarding,
-      },
-    };
-  }
-
-  private generateToken(user: JwtUserPayload): string {
-    const payload = {
-      sub: user.id,
-      email: user.email,
-      role: user.role,
-      hasCompletedOnboarding: user.hasCompletedOnboarding ?? false,
-    };
-
-    return this.jwtService.sign(payload);
+    return this.tokenRefreshService.refreshToken(userId);
   }
 
   // ==================== Email Verification ====================
 
   async requestEmailVerification(dto: RequestVerificationDto) {
-    const user = await this.prisma.user.findUnique({
-      where: { email: dto.email },
-    });
-
-    if (!user) {
-      // Return success even if user not found to prevent email enumeration
-      return {
-        success: true,
-        message: 'If the email exists, a verification link has been sent',
-      };
-    }
-
-    if (user.emailVerified) {
-      return { success: true, message: 'Email is already verified' };
-    }
-
-    // Generate verification token
-    const token = crypto.randomBytes(32).toString('hex');
-    const expires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours
-
-    // Store verification token
-    await this.prisma.verificationToken.upsert({
-      where: {
-        identifier_token: {
-          identifier: dto.email,
-          token: token,
-        },
-      },
-      update: {
-        token,
-        expires,
-      },
-      create: {
-        identifier: dto.email,
-        token,
-        expires,
-      },
-    });
-
-    this.logger.log(`Verification token created`, 'AuthService', {
-      email: dto.email,
-    });
-
-    // Send verification email
-    try {
-      await this.emailService.sendVerificationEmail(
-        dto.email,
-        user.name || 'Usuário',
-        token,
-      );
-    } catch (error) {
-      this.logger.error(
-        'Failed to send verification email',
-        error instanceof Error ? error.stack : 'Unknown error',
-        'AuthService',
-      );
-      // Don't fail the request if email fails
-    }
-
-    return {
-      success: true,
-      message: 'Verification email sent',
-      // Remove token from response in production
-      ...(process.env.NODE_ENV !== 'production' && { token }),
-    };
+    return this.emailVerificationService.requestVerification(dto);
   }
 
   async verifyEmail(dto: VerifyEmailDto) {
-    const verificationToken = await this.prisma.verificationToken.findUnique({
-      where: { token: dto.token },
-    });
-
-    if (!verificationToken) {
-      throw new BadRequestException('Invalid or expired verification token');
-    }
-
-    if (verificationToken.expires < new Date()) {
-      // Clean up expired token
-      await this.prisma.verificationToken.delete({
-        where: { token: dto.token },
-      });
-      throw new BadRequestException('Verification token has expired');
-    }
-
-    // Update user's email verification status
-    await this.prisma.user.update({
-      where: { email: verificationToken.identifier },
-      data: { emailVerified: new Date() },
-    });
-
-    // Delete the used token
-    await this.prisma.verificationToken.delete({
-      where: { token: dto.token },
-    });
-
-    this.logger.log(`Email verified successfully`, 'AuthService', {
-      email: verificationToken.identifier,
-    });
-
-    // Send welcome email
-    const user = await this.prisma.user.findUnique({
-      where: { email: verificationToken.identifier },
-    });
-
-    if (user) {
-      try {
-        await this.emailService.sendWelcomeEmail(
-          user.email!,
-          user.name || 'Usuário',
-        );
-      } catch (error) {
-        this.logger.error(
-          'Failed to send welcome email',
-          error instanceof Error ? error.stack : 'Unknown error',
-          'AuthService',
-        );
-        // Don't fail the request if email fails
-      }
-    }
-
-    return { success: true, message: 'Email verified successfully' };
+    return this.emailVerificationService.verifyEmail(dto);
   }
 
-  // ==================== Password Reset ====================
+  // ==================== Password Operations ====================
 
   async forgotPassword(dto: ForgotPasswordDto) {
-    const user = await this.prisma.user.findUnique({
-      where: { email: dto.email },
-    });
-
-    // Always return success to prevent email enumeration
-    if (!user) {
-      return {
-        success: true,
-        message: 'If the email exists, a password reset link has been sent',
-      };
-    }
-
-    // Generate reset token
-    const token = crypto.randomBytes(32).toString('hex');
-    const expires = new Date(Date.now() + 1 * 60 * 60 * 1000); // 1 hour
-
-    // Store reset token (using verification token table with different identifier prefix)
-    await this.prisma.verificationToken.upsert({
-      where: {
-        identifier_token: {
-          identifier: `reset:${dto.email}`,
-          token: token,
-        },
-      },
-      update: {
-        token,
-        expires,
-      },
-      create: {
-        identifier: `reset:${dto.email}`,
-        token,
-        expires,
-      },
-    });
-
-    this.logger.log(`Password reset token created`, 'AuthService', {
-      email: dto.email,
-    });
-
-    // Send password reset email
-    try {
-      await this.emailService.sendPasswordResetEmail(
-        user.email!,
-        user.name || 'Usuário',
-        token,
-      );
-    } catch (error) {
-      this.logger.error(
-        'Failed to send password reset email',
-        error instanceof Error ? error.stack : 'Unknown error',
-        'AuthService',
-      );
-      // Don't fail the request if email fails
-    }
-
-    return {
-      success: true,
-      message: 'Password reset email sent',
-      // Remove token from response in production
-      ...(process.env.NODE_ENV !== 'production' && { token }),
-    };
+    return this.passwordResetService.forgotPassword(dto);
   }
 
   async resetPassword(dto: ResetPasswordDto) {
-    const verificationToken = await this.prisma.verificationToken.findUnique({
-      where: { token: dto.token },
-    });
-
-    if (
-      !verificationToken ||
-      !verificationToken.identifier.startsWith('reset:')
-    ) {
-      throw new BadRequestException('Invalid or expired reset token');
-    }
-
-    if (verificationToken.expires < new Date()) {
-      await this.prisma.verificationToken.delete({
-        where: { token: dto.token },
-      });
-      throw new BadRequestException('Reset token has expired');
-    }
-
-    const email = verificationToken.identifier.replace('reset:', '');
-    const hashedPassword = await bcrypt.hash(
-      dto.password,
-      APP_CONSTANTS.BCRYPT_ROUNDS,
-    );
-
-    await this.prisma.user.update({
-      where: { email },
-      data: { password: hashedPassword },
-    });
-
-    // Delete the used token
-    await this.prisma.verificationToken.delete({
-      where: { token: dto.token },
-    });
-
-    this.logger.log(`Password reset successfully`, 'AuthService', { email });
-
-    return { success: true, message: 'Password reset successfully' };
+    return this.passwordResetService.resetPassword(dto);
   }
 
   async changePassword(userId: string, dto: ChangePasswordDto) {
-    const user = await this.prisma.user.findUnique({
-      where: { id: userId },
-    });
-
-    if (!user || !user.password) {
-      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
-    }
-
-    const isCurrentPasswordValid = await bcrypt.compare(
-      dto.currentPassword,
-      user.password,
-    );
-    if (!isCurrentPasswordValid) {
-      throw new UnauthorizedException('Current password is incorrect');
-    }
-
-    const hashedPassword = await bcrypt.hash(
-      dto.newPassword,
-      APP_CONSTANTS.BCRYPT_ROUNDS,
-    );
-
-    await this.prisma.user.update({
-      where: { id: userId },
-      data: { password: hashedPassword },
-    });
-
-    this.logger.log(`Password changed successfully`, 'AuthService', { userId });
-
-    // Send password changed notification email
-    try {
-      await this.emailService.sendPasswordChangedEmail(
-        user.email!,
-        user.name || 'Usuário',
-      );
-    } catch (error) {
-      this.logger.error(
-        'Failed to send password changed email',
-        error instanceof Error ? error.stack : 'Unknown error',
-        'AuthService',
-      );
-      // Don't fail the request if email fails
-    }
-
-    return { success: true, message: 'Password changed successfully' };
+    return this.passwordResetService.changePassword(userId, dto);
   }
 
-  /**
-   * Change user email
-   */
-  async changeEmail(userId: string, dto: any) {
-    const { newEmail, currentPassword } = dto;
-
-    // Get user
-    const user = await this.prisma.user.findUnique({ where: { id: userId } });
-
-    if (!user || !user.password) {
-      throw new UnauthorizedException('Invalid credentials');
-    }
-
-    // Verify current password
-    const isPasswordValid = await bcrypt.compare(
-      currentPassword,
-      user.password,
-    );
-
-    if (!isPasswordValid) {
-      throw new UnauthorizedException('Current password is incorrect');
-    }
-
-    // Check if new email is already in use
-    const existingUser = await this.prisma.user.findUnique({
-      where: { email: newEmail },
-    });
-
-    if (existingUser) {
-      throw new ConflictException('Email already in use');
-    }
-
-    // Update email
-    await this.prisma.user.update({
-      where: { id: userId },
-      data: {
-        email: newEmail,
-        emailVerified: null, // Reset verification
-      },
-    });
-
-    this.logger.log(`Email changed for user`, 'AuthService', { userId });
+  // ==================== Account Management ====================
 
-    return {
-      success: true,
-      message: 'Email changed successfully. Please verify your new email.',
-    };
+  async changeEmail(userId: string, dto: ChangeEmailDto) {
+    return this.accountManagementService.changeEmail(userId, dto);
   }
 
-  /**
-   * Delete user account
-   */
-  async deleteAccount(userId: string, dto: any) {
-    const { password } = dto;
-
-    // Get user
-    const user = await this.prisma.user.findUnique({ where: { id: userId } });
-
-    if (!user || !user.password) {
-      throw new UnauthorizedException('Invalid credentials');
-    }
-
-    // Verify password
-    const isPasswordValid = await bcrypt.compare(password, user.password);
-
-    if (!isPasswordValid) {
-      throw new UnauthorizedException('Password is incorrect');
-    }
-
-    // Prevent deleting admin if they're the last one
-    if (user.role === 'ADMIN') {
-      const adminCount = await this.prisma.user.count({
-        where: { role: 'ADMIN' },
-      });
-
-      if (adminCount <= 1) {
-        throw new BadRequestException('Cannot delete the last admin account');
-      }
-    }
-
-    // Delete user (cascade will delete related data)
-    await this.prisma.user.delete({ where: { id: userId } });
-
-    this.logger.log(`Account deleted`, 'AuthService', { userId });
-
-    return {
-      success: true,
-      message: 'Account deleted successfully',
-    };
+  async deleteAccount(userId: string, dto: DeleteAccountDto) {
+    return this.accountManagementService.deleteAccount(userId, dto);
   }
 }
diff --git a/src/auth/controllers/auth-account.controller.ts b/src/auth/controllers/auth-account.controller.ts
new file mode 100644
index 0000000..b74da2b
--- /dev/null
+++ b/src/auth/controllers/auth-account.controller.ts
@@ -0,0 +1,60 @@
+/**
+ * Auth Account Controller
+ * Handles account management endpoints
+ */
+
+import {
+  Controller,
+  Post,
+  Body,
+  UseGuards,
+  HttpCode,
+  HttpStatus,
+} from '@nestjs/common';
+import {
+  ApiTags,
+  ApiOperation,
+  ApiResponse,
+  ApiBearerAuth,
+} from '@nestjs/swagger';
+import { AuthService } from '../auth.service';
+import { ChangeEmailDto } from '../dto/change-email.dto';
+import { DeleteAccountDto } from '../dto/delete-account.dto';
+import { JwtAuthGuard } from '../guards/jwt-auth.guard';
+import { CurrentUser } from '../../common/decorators/current-user.decorator';
+import { UserPayload } from '../interfaces/auth-request.interface';
+
+@ApiTags('auth')
+@Controller('auth')
+export class AuthAccountController {
+  constructor(private readonly authService: AuthService) {}
+
+  @UseGuards(JwtAuthGuard)
+  @Post('change-email')
+  @HttpCode(HttpStatus.OK)
+  @ApiBearerAuth('JWT-auth')
+  @ApiOperation({ summary: 'Change email address (authenticated)' })
+  @ApiResponse({ status: 200, description: 'Email changed successfully' })
+  @ApiResponse({ status: 400, description: 'Invalid email or password' })
+  @ApiResponse({ status: 409, description: 'Email already in use' })
+  async changeEmail(
+    @CurrentUser() user: UserPayload,
+    @Body() dto: ChangeEmailDto,
+  ) {
+    return this.authService.changeEmail(user.userId, dto);
+  }
+
+  @UseGuards(JwtAuthGuard)
+  @Post('delete-account')
+  @HttpCode(HttpStatus.OK)
+  @ApiBearerAuth('JWT-auth')
+  @ApiOperation({ summary: 'Delete own account (authenticated)' })
+  @ApiResponse({ status: 200, description: 'Account deleted successfully' })
+  @ApiResponse({ status: 401, description: 'Password is incorrect' })
+  async deleteAccount(
+    @CurrentUser() user: UserPayload,
+    @Body() dto: DeleteAccountDto,
+  ) {
+    return this.authService.deleteAccount(user.userId, dto);
+  }
+}
diff --git a/src/auth/controllers/auth-core.controller.ts b/src/auth/controllers/auth-core.controller.ts
new file mode 100644
index 0000000..c51c69b
--- /dev/null
+++ b/src/auth/controllers/auth-core.controller.ts
@@ -0,0 +1,73 @@
+/**
+ * Auth Core Controller
+ * Handles signup, login, and token refresh
+ */
+
+import {
+  Controller,
+  Post,
+  Body,
+  UseGuards,
+  HttpCode,
+  HttpStatus,
+} from '@nestjs/common';
+import {
+  ApiTags,
+  ApiOperation,
+  ApiResponse,
+  ApiBearerAuth,
+} from '@nestjs/swagger';
+import { Throttle, SkipThrottle } from '@nestjs/throttler';
+import { AuthService } from '../auth.service';
+import { SignupDto } from '../dto/signup.dto';
+import { LoginDto } from '../dto/login.dto';
+import { Public } from '../decorators/public.decorator';
+import { JwtAuthGuard } from '../guards/jwt-auth.guard';
+import { CurrentUser } from '../../common/decorators/current-user.decorator';
+import { UserPayload } from '../interfaces/auth-request.interface';
+import { APP_CONSTANTS } from '../../common/constants/app.constants';
+
+@ApiTags('auth')
+@Controller('auth')
+export class AuthCoreController {
+  constructor(private readonly authService: AuthService) {}
+
+  @Public()
+  @Post('signup')
+  @Throttle({
+    default: { ttl: 60000, limit: APP_CONSTANTS.AUTH_RATE_LIMIT_MAX_REQUESTS },
+  })
+  @HttpCode(HttpStatus.CREATED)
+  @ApiOperation({ summary: 'Register a new user' })
+  @ApiResponse({ status: 201, description: 'User successfully registered' })
+  @ApiResponse({ status: 409, description: 'Email already registered' })
+  @ApiResponse({ status: 400, description: 'Invalid input data' })
+  async signup(@Body() signupDto: SignupDto) {
+    return this.authService.signup(signupDto);
+  }
+
+  @Public()
+  @Post('login')
+  @Throttle({
+    default: { ttl: 60000, limit: APP_CONSTANTS.AUTH_RATE_LIMIT_MAX_REQUESTS },
+  })
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({ summary: 'Login with email and password' })
+  @ApiResponse({ status: 200, description: 'Login successful' })
+  @ApiResponse({ status: 401, description: 'Invalid credentials' })
+  async login(@Body() loginDto: LoginDto) {
+    return this.authService.login(loginDto);
+  }
+
+  @UseGuards(JwtAuthGuard)
+  @SkipThrottle()
+  @Post('refresh')
+  @HttpCode(HttpStatus.OK)
+  @ApiBearerAuth('JWT-auth')
+  @ApiOperation({ summary: 'Refresh JWT token' })
+  @ApiResponse({ status: 200, description: 'Token refreshed successfully' })
+  @ApiResponse({ status: 401, description: 'Unauthorized' })
+  async refreshToken(@CurrentUser() user: UserPayload) {
+    return this.authService.refreshToken(user.userId);
+  }
+}
diff --git a/src/auth/controllers/auth-password.controller.ts b/src/auth/controllers/auth-password.controller.ts
new file mode 100644
index 0000000..37beffb
--- /dev/null
+++ b/src/auth/controllers/auth-password.controller.ts
@@ -0,0 +1,75 @@
+/**
+ * Auth Password Controller
+ * Handles password-related endpoints
+ */
+
+import {
+  Controller,
+  Post,
+  Body,
+  UseGuards,
+  HttpCode,
+  HttpStatus,
+} from '@nestjs/common';
+import {
+  ApiTags,
+  ApiOperation,
+  ApiResponse,
+  ApiBearerAuth,
+} from '@nestjs/swagger';
+import { Throttle } from '@nestjs/throttler';
+import { AuthService } from '../auth.service';
+import {
+  ForgotPasswordDto,
+  ResetPasswordDto,
+  ChangePasswordDto,
+} from '../dto/verification.dto';
+import { Public } from '../decorators/public.decorator';
+import { JwtAuthGuard } from '../guards/jwt-auth.guard';
+import { CurrentUser } from '../../common/decorators/current-user.decorator';
+import { UserPayload } from '../interfaces/auth-request.interface';
+import { APP_CONSTANTS } from '../../common/constants/app.constants';
+
+@ApiTags('auth')
+@Controller('auth')
+export class AuthPasswordController {
+  constructor(private readonly authService: AuthService) {}
+
+  @Public()
+  @Post('forgot-password')
+  @Throttle({ default: { ttl: 60000, limit: 3 } })
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({ summary: 'Request password reset' })
+  @ApiResponse({ status: 200, description: 'Password reset email sent' })
+  @ApiResponse({ status: 429, description: 'Too many requests' })
+  async forgotPassword(@Body() dto: ForgotPasswordDto) {
+    return this.authService.forgotPassword(dto);
+  }
+
+  @Public()
+  @Post('reset-password')
+  @Throttle({
+    default: { ttl: 60000, limit: APP_CONSTANTS.AUTH_RATE_LIMIT_MAX_REQUESTS },
+  })
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({ summary: 'Reset password with token' })
+  @ApiResponse({ status: 200, description: 'Password reset successfully' })
+  @ApiResponse({ status: 400, description: 'Invalid or expired token' })
+  async resetPassword(@Body() dto: ResetPasswordDto) {
+    return this.authService.resetPassword(dto);
+  }
+
+  @UseGuards(JwtAuthGuard)
+  @Post('change-password')
+  @HttpCode(HttpStatus.OK)
+  @ApiBearerAuth('JWT-auth')
+  @ApiOperation({ summary: 'Change password (authenticated)' })
+  @ApiResponse({ status: 200, description: 'Password changed successfully' })
+  @ApiResponse({ status: 401, description: 'Current password is incorrect' })
+  async changePassword(
+    @CurrentUser() user: UserPayload,
+    @Body() dto: ChangePasswordDto,
+  ) {
+    return this.authService.changePassword(user.userId, dto);
+  }
+}
diff --git a/src/auth/controllers/auth-verification.controller.ts b/src/auth/controllers/auth-verification.controller.ts
new file mode 100644
index 0000000..1399dcc
--- /dev/null
+++ b/src/auth/controllers/auth-verification.controller.ts
@@ -0,0 +1,41 @@
+/**
+ * Auth Verification Controller
+ * Handles email verification endpoints
+ */
+
+import { Controller, Post, Body, HttpCode, HttpStatus } from '@nestjs/common';
+import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
+import { Throttle } from '@nestjs/throttler';
+import { AuthService } from '../auth.service';
+import {
+  RequestVerificationDto,
+  VerifyEmailDto,
+} from '../dto/verification.dto';
+import { Public } from '../decorators/public.decorator';
+
+@ApiTags('auth')
+@Controller('auth')
+export class AuthVerificationController {
+  constructor(private readonly authService: AuthService) {}
+
+  @Public()
+  @Post('verify-email/request')
+  @Throttle({ default: { ttl: 60000, limit: 3 } })
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({ summary: 'Request email verification' })
+  @ApiResponse({ status: 200, description: 'Verification email sent' })
+  @ApiResponse({ status: 429, description: 'Too many requests' })
+  async requestEmailVerification(@Body() dto: RequestVerificationDto) {
+    return this.authService.requestEmailVerification(dto);
+  }
+
+  @Public()
+  @Post('verify-email')
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({ summary: 'Verify email with token' })
+  @ApiResponse({ status: 200, description: 'Email verified successfully' })
+  @ApiResponse({ status: 400, description: 'Invalid or expired token' })
+  async verifyEmail(@Body() dto: VerifyEmailDto) {
+    return this.authService.verifyEmail(dto);
+  }
+}
diff --git a/src/auth/controllers/index.ts b/src/auth/controllers/index.ts
new file mode 100644
index 0000000..48f7bcf
--- /dev/null
+++ b/src/auth/controllers/index.ts
@@ -0,0 +1,8 @@
+/**
+ * Auth Controllers - Barrel Export
+ */
+
+export { AuthCoreController } from './auth-core.controller';
+export { AuthVerificationController } from './auth-verification.controller';
+export { AuthPasswordController } from './auth-password.controller';
+export { AuthAccountController } from './auth-account.controller';
diff --git a/src/auth/services/account-management.service.ts b/src/auth/services/account-management.service.ts
new file mode 100644
index 0000000..b370c8f
--- /dev/null
+++ b/src/auth/services/account-management.service.ts
@@ -0,0 +1,120 @@
+/**
+ * Account Management Service
+ * Single Responsibility: Handle account-level operations (email change, deletion)
+ */
+
+import {
+  Injectable,
+  UnauthorizedException,
+  ConflictException,
+  BadRequestException,
+} from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { PasswordService } from './password.service';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
+import { ChangeEmailDto } from '../dto/change-email.dto';
+import { DeleteAccountDto } from '../dto/delete-account.dto';
+
+@Injectable()
+export class AccountManagementService {
+  private readonly context = 'AccountManagement';
+
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly logger: AppLoggerService,
+    private readonly passwordService: PasswordService,
+  ) {}
+
+  async changeEmail(userId: string, dto: ChangeEmailDto) {
+    const { newEmail, currentPassword } = dto;
+
+    const user = await this.findUserWithPassword(userId);
+
+    await this.validatePassword(user, currentPassword);
+    await this.ensureEmailNotTaken(newEmail);
+
+    await this.updateEmail(userId, newEmail);
+
+    this.logger.log(`Email changed for user`, this.context, { userId });
+
+    return {
+      success: true,
+      message: 'Email changed successfully. Please verify your new email.',
+    };
+  }
+
+  async deleteAccount(userId: string, dto: DeleteAccountDto) {
+    const { password } = dto;
+
+    const user = await this.findUserWithPassword(userId);
+
+    await this.validatePassword(user, password);
+    await this.preventLastAdminDeletion(user.role);
+
+    await this.prisma.user.delete({ where: { id: userId } });
+
+    this.logger.log(`Account deleted`, this.context, { userId });
+
+    return {
+      success: true,
+      message: 'Account deleted successfully',
+    };
+  }
+
+  private async findUserWithPassword(userId: string) {
+    const user = await this.prisma.user.findUnique({
+      where: { id: userId },
+      select: { id: true, email: true, password: true, role: true },
+    });
+
+    if (!user?.password) {
+      throw new UnauthorizedException(ERROR_MESSAGES.INVALID_CREDENTIALS);
+    }
+
+    return { ...user, password: user.password };
+  }
+
+  private async validatePassword(
+    user: { password: string },
+    password: string,
+  ): Promise<void> {
+    const isValid = await this.passwordService.compare(password, user.password);
+
+    if (!isValid) {
+      throw new UnauthorizedException(ERROR_MESSAGES.PASSWORD_INCORRECT);
+    }
+  }
+
+  private async ensureEmailNotTaken(email: string): Promise<void> {
+    const existingUser = await this.prisma.user.findUnique({
+      where: { email },
+    });
+
+    if (existingUser) {
+      throw new ConflictException(ERROR_MESSAGES.EMAIL_ALREADY_IN_USE);
+    }
+  }
+
+  private async updateEmail(userId: string, email: string): Promise<void> {
+    await this.prisma.user.update({
+      where: { id: userId },
+      data: {
+        email,
+        emailVerified: null, // Reset verification
+      },
+    });
+  }
+
+  private async preventLastAdminDeletion(role: string): Promise<void> {
+    if (role !== 'ADMIN') return;
+
+    const adminCount = await this.prisma.user.count({
+      where: { role: 'ADMIN' },
+    });
+
+    if (adminCount <= 1) {
+      throw new BadRequestException(ERROR_MESSAGES.CANNOT_DELETE_LAST_ADMIN);
+    }
+  }
+}
diff --git a/src/auth/services/auth-core.service.ts b/src/auth/services/auth-core.service.ts
new file mode 100644
index 0000000..e20511c
--- /dev/null
+++ b/src/auth/services/auth-core.service.ts
@@ -0,0 +1,164 @@
+/**
+ * Auth Core Service
+ * Single Responsibility: Core authentication operations (signup, login, token refresh)
+ */
+
+import {
+  Injectable,
+  ConflictException,
+  UnauthorizedException,
+} from '@nestjs/common';
+import { User } from '@prisma/client';
+import { PrismaService } from '../../prisma/prisma.service';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { SignupDto } from '../dto/signup.dto';
+import { LoginDto } from '../dto/login.dto';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
+import { TokenService } from './token.service';
+import { PasswordService } from './password.service';
+
+type ValidatedUser = Omit<User, 'password'>;
+
+@Injectable()
+export class AuthCoreService {
+  private readonly context = 'AuthCoreService';
+
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly logger: AppLoggerService,
+    private readonly tokenService: TokenService,
+    private readonly passwordService: PasswordService,
+  ) {}
+
+  async signup(dto: SignupDto) {
+    const { email, password, name } = dto;
+
+    await this.ensureEmailNotExists(email);
+
+    const hashedPassword = await this.passwordService.hash(password);
+
+    const user = await this.prisma.user.create({
+      data: {
+        email,
+        name: name ?? email.split('@')[0],
+        password: hashedPassword,
+        hasCompletedOnboarding: false,
+      },
+    });
+
+    this.logger.log(`User registered successfully`, this.context, {
+      userId: user.id,
+      email,
+    });
+
+    if (!user.email) {
+      throw new Error('User email is required after registration');
+    }
+
+    const token = this.tokenService.generateToken({
+      id: user.id,
+      email: user.email,
+      role: user.role,
+      hasCompletedOnboarding: user.hasCompletedOnboarding,
+    });
+
+    return this.buildAuthResponse(user, token);
+  }
+
+  async validateUser(
+    email: string,
+    password: string,
+  ): Promise<ValidatedUser | null> {
+    const user = await this.prisma.user.findUnique({ where: { email } });
+
+    if (!user?.password) {
+      this.logger.warn(`Failed login attempt - user not found`, this.context, {
+        email,
+      });
+      return null;
+    }
+
+    const isPasswordValid = await this.passwordService.compare(
+      password,
+      user.password,
+    );
+
+    if (!isPasswordValid) {
+      this.logger.warn(
+        `Failed login attempt - invalid password`,
+        this.context,
+        { email },
+      );
+      return null;
+    }
+
+    const { password: _, ...result } = user;
+    return result;
+  }
+
+  async login(dto: LoginDto) {
+    const user = await this.validateUser(dto.email, dto.password);
+
+    if (!user) {
+      throw new UnauthorizedException(ERROR_MESSAGES.INVALID_CREDENTIALS);
+    }
+
+    if (!user.email) {
+      throw new UnauthorizedException(ERROR_MESSAGES.INVALID_CREDENTIALS);
+    }
+
+    const token = this.tokenService.generateToken({
+      id: user.id,
+      email: user.email,
+      role: user.role,
+      hasCompletedOnboarding: user.hasCompletedOnboarding,
+    });
+
+    this.logger.log(`User logged in successfully`, this.context, {
+      userId: user.id,
+      email: user.email,
+    });
+
+    return this.buildAuthResponse(user, token);
+  }
+
+  private async ensureEmailNotExists(email: string): Promise<void> {
+    const existingUser = await this.prisma.user.findUnique({
+      where: { email },
+    });
+
+    if (existingUser) {
+      this.logger.warn(`Signup attempt for existing email`, this.context, {
+        email,
+      });
+      throw new ConflictException(ERROR_MESSAGES.EMAIL_ALREADY_EXISTS);
+    }
+  }
+
+  private buildAuthResponse(
+    user: {
+      id: string;
+      email: string | null;
+      name: string | null;
+      role: string;
+      username?: string | null;
+      image?: string | null;
+      hasCompletedOnboarding: boolean;
+    },
+    token: string,
+  ) {
+    return {
+      success: true,
+      user: {
+        id: user.id,
+        email: user.email,
+        name: user.name,
+        role: user.role,
+        username: user.username ?? null,
+        image: user.image ?? null,
+        hasCompletedOnboarding: user.hasCompletedOnboarding,
+      },
+      token,
+    };
+  }
+}
diff --git a/src/auth/services/email-verification.service.ts b/src/auth/services/email-verification.service.ts
new file mode 100644
index 0000000..94eb251
--- /dev/null
+++ b/src/auth/services/email-verification.service.ts
@@ -0,0 +1,125 @@
+/**
+ * Email Verification Service
+ * Single Responsibility: Handle email verification flow
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { EmailService } from '../../common/email/email.service';
+import { VerificationTokenService } from './verification-token.service';
+import {
+  RequestVerificationDto,
+  VerifyEmailDto,
+} from '../dto/verification.dto';
+
+@Injectable()
+export class EmailVerificationService {
+  private readonly context = 'EmailVerification';
+
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly logger: AppLoggerService,
+    private readonly emailService: EmailService,
+    private readonly tokenService: VerificationTokenService,
+  ) {}
+
+  async requestVerification(dto: RequestVerificationDto) {
+    const user = await this.findUserByEmail(dto.email);
+
+    if (!user) {
+      // Return success even if user not found to prevent email enumeration
+      return this.buildSuccessResponse(
+        'If the email exists, a verification link has been sent',
+      );
+    }
+
+    if (user.emailVerified) {
+      return this.buildSuccessResponse('Email is already verified');
+    }
+
+    const token = await this.tokenService.createEmailVerificationToken(
+      dto.email,
+    );
+
+    this.logger.log(`Verification token created`, this.context, {
+      email: dto.email,
+    });
+
+    await this.sendVerificationEmail(dto.email, user.name, token);
+
+    return {
+      success: true,
+      message: 'Verification email sent',
+      ...(process.env.NODE_ENV !== 'production' && { token }),
+    };
+  }
+
+  async verifyEmail(dto: VerifyEmailDto) {
+    const email = await this.tokenService.validateEmailVerificationToken(
+      dto.token,
+    );
+
+    await this.markEmailAsVerified(email);
+
+    this.logger.log(`Email verified successfully`, this.context, { email });
+
+    await this.sendWelcomeEmail(email);
+
+    return this.buildSuccessResponse('Email verified successfully');
+  }
+
+  private async findUserByEmail(email: string) {
+    return this.prisma.user.findUnique({
+      where: { email },
+      select: { id: true, email: true, name: true, emailVerified: true },
+    });
+  }
+
+  private async markEmailAsVerified(email: string): Promise<void> {
+    await this.prisma.user.update({
+      where: { email },
+      data: { emailVerified: new Date() },
+    });
+  }
+
+  private async sendVerificationEmail(
+    email: string,
+    name: string | null,
+    token: string,
+  ): Promise<void> {
+    try {
+      await this.emailService.sendVerificationEmail(
+        email,
+        name ?? 'Usuário',
+        token,
+      );
+    } catch (error) {
+      this.logger.error(
+        'Failed to send verification email',
+        error instanceof Error ? error.stack : 'Unknown error',
+        this.context,
+      );
+    }
+  }
+
+  private async sendWelcomeEmail(email: string): Promise<void> {
+    const user = await this.findUserByEmail(email);
+
+    if (!user) return;
+
+    try {
+      await this.emailService.sendWelcomeEmail(email, user.name ?? 'Usuário');
+    } catch (error) {
+      this.logger.error(
+        'Failed to send welcome email',
+        error instanceof Error ? error.stack : 'Unknown error',
+        this.context,
+      );
+    }
+  }
+
+  private buildSuccessResponse(message: string) {
+    return { success: true, message };
+  }
+}
diff --git a/src/auth/services/index.ts b/src/auth/services/index.ts
new file mode 100644
index 0000000..136091f
--- /dev/null
+++ b/src/auth/services/index.ts
@@ -0,0 +1,13 @@
+/**
+ * Auth Services Index
+ * Barrel export for all auth services
+ */
+
+export { TokenService, JwtUserPayload, TokenPayload } from './token.service';
+export { PasswordService } from './password.service';
+export { VerificationTokenService } from './verification-token.service';
+export { EmailVerificationService } from './email-verification.service';
+export { PasswordResetService } from './password-reset.service';
+export { AccountManagementService } from './account-management.service';
+export { AuthCoreService } from './auth-core.service';
+export { TokenRefreshService } from './token-refresh.service';
diff --git a/src/auth/services/password-reset.service.ts b/src/auth/services/password-reset.service.ts
new file mode 100644
index 0000000..4de0e2e
--- /dev/null
+++ b/src/auth/services/password-reset.service.ts
@@ -0,0 +1,175 @@
+/**
+ * Password Reset Service
+ * Single Responsibility: Handle password reset and change flows
+ */
+
+import {
+  Injectable,
+  NotFoundException,
+  UnauthorizedException,
+} from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { EmailService } from '../../common/email/email.service';
+import { PasswordService } from './password.service';
+import { VerificationTokenService } from './verification-token.service';
+import {
+  ForgotPasswordDto,
+  ResetPasswordDto,
+  ChangePasswordDto,
+} from '../dto/verification.dto';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
+
+@Injectable()
+export class PasswordResetService {
+  private readonly context = 'PasswordReset';
+
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly logger: AppLoggerService,
+    private readonly emailService: EmailService,
+    private readonly passwordService: PasswordService,
+    private readonly tokenService: VerificationTokenService,
+  ) {}
+
+  async forgotPassword(dto: ForgotPasswordDto) {
+    const user = await this.findUserByEmail(dto.email);
+
+    // Always return success to prevent email enumeration
+    if (!user) {
+      return this.buildSuccessResponse(
+        'If the email exists, a password reset link has been sent',
+      );
+    }
+
+    const token = await this.tokenService.createPasswordResetToken(dto.email);
+
+    this.logger.log(`Password reset token created`, this.context, {
+      email: dto.email,
+    });
+
+    await this.sendPasswordResetEmail(dto.email, user.name, token);
+
+    return {
+      success: true,
+      message: 'Password reset email sent',
+      ...(process.env.NODE_ENV !== 'production' && { token }),
+    };
+  }
+
+  async resetPassword(dto: ResetPasswordDto) {
+    const email = await this.tokenService.validatePasswordResetToken(dto.token);
+
+    const hashedPassword = await this.passwordService.hash(dto.password);
+
+    await this.updatePassword(email, hashedPassword);
+
+    this.logger.log(`Password reset successfully`, this.context, { email });
+
+    return this.buildSuccessResponse('Password reset successfully');
+  }
+
+  async changePassword(userId: string, dto: ChangePasswordDto) {
+    const user = await this.findUserById(userId);
+
+    if (!user?.password) {
+      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
+    }
+
+    const isCurrentPasswordValid = await this.passwordService.compare(
+      dto.currentPassword,
+      user.password,
+    );
+
+    if (!isCurrentPasswordValid) {
+      throw new UnauthorizedException(
+        ERROR_MESSAGES.CURRENT_PASSWORD_INCORRECT,
+      );
+    }
+
+    const hashedPassword = await this.passwordService.hash(dto.newPassword);
+
+    await this.updatePasswordById(userId, hashedPassword);
+
+    this.logger.log(`Password changed successfully`, this.context, { userId });
+
+    if (user.email) {
+      await this.sendPasswordChangedEmail(user.email, user.name);
+    }
+
+    return this.buildSuccessResponse('Password changed successfully');
+  }
+
+  private async findUserByEmail(email: string) {
+    return this.prisma.user.findUnique({
+      where: { email },
+      select: { id: true, email: true, name: true },
+    });
+  }
+
+  private async findUserById(userId: string) {
+    return this.prisma.user.findUnique({
+      where: { id: userId },
+      select: { id: true, email: true, name: true, password: true },
+    });
+  }
+
+  private async updatePassword(email: string, password: string): Promise<void> {
+    await this.prisma.user.update({
+      where: { email },
+      data: { password },
+    });
+  }
+
+  private async updatePasswordById(
+    userId: string,
+    password: string,
+  ): Promise<void> {
+    await this.prisma.user.update({
+      where: { id: userId },
+      data: { password },
+    });
+  }
+
+  private async sendPasswordResetEmail(
+    email: string,
+    name: string | null,
+    token: string,
+  ): Promise<void> {
+    try {
+      await this.emailService.sendPasswordResetEmail(
+        email,
+        name ?? 'Usuário',
+        token,
+      );
+    } catch (error) {
+      this.logger.error(
+        'Failed to send password reset email',
+        error instanceof Error ? error.stack : 'Unknown error',
+        this.context,
+      );
+    }
+  }
+
+  private async sendPasswordChangedEmail(
+    email: string,
+    name: string | null,
+  ): Promise<void> {
+    try {
+      await this.emailService.sendPasswordChangedEmail(
+        email,
+        name ?? 'Usuário',
+      );
+    } catch (error) {
+      this.logger.error(
+        'Failed to send password changed email',
+        error instanceof Error ? error.stack : 'Unknown error',
+        this.context,
+      );
+    }
+  }
+
+  private buildSuccessResponse(message: string) {
+    return { success: true, message };
+  }
+}
diff --git a/src/auth/services/password.service.spec.ts b/src/auth/services/password.service.spec.ts
new file mode 100644
index 0000000..79765ac
--- /dev/null
+++ b/src/auth/services/password.service.spec.ts
@@ -0,0 +1,60 @@
+/**
+ * Password Service Tests
+ */
+
+import { Test, TestingModule } from '@nestjs/testing';
+import { PasswordService } from './password.service';
+
+describe('PasswordService', () => {
+  let service: PasswordService;
+
+  beforeEach(async () => {
+    const module: TestingModule = await Test.createTestingModule({
+      providers: [PasswordService],
+    }).compile();
+
+    service = module.get<PasswordService>(PasswordService);
+  });
+
+  describe('hash', () => {
+    it('should hash a password', async () => {
+      const password = 'testPassword123';
+
+      const hashedPassword = await service.hash(password);
+
+      expect(hashedPassword).toBeDefined();
+      expect(hashedPassword).not.toBe(password);
+      expect(hashedPassword.length).toBeGreaterThan(0);
+    });
+
+    it('should generate different hashes for the same password', async () => {
+      const password = 'testPassword123';
+
+      const hash1 = await service.hash(password);
+      const hash2 = await service.hash(password);
+
+      expect(hash1).not.toBe(hash2);
+    });
+  });
+
+  describe('compare', () => {
+    it('should return true for matching password and hash', async () => {
+      const password = 'testPassword123';
+      const hashedPassword = await service.hash(password);
+
+      const result = await service.compare(password, hashedPassword);
+
+      expect(result).toBe(true);
+    });
+
+    it('should return false for non-matching password', async () => {
+      const password = 'testPassword123';
+      const wrongPassword = 'wrongPassword456';
+      const hashedPassword = await service.hash(password);
+
+      const result = await service.compare(wrongPassword, hashedPassword);
+
+      expect(result).toBe(false);
+    });
+  });
+});
diff --git a/src/auth/services/password.service.ts b/src/auth/services/password.service.ts
new file mode 100644
index 0000000..4914ec8
--- /dev/null
+++ b/src/auth/services/password.service.ts
@@ -0,0 +1,19 @@
+/**
+ * Password Service
+ * Single Responsibility: Password hashing and validation
+ */
+
+import { Injectable } from '@nestjs/common';
+import * as bcrypt from 'bcryptjs';
+import { APP_CONSTANTS } from '../../common/constants/app.constants';
+
+@Injectable()
+export class PasswordService {
+  async hash(password: string): Promise<string> {
+    return bcrypt.hash(password, APP_CONSTANTS.BCRYPT_ROUNDS);
+  }
+
+  async compare(password: string, hash: string): Promise<boolean> {
+    return bcrypt.compare(password, hash);
+  }
+}
diff --git a/src/auth/services/token-refresh.service.ts b/src/auth/services/token-refresh.service.ts
new file mode 100644
index 0000000..c555675
--- /dev/null
+++ b/src/auth/services/token-refresh.service.ts
@@ -0,0 +1,61 @@
+/**
+ * Token Refresh Service
+ * Single Responsibility: Handle token refresh operations
+ */
+
+import { Injectable, UnauthorizedException } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
+import { TokenService } from './token.service';
+
+@Injectable()
+export class TokenRefreshService {
+  private readonly context = 'TokenRefreshService';
+
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly logger: AppLoggerService,
+    private readonly tokenService: TokenService,
+  ) {}
+
+  async refreshToken(userId: string) {
+    const user = await this.prisma.user.findUnique({
+      where: { id: userId },
+      select: {
+        id: true,
+        email: true,
+        name: true,
+        role: true,
+        hasCompletedOnboarding: true,
+      },
+    });
+
+    if (!user?.email) {
+      this.logger.warn(`Token refresh failed - user not found`, this.context, {
+        userId,
+      });
+      throw new UnauthorizedException(ERROR_MESSAGES.USER_NOT_FOUND);
+    }
+
+    const token = this.tokenService.generateToken({
+      id: user.id,
+      email: user.email,
+      role: user.role,
+      hasCompletedOnboarding: user.hasCompletedOnboarding,
+    });
+
+    this.logger.debug(`Token refreshed`, this.context, { userId });
+
+    return {
+      success: true,
+      token,
+      user: {
+        id: user.id,
+        email: user.email,
+        name: user.name,
+        hasCompletedOnboarding: user.hasCompletedOnboarding,
+      },
+    };
+  }
+}
diff --git a/src/auth/services/token.service.spec.ts b/src/auth/services/token.service.spec.ts
new file mode 100644
index 0000000..524e2b5
--- /dev/null
+++ b/src/auth/services/token.service.spec.ts
@@ -0,0 +1,117 @@
+/**
+ * Token Service Tests
+ */
+
+import { Test, TestingModule } from '@nestjs/testing';
+import { JwtService } from '@nestjs/jwt';
+import { TokenService, JwtUserPayload } from './token.service';
+
+describe('TokenService', () => {
+  let service: TokenService;
+  let jwtService: jest.Mocked<JwtService>;
+
+  const mockUser: JwtUserPayload = {
+    id: 'user-123',
+    email: 'test@example.com',
+    role: 'USER',
+    hasCompletedOnboarding: true,
+  };
+
+  beforeEach(async () => {
+    const mockJwtService = {
+      sign: jest.fn(),
+      verify: jest.fn(),
+      decode: jest.fn(),
+    };
+
+    const module: TestingModule = await Test.createTestingModule({
+      providers: [
+        TokenService,
+        { provide: JwtService, useValue: mockJwtService },
+      ],
+    }).compile();
+
+    service = module.get<TokenService>(TokenService);
+    jwtService = module.get(JwtService);
+  });
+
+  describe('generateToken', () => {
+    it('should generate a JWT token with correct payload', () => {
+      const expectedToken = 'jwt-token-123';
+      jwtService.sign.mockReturnValue(expectedToken);
+
+      const result = service.generateToken(mockUser);
+
+      expect(result).toBe(expectedToken);
+      expect(jwtService.sign).toHaveBeenCalledWith({
+        sub: mockUser.id,
+        email: mockUser.email,
+        role: mockUser.role,
+        hasCompletedOnboarding: mockUser.hasCompletedOnboarding,
+      });
+    });
+
+    it('should default hasCompletedOnboarding to false when null', () => {
+      const userWithNullOnboarding = {
+        ...mockUser,
+        hasCompletedOnboarding: null as unknown as boolean,
+      };
+      jwtService.sign.mockReturnValue('token');
+
+      service.generateToken(userWithNullOnboarding);
+
+      expect(jwtService.sign).toHaveBeenCalledWith(
+        expect.objectContaining({
+          hasCompletedOnboarding: false,
+        }),
+      );
+    });
+  });
+
+  describe('verifyToken', () => {
+    it('should verify and return decoded token', () => {
+      const mockPayload = {
+        sub: mockUser.id,
+        email: mockUser.email,
+        role: mockUser.role,
+        hasCompletedOnboarding: true,
+      };
+      jwtService.verify.mockReturnValue(mockPayload);
+
+      const result = service.verifyToken('valid-token');
+
+      expect(result).toEqual(mockPayload);
+      expect(jwtService.verify).toHaveBeenCalledWith('valid-token');
+    });
+
+    it('should throw when token is invalid', () => {
+      jwtService.verify.mockImplementation(() => {
+        throw new Error('Invalid token');
+      });
+
+      expect(() => service.verifyToken('invalid-token')).toThrow(
+        'Invalid token',
+      );
+    });
+  });
+
+  describe('decodeToken', () => {
+    it('should decode token without verification', () => {
+      const mockPayload = { sub: mockUser.id, email: mockUser.email };
+      jwtService.decode.mockReturnValue(mockPayload);
+
+      const result = service.decodeToken('any-token');
+
+      expect(result).toEqual(mockPayload);
+      expect(jwtService.decode).toHaveBeenCalledWith('any-token');
+    });
+
+    it('should return null for invalid token', () => {
+      jwtService.decode.mockReturnValue(null);
+
+      const result = service.decodeToken('invalid-token');
+
+      expect(result).toBeNull();
+    });
+  });
+});
diff --git a/src/auth/services/token.service.ts b/src/auth/services/token.service.ts
new file mode 100644
index 0000000..9ed3cc6
--- /dev/null
+++ b/src/auth/services/token.service.ts
@@ -0,0 +1,48 @@
+/**
+ * Token Service
+ * Single Responsibility: JWT token generation and validation
+ */
+
+import { Injectable } from '@nestjs/common';
+import { JwtService } from '@nestjs/jwt';
+import { User } from '@prisma/client';
+
+export type JwtUserPayload = Pick<
+  User,
+  'id' | 'email' | 'role' | 'hasCompletedOnboarding'
+>;
+
+export interface TokenPayload {
+  sub: string;
+  email: string;
+  role: string;
+  hasCompletedOnboarding: boolean;
+}
+
+@Injectable()
+export class TokenService {
+  constructor(private readonly jwtService: JwtService) {}
+
+  generateToken(user: JwtUserPayload): string {
+    if (!user.email) {
+      throw new Error('User email is required for token generation');
+    }
+
+    const payload: TokenPayload = {
+      sub: user.id,
+      email: user.email,
+      role: user.role,
+      hasCompletedOnboarding: user.hasCompletedOnboarding,
+    };
+
+    return this.jwtService.sign(payload);
+  }
+
+  verifyToken(token: string): TokenPayload {
+    return this.jwtService.verify<TokenPayload>(token);
+  }
+
+  decodeToken(token: string): TokenPayload | null {
+    return this.jwtService.decode(token);
+  }
+}
diff --git a/src/auth/services/verification-token.service.ts b/src/auth/services/verification-token.service.ts
new file mode 100644
index 0000000..57d3213
--- /dev/null
+++ b/src/auth/services/verification-token.service.ts
@@ -0,0 +1,129 @@
+/**
+ * Verification Token Service
+ * Single Responsibility: Create and validate verification tokens
+ */
+
+import { Injectable, BadRequestException } from '@nestjs/common';
+import * as crypto from 'crypto';
+import { PrismaService } from '../../prisma/prisma.service';
+import {
+  TIME_MS,
+  TOKEN_EXPIRY,
+  ERROR_MESSAGES,
+  CRYPTO_CONSTANTS,
+} from '../../common/constants/app.constants';
+
+const RESET_TOKEN_PREFIX = 'reset:';
+
+export interface VerificationResult {
+  email: string;
+  isValid: boolean;
+}
+
+@Injectable()
+export class VerificationTokenService {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async createEmailVerificationToken(email: string): Promise<string> {
+    const token = this.generateToken();
+    const expires = this.calculateExpiry(TOKEN_EXPIRY.EMAIL_VERIFICATION_HOURS);
+
+    await this.upsertToken(email, token, expires);
+
+    return token;
+  }
+
+  async createPasswordResetToken(email: string): Promise<string> {
+    const token = this.generateToken();
+    const expires = this.calculateExpiry(TOKEN_EXPIRY.PASSWORD_RESET_HOURS);
+    const identifier = `${RESET_TOKEN_PREFIX}${email}`;
+
+    await this.upsertToken(identifier, token, expires);
+
+    return token;
+  }
+
+  async validateEmailVerificationToken(token: string): Promise<string> {
+    const verificationToken = await this.findToken(token);
+
+    if (!verificationToken) {
+      throw new BadRequestException(ERROR_MESSAGES.INVALID_VERIFICATION_TOKEN);
+    }
+
+    this.validateExpiry(verificationToken.expires, token);
+
+    const email = verificationToken.identifier;
+    await this.deleteToken(token);
+
+    return email;
+  }
+
+  async validatePasswordResetToken(token: string): Promise<string> {
+    const verificationToken = await this.findToken(token);
+
+    if (!verificationToken?.identifier.startsWith(RESET_TOKEN_PREFIX)) {
+      throw new BadRequestException(ERROR_MESSAGES.INVALID_RESET_TOKEN);
+    }
+
+    this.validateExpiry(verificationToken.expires, token);
+
+    const email = verificationToken.identifier.replace(RESET_TOKEN_PREFIX, '');
+    await this.deleteToken(token);
+
+    return email;
+  }
+
+  private generateToken(): string {
+    return crypto.randomBytes(CRYPTO_CONSTANTS.TOKEN_BYTES).toString('hex');
+  }
+
+  private calculateExpiry(hours: number): Date {
+    return new Date(Date.now() + hours * TIME_MS.HOUR);
+  }
+
+  private async upsertToken(
+    identifier: string,
+    token: string,
+    expires: Date,
+  ): Promise<void> {
+    await this.prisma.verificationToken.upsert({
+      where: {
+        identifier_token: {
+          identifier,
+          token,
+        },
+      },
+      update: {
+        token,
+        expires,
+      },
+      create: {
+        identifier,
+        token,
+        expires,
+      },
+    });
+  }
+
+  private async findToken(token: string) {
+    return this.prisma.verificationToken.findUnique({
+      where: { token },
+    });
+  }
+
+  private async deleteToken(token: string): Promise<void> {
+    await this.prisma.verificationToken.delete({
+      where: { token },
+    });
+  }
+
+  private validateExpiry(expires: Date, token: string): void {
+    if (expires < new Date()) {
+      // Clean up expired token asynchronously
+      this.deleteToken(token).catch(() => {
+        // Ignore deletion errors
+      });
+      throw new BadRequestException(ERROR_MESSAGES.TOKEN_EXPIRED);
+    }
+  }
+}
diff --git a/src/auth/strategies/jwt.strategy.ts b/src/auth/strategies/jwt.strategy.ts
index a18adc0..ce33bd7 100644
--- a/src/auth/strategies/jwt.strategy.ts
+++ b/src/auth/strategies/jwt.strategy.ts
@@ -3,6 +3,7 @@ import { PassportStrategy } from '@nestjs/passport';
 import { ExtractJwt, Strategy } from 'passport-jwt';
 import { ConfigService } from '@nestjs/config';
 import { PrismaService } from '../../prisma/prisma.service';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
 
 export interface JwtPayload {
   sub: string;
@@ -41,7 +42,7 @@ export class JwtStrategy extends PassportStrategy(Strategy) {
     });
 
     if (!user) {
-      throw new UnauthorizedException('User not found');
+      throw new UnauthorizedException(ERROR_MESSAGES.USER_NOT_FOUND);
     }
 
     return {
diff --git a/src/auth/strategies/local.strategy.ts b/src/auth/strategies/local.strategy.ts
index f73a5ff..6830dbe 100644
--- a/src/auth/strategies/local.strategy.ts
+++ b/src/auth/strategies/local.strategy.ts
@@ -1,7 +1,11 @@
 import { Injectable, UnauthorizedException } from '@nestjs/common';
 import { PassportStrategy } from '@nestjs/passport';
 import { Strategy } from 'passport-local';
+import { User } from '@prisma/client';
 import { AuthService } from '../auth.service';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
+
+type ValidatedUser = Omit<User, 'password'>;
 
 @Injectable()
 export class LocalStrategy extends PassportStrategy(Strategy) {
@@ -12,10 +16,10 @@ export class LocalStrategy extends PassportStrategy(Strategy) {
     });
   }
 
-  async validate(email: string, password: string): Promise<any> {
+  async validate(email: string, password: string): Promise<ValidatedUser> {
     const user = await this.authService.validateUser(email, password);
     if (!user) {
-      throw new UnauthorizedException('Invalid credentials');
+      throw new UnauthorizedException(ERROR_MESSAGES.INVALID_CREDENTIALS);
     }
     return user;
   }
diff --git a/src/common/cache/cache-lock.service.ts b/src/common/cache/cache-lock.service.ts
new file mode 100644
index 0000000..a928642
--- /dev/null
+++ b/src/common/cache/cache-lock.service.ts
@@ -0,0 +1,84 @@
+/**
+ * Cache Lock Service
+ * Single Responsibility: Distributed locking operations
+ */
+
+import { Injectable } from '@nestjs/common';
+import { RedisConnectionService } from './redis-connection.service';
+import { AppLoggerService } from '../logger/logger.service';
+
+@Injectable()
+export class CacheLockService {
+  constructor(
+    private readonly redisConnection: RedisConnectionService,
+    private readonly logger: AppLoggerService,
+  ) {}
+
+  /**
+   * Acquire a distributed lock using SETNX
+   * Returns true if lock was acquired, false if already locked
+   */
+  async acquireLock(key: string, ttl: number): Promise<boolean> {
+    if (!this.redisConnection.isEnabled || !this.redisConnection.client) {
+      return true; // Allow operation if Redis is disabled
+    }
+
+    try {
+      const result = await this.redisConnection.client.set(
+        key,
+        Date.now().toString(),
+        'EX',
+        ttl,
+        'NX',
+      );
+      return result === 'OK';
+    } catch (error) {
+      this.logger.error(
+        `Failed to acquire lock: ${key}`,
+        error instanceof Error ? error.stack : undefined,
+        'CacheLockService',
+      );
+      return false;
+    }
+  }
+
+  /**
+   * Release a distributed lock
+   */
+  async releaseLock(key: string): Promise<void> {
+    if (!this.redisConnection.isEnabled || !this.redisConnection.client) {
+      return;
+    }
+
+    try {
+      await this.redisConnection.client.del(key);
+    } catch (error) {
+      this.logger.error(
+        `Failed to release lock: ${key}`,
+        error instanceof Error ? error.stack : undefined,
+        'CacheLockService',
+      );
+    }
+  }
+
+  /**
+   * Check if a lock exists
+   */
+  async isLocked(key: string): Promise<boolean> {
+    if (!this.redisConnection.isEnabled || !this.redisConnection.client) {
+      return false;
+    }
+
+    try {
+      const exists = await this.redisConnection.client.exists(key);
+      return exists === 1;
+    } catch (error) {
+      this.logger.error(
+        `Failed to check lock: ${key}`,
+        error instanceof Error ? error.stack : undefined,
+        'CacheLockService',
+      );
+      return false;
+    }
+  }
+}
diff --git a/src/common/cache/cache.module.ts b/src/common/cache/cache.module.ts
index 089e790..b756312 100644
--- a/src/common/cache/cache.module.ts
+++ b/src/common/cache/cache.module.ts
@@ -1,9 +1,20 @@
 import { Module, Global } from '@nestjs/common';
 import { CacheService } from './cache.service';
+import { RedisConnectionService } from './redis-connection.service';
+import { CacheLockService } from './cache-lock.service';
+import { CacheCoreService, CachePatternsService } from './services';
+import { LoggerModule } from '../logger/logger.module';
 
 @Global()
 @Module({
-  providers: [CacheService],
+  imports: [LoggerModule],
+  providers: [
+    RedisConnectionService,
+    CacheLockService,
+    CacheCoreService,
+    CachePatternsService,
+    CacheService,
+  ],
   exports: [CacheService],
 })
 export class CacheModule {}
diff --git a/src/common/cache/cache.service.spec.ts b/src/common/cache/cache.service.spec.ts
index 632a9cc..f7ed523 100644
--- a/src/common/cache/cache.service.spec.ts
+++ b/src/common/cache/cache.service.spec.ts
@@ -1,247 +1,192 @@
-/* eslint-disable @typescript-eslint/unbound-method */
-import { AppLoggerService } from '../logger/logger.service';
-
-// Create a mock Redis client that we can control
-const mockRedis = {
-  get: jest.fn(),
-  set: jest.fn(),
-  setex: jest.fn(),
-  del: jest.fn(),
-  keys: jest.fn(),
-  flushdb: jest.fn(),
-  exists: jest.fn(),
-  quit: jest.fn(),
-  on: jest.fn(),
-};
-
-// Mock ioredis before importing CacheService
-// Need to mock as default export for ES module compatibility
-jest.mock('ioredis', () => {
-  return {
-    default: jest.fn(() => mockRedis),
-    __esModule: true,
-  };
-});
-
-// Import after mock setup
+import { Test, TestingModule } from '@nestjs/testing';
 import { CacheService } from './cache.service';
+import { CacheCoreService } from './services/cache-core.service';
+import { CachePatternsService } from './services/cache-patterns.service';
+import { RedisConnectionService } from './redis-connection.service';
 
 describe('CacheService', () => {
-  let mockLogger: jest.Mocked<AppLoggerService>;
-  const originalEnv = process.env;
-
-  beforeEach(() => {
-    // Reset all mocks
-    jest.clearAllMocks();
-
-    // Reset mock implementations
-    mockRedis.get.mockReset();
-    mockRedis.set.mockReset();
-    mockRedis.setex.mockReset();
-    mockRedis.del.mockReset();
-    mockRedis.keys.mockReset();
-    mockRedis.flushdb.mockReset();
-    mockRedis.exists.mockReset();
-    mockRedis.quit.mockReset();
-    mockRedis.on.mockReset();
-
-    // Create fresh logger mock
-    mockLogger = {
-      log: jest.fn(),
-      error: jest.fn(),
-      warn: jest.fn(),
-      debug: jest.fn(),
-      verbose: jest.fn(),
-    } as unknown as jest.Mocked<AppLoggerService>;
-
-    // Reset process.env
-    jest.resetModules();
-    process.env = { ...originalEnv };
+  let service: CacheService;
+  let coreService: jest.Mocked<CacheCoreService>;
+  let patternsService: jest.Mocked<CachePatternsService>;
+  let redisConnection: jest.Mocked<RedisConnectionService>;
+
+  beforeEach(async () => {
+    const mockCoreService = {
+      get: jest.fn(),
+      set: jest.fn(),
+      delete: jest.fn(),
+      deletePattern: jest.fn(),
+      flush: jest.fn(),
+      isEnabled: true,
+    };
+
+    const mockPatternsService = {
+      acquireLock: jest.fn(),
+      releaseLock: jest.fn(),
+      isLocked: jest.fn(),
+      getOrSet: jest.fn(),
+    };
+
+    const mockRedisConnection = {
+      onModuleDestroy: jest.fn(),
+      client: null,
+    };
+
+    const module: TestingModule = await Test.createTestingModule({
+      providers: [
+        CacheService,
+        {
+          provide: CacheCoreService,
+          useValue: mockCoreService,
+        },
+        {
+          provide: CachePatternsService,
+          useValue: mockPatternsService,
+        },
+        {
+          provide: RedisConnectionService,
+          useValue: mockRedisConnection,
+        },
+      ],
+    }).compile();
+
+    service = module.get<CacheService>(CacheService);
+    coreService = module.get(CacheCoreService);
+    patternsService = module.get(CachePatternsService);
+    redisConnection = module.get(RedisConnectionService);
   });
 
-  afterAll(() => {
-    process.env = originalEnv;
+  afterEach(() => {
+    jest.clearAllMocks();
   });
 
   describe('when Redis is configured', () => {
-    let service: CacheService;
-
-    beforeEach(() => {
-      process.env.REDIS_HOST = 'localhost';
-      process.env.REDIS_PORT = '6379';
-      process.env.REDIS_PASSWORD = 'test-password';
-      service = new CacheService(mockLogger);
-    });
-
     it('should be enabled', () => {
       expect(service.isEnabled).toBe(true);
     });
 
-    it('should register event handlers on Redis client', () => {
-      expect(mockRedis.on).toHaveBeenCalledWith(
-        'connect',
-        expect.any(Function),
-      );
-      expect(mockRedis.on).toHaveBeenCalledWith('error', expect.any(Function));
-    });
-
     describe('get', () => {
       it('should return parsed value when key exists', async () => {
         const testData = { name: 'test', value: 123 };
-        mockRedis.get.mockResolvedValue(JSON.stringify(testData));
+        coreService.get.mockResolvedValue(testData);
 
         const result = await service.get<typeof testData>('test-key');
 
         expect(result).toEqual(testData);
-        expect(mockRedis.get).toHaveBeenCalledWith('test-key');
+        expect(coreService.get).toHaveBeenCalledWith('test-key');
       });
 
       it('should return null when key does not exist', async () => {
-        mockRedis.get.mockResolvedValue(null);
+        coreService.get.mockResolvedValue(null);
 
         const result = await service.get('non-existent-key');
 
         expect(result).toBeNull();
       });
-
-      it('should return null on error and log', async () => {
-        mockRedis.get.mockRejectedValue(new Error('Connection error'));
-
-        const result = await service.get('test-key');
-
-        expect(result).toBeNull();
-        expect(mockLogger.error).toHaveBeenCalled();
-      });
     });
 
     describe('set', () => {
       it('should set value without TTL', async () => {
-        mockRedis.set.mockResolvedValue('OK');
+        coreService.set.mockResolvedValue(undefined);
 
         await service.set('test-key', { data: 'value' });
 
-        expect(mockRedis.set).toHaveBeenCalledWith(
+        expect(coreService.set).toHaveBeenCalledWith(
           'test-key',
-          JSON.stringify({ data: 'value' }),
+          { data: 'value' },
+          undefined,
         );
       });
 
-      it('should set value with TTL using setex', async () => {
-        mockRedis.setex.mockResolvedValue('OK');
+      it('should set value with TTL', async () => {
+        coreService.set.mockResolvedValue(undefined);
 
         await service.set('test-key', { data: 'value' }, 300);
 
-        expect(mockRedis.setex).toHaveBeenCalledWith(
+        expect(coreService.set).toHaveBeenCalledWith(
           'test-key',
+          { data: 'value' },
           300,
-          JSON.stringify({ data: 'value' }),
         );
       });
-
-      it('should log error on failure', async () => {
-        mockRedis.set.mockRejectedValue(new Error('Set failed'));
-
-        await service.set('test-key', 'value');
-
-        expect(mockLogger.error).toHaveBeenCalled();
-      });
     });
 
     describe('delete', () => {
       it('should delete key', async () => {
-        mockRedis.del.mockResolvedValue(1);
+        coreService.delete.mockResolvedValue(undefined);
 
         await service.delete('test-key');
 
-        expect(mockRedis.del).toHaveBeenCalledWith('test-key');
-      });
-
-      it('should log error on failure', async () => {
-        mockRedis.del.mockRejectedValue(new Error('Delete failed'));
-
-        await service.delete('test-key');
-
-        expect(mockLogger.error).toHaveBeenCalled();
+        expect(coreService.delete).toHaveBeenCalledWith('test-key');
       });
     });
 
     describe('deletePattern', () => {
       it('should delete keys matching pattern', async () => {
-        mockRedis.keys.mockResolvedValue(['key1', 'key2', 'key3']);
-        mockRedis.del.mockResolvedValue(3);
-
-        await service.deletePattern('user:*');
-
-        expect(mockRedis.keys).toHaveBeenCalledWith('user:*');
-        expect(mockRedis.del).toHaveBeenCalledWith('key1', 'key2', 'key3');
-      });
-
-      it('should not call del when no keys match', async () => {
-        mockRedis.keys.mockResolvedValue([]);
+        coreService.deletePattern.mockResolvedValue(undefined);
 
         await service.deletePattern('user:*');
 
-        expect(mockRedis.keys).toHaveBeenCalledWith('user:*');
-        expect(mockRedis.del).not.toHaveBeenCalled();
+        expect(coreService.deletePattern).toHaveBeenCalledWith('user:*');
       });
     });
 
     describe('flush', () => {
       it('should flush database', async () => {
-        mockRedis.flushdb.mockResolvedValue('OK');
+        coreService.flush.mockResolvedValue(undefined);
 
         await service.flush();
 
-        expect(mockRedis.flushdb).toHaveBeenCalled();
+        expect(coreService.flush).toHaveBeenCalled();
       });
     });
 
     describe('acquireLock', () => {
       it('should acquire lock successfully', async () => {
-        mockRedis.set.mockResolvedValue('OK');
+        patternsService.acquireLock.mockResolvedValue(true);
 
         const result = await service.acquireLock('lock:resource', 60);
 
         expect(result).toBe(true);
-        expect(mockRedis.set).toHaveBeenCalledWith(
+        expect(patternsService.acquireLock).toHaveBeenCalledWith(
           'lock:resource',
-          expect.any(String),
-          'EX',
           60,
-          'NX',
         );
       });
 
       it('should return false when lock already exists', async () => {
-        mockRedis.set.mockResolvedValue(null);
+        patternsService.acquireLock.mockResolvedValue(false);
 
         const result = await service.acquireLock('lock:resource', 60);
 
         expect(result).toBe(false);
       });
+    });
 
-      it('should return false on error', async () => {
-        mockRedis.set.mockRejectedValue(new Error('Lock failed'));
+    describe('releaseLock', () => {
+      it('should release lock', async () => {
+        patternsService.releaseLock.mockResolvedValue(undefined);
 
-        const result = await service.acquireLock('lock:resource', 60);
+        await service.releaseLock('lock:resource');
 
-        expect(result).toBe(false);
-        expect(mockLogger.error).toHaveBeenCalled();
+        expect(patternsService.releaseLock).toHaveBeenCalledWith(
+          'lock:resource',
+        );
       });
     });
 
     describe('isLocked', () => {
       it('should return true when lock exists', async () => {
-        mockRedis.exists.mockResolvedValue(1);
+        patternsService.isLocked.mockResolvedValue(true);
 
         const result = await service.isLocked('lock:resource');
 
         expect(result).toBe(true);
-        expect(mockRedis.exists).toHaveBeenCalledWith('lock:resource');
+        expect(patternsService.isLocked).toHaveBeenCalledWith('lock:resource');
       });
 
       it('should return false when lock does not exist', async () => {
-        mockRedis.exists.mockResolvedValue(0);
+        patternsService.isLocked.mockResolvedValue(false);
 
         const result = await service.isLocked('lock:resource');
 
@@ -249,60 +194,123 @@ describe('CacheService', () => {
       });
     });
 
+    describe('getOrSet', () => {
+      it('should get or set value', async () => {
+        const computeFn = jest.fn().mockResolvedValue('computed-value');
+        patternsService.getOrSet.mockResolvedValue('computed-value');
+
+        const result = await service.getOrSet('test-key', computeFn, 60);
+
+        expect(result).toBe('computed-value');
+        expect(patternsService.getOrSet).toHaveBeenCalledWith(
+          'test-key',
+          computeFn,
+          60,
+        );
+      });
+    });
+
     describe('onModuleDestroy', () => {
       it('should close Redis connection', async () => {
-        mockRedis.quit.mockResolvedValue('OK');
+        redisConnection.onModuleDestroy.mockResolvedValue(undefined);
 
         await service.onModuleDestroy();
 
-        expect(mockRedis.quit).toHaveBeenCalled();
+        expect(redisConnection.onModuleDestroy).toHaveBeenCalled();
       });
     });
   });
 
   describe('when Redis is not configured', () => {
-    let service: CacheService;
-
-    beforeEach(() => {
-      // Ensure REDIS_HOST is not set
-      delete process.env.REDIS_HOST;
-      service = new CacheService(mockLogger);
+    let disabledService: CacheService;
+
+    beforeEach(async () => {
+      const mockCoreServiceDisabled = {
+        get: jest.fn(),
+        set: jest.fn(),
+        delete: jest.fn(),
+        deletePattern: jest.fn(),
+        flush: jest.fn(),
+        isEnabled: false,
+      };
+
+      const mockPatternsService = {
+        acquireLock: jest.fn(),
+        releaseLock: jest.fn(),
+        isLocked: jest.fn(),
+        getOrSet: jest.fn(),
+      };
+
+      const mockRedisConnection = {
+        onModuleDestroy: jest.fn(),
+        client: null,
+      };
+
+      const module: TestingModule = await Test.createTestingModule({
+        providers: [
+          CacheService,
+          {
+            provide: CacheCoreService,
+            useValue: mockCoreServiceDisabled,
+          },
+          {
+            provide: CachePatternsService,
+            useValue: mockPatternsService,
+          },
+          {
+            provide: RedisConnectionService,
+            useValue: mockRedisConnection,
+          },
+        ],
+      }).compile();
+
+      disabledService = module.get<CacheService>(CacheService);
     });
 
     it('should be disabled', () => {
-      expect(service.isEnabled).toBe(false);
-    });
-
-    it('should log warning on initialization', () => {
-      expect(mockLogger.warn).toHaveBeenCalledWith(
-        'Redis not configured - caching disabled',
-        'CacheService',
-      );
+      expect(disabledService.isEnabled).toBe(false);
     });
 
     it('should return null from get', async () => {
-      const result = await service.get('test-key');
+      const mockCoreServiceDisabled = {
+        get: jest.fn().mockResolvedValue(null),
+        set: jest.fn(),
+        delete: jest.fn(),
+        deletePattern: jest.fn(),
+        flush: jest.fn(),
+        isEnabled: false,
+      };
+
+      // Recreate service with disabled mock
+      const module: TestingModule = await Test.createTestingModule({
+        providers: [
+          CacheService,
+          {
+            provide: CacheCoreService,
+            useValue: mockCoreServiceDisabled,
+          },
+          {
+            provide: CachePatternsService,
+            useValue: {
+              acquireLock: jest.fn(),
+              releaseLock: jest.fn(),
+              isLocked: jest.fn(),
+              getOrSet: jest.fn(),
+            },
+          },
+          {
+            provide: RedisConnectionService,
+            useValue: {
+              onModuleDestroy: jest.fn(),
+              client: null,
+            },
+          },
+        ],
+      }).compile();
+
+      const testService = module.get<CacheService>(CacheService);
+      const result = await testService.get('test-key');
       expect(result).toBeNull();
     });
-
-    it('should do nothing on set', async () => {
-      await service.set('test-key', 'value');
-      expect(mockRedis.set).not.toHaveBeenCalled();
-    });
-
-    it('should do nothing on delete', async () => {
-      await service.delete('test-key');
-      expect(mockRedis.del).not.toHaveBeenCalled();
-    });
-
-    it('should return true for acquireLock (allow operation without coordination)', async () => {
-      const result = await service.acquireLock('lock:resource', 60);
-      expect(result).toBe(true);
-    });
-
-    it('should return false for isLocked', async () => {
-      const result = await service.isLocked('lock:resource');
-      expect(result).toBe(false);
-    });
   });
 });
diff --git a/src/common/cache/cache.service.ts b/src/common/cache/cache.service.ts
index 0feca9a..6cbb1cc 100644
--- a/src/common/cache/cache.service.ts
+++ b/src/common/cache/cache.service.ts
@@ -1,213 +1,70 @@
+/**
+ * Cache Service (Facade)
+ * Provides unified API for caching operations
+ * Delegates to specialized services for implementation
+ */
+
 import { Injectable, OnModuleDestroy } from '@nestjs/common';
-import Redis from 'ioredis';
-import { AppLoggerService } from '../logger/logger.service';
+import { RedisConnectionService } from './redis-connection.service';
+import { CacheCoreService } from './services/cache-core.service';
+import { CachePatternsService } from './services/cache-patterns.service';
 
 @Injectable()
 export class CacheService implements OnModuleDestroy {
-  private client: Redis | null = null;
-  private _isEnabled: boolean;
-
-  constructor(private readonly logger: AppLoggerService) {
-    const redisHost = process.env.REDIS_HOST;
-    const redisPort = parseInt(process.env.REDIS_PORT || '6379', 10);
-    const redisPassword = process.env.REDIS_PASSWORD;
-
-    this._isEnabled = !!redisHost;
-
-    if (this._isEnabled) {
-      try {
-        this.client = new Redis({
-          host: redisHost,
-          port: redisPort,
-          password: redisPassword,
-          retryStrategy: (times) => {
-            const delay = Math.min(times * 50, 2000);
-            return delay;
-          },
-          maxRetriesPerRequest: 3,
-        });
-
-        this.client.on('connect', () => {
-          this.logger.log('Redis connected successfully', 'CacheService');
-        });
-
-        this.client.on('error', (error) => {
-          this.logger.error(
-            'Redis connection error',
-            error.stack,
-            'CacheService',
-            { error: error.message },
-          );
-        });
-      } catch (error) {
-        this.logger.error(
-          'Failed to initialize Redis client',
-          error instanceof Error ? error.stack : undefined,
-          'CacheService',
-        );
-        this._isEnabled = false;
-      }
-    } else {
-      this.logger.warn(
-        'Redis not configured - caching disabled',
-        'CacheService',
-      );
-    }
-  }
+  constructor(
+    private readonly coreService: CacheCoreService,
+    private readonly patternsService: CachePatternsService,
+    private readonly redisConnection: RedisConnectionService,
+  ) {}
 
   async get<T>(key: string): Promise<T | null> {
-    if (!this._isEnabled || !this.client) {
-      return null;
-    }
-
-    try {
-      const value = await this.client.get(key);
-      return value ? (JSON.parse(value) as T) : null;
-    } catch (error) {
-      this.logger.error(
-        `Failed to get cache key: ${key}`,
-        error instanceof Error ? error.stack : undefined,
-        'CacheService',
-      );
-      return null;
-    }
+    return this.coreService.get<T>(key);
   }
 
   async set(key: string, value: unknown, ttl?: number): Promise<void> {
-    if (!this._isEnabled || !this.client) {
-      return;
-    }
-
-    try {
-      const serialized = JSON.stringify(value);
-      if (ttl) {
-        await this.client.setex(key, ttl, serialized);
-      } else {
-        await this.client.set(key, serialized);
-      }
-    } catch (error) {
-      this.logger.error(
-        `Failed to set cache key: ${key}`,
-        error instanceof Error ? error.stack : undefined,
-        'CacheService',
-      );
-    }
+    return this.coreService.set(key, value, ttl);
   }
 
   async delete(key: string): Promise<void> {
-    if (!this._isEnabled || !this.client) {
-      return;
-    }
-
-    try {
-      await this.client.del(key);
-    } catch (error) {
-      this.logger.error(
-        `Failed to delete cache key: ${key}`,
-        error instanceof Error ? error.stack : undefined,
-        'CacheService',
-      );
-    }
+    return this.coreService.delete(key);
   }
 
   async deletePattern(pattern: string): Promise<void> {
-    if (!this._isEnabled || !this.client) {
-      return;
-    }
-
-    try {
-      const keys = await this.client.keys(pattern);
-      if (keys.length > 0) {
-        await this.client.del(...keys);
-      }
-    } catch (error) {
-      this.logger.error(
-        `Failed to delete cache pattern: ${pattern}`,
-        error instanceof Error ? error.stack : undefined,
-        'CacheService',
-      );
-    }
+    return this.coreService.deletePattern(pattern);
   }
 
   async flush(): Promise<void> {
-    if (!this._isEnabled || !this.client) {
-      return;
-    }
-
-    try {
-      await this.client.flushdb();
-      this.logger.log('Cache flushed successfully', 'CacheService');
-    } catch (error) {
-      this.logger.error(
-        'Failed to flush cache',
-        error instanceof Error ? error.stack : undefined,
-        'CacheService',
-      );
-    }
+    return this.coreService.flush();
   }
 
-  /**
-   * Acquire a distributed lock using SETNX
-   * Returns true if lock was acquired, false if already locked
-   */
   async acquireLock(key: string, ttl: number): Promise<boolean> {
-    if (!this._isEnabled || !this.client) {
-      // If Redis is disabled, allow operation (no distributed coordination)
-      return true;
-    }
-
-    try {
-      const result = await this.client.set(key, Date.now().toString(), 'EX', ttl, 'NX');
-      return result === 'OK';
-    } catch (error) {
-      this.logger.error(
-        `Failed to acquire lock: ${key}`,
-        error instanceof Error ? error.stack : undefined,
-        'CacheService',
-      );
-      return false;
-    }
+    return this.patternsService.acquireLock(key, ttl);
   }
 
-  /**
-   * Release a distributed lock
-   */
   async releaseLock(key: string): Promise<void> {
-    await this.delete(key);
+    return this.patternsService.releaseLock(key);
   }
 
-  /**
-   * Check if a lock exists
-   */
   async isLocked(key: string): Promise<boolean> {
-    if (!this._isEnabled || !this.client) {
-      return false;
-    }
+    return this.patternsService.isLocked(key);
+  }
 
-    try {
-      const exists = await this.client.exists(key);
-      return exists === 1;
-    } catch (error) {
-      this.logger.error(
-        `Failed to check lock: ${key}`,
-        error instanceof Error ? error.stack : undefined,
-        'CacheService',
-      );
-      return false;
-    }
+  /**
+   * Cache-aside pattern helper
+   */
+  async getOrSet<T>(
+    key: string,
+    computeFn: () => Promise<T>,
+    ttl?: number,
+  ): Promise<T> {
+    return this.patternsService.getOrSet(key, computeFn, ttl);
   }
 
   async onModuleDestroy(): Promise<void> {
-    if (this.client) {
-      await this.client.quit();
-      this.logger.log('Redis connection closed', 'CacheService');
-    }
+    await this.redisConnection.onModuleDestroy();
   }
 
-  /**
-   * Check if Redis caching is enabled
-   */
   get isEnabled(): boolean {
-    return this._isEnabled;
+    return this.coreService.isEnabled;
   }
 }
diff --git a/src/common/cache/redis-connection.service.ts b/src/common/cache/redis-connection.service.ts
new file mode 100644
index 0000000..cdffd06
--- /dev/null
+++ b/src/common/cache/redis-connection.service.ts
@@ -0,0 +1,96 @@
+/**
+ * Redis Connection Manager
+ * Single Responsibility: Manage Redis client connection lifecycle
+ */
+
+import { Injectable, OnModuleDestroy } from '@nestjs/common';
+import Redis from 'ioredis';
+import { AppLoggerService } from '../logger/logger.service';
+
+const REDIS_DEFAULT_PORT = 6379;
+const RETRY_DELAY_MAX = 2000;
+const RETRY_DELAY_MULTIPLIER = 50;
+const MAX_RETRIES_PER_REQUEST = 3;
+
+@Injectable()
+export class RedisConnectionService implements OnModuleDestroy {
+  private _client: Redis | null = null;
+  private _isEnabled: boolean;
+
+  constructor(private readonly logger: AppLoggerService) {
+    const redisHost = process.env.REDIS_HOST;
+    const redisPort = parseInt(
+      process.env.REDIS_PORT ?? String(REDIS_DEFAULT_PORT),
+      10,
+    );
+    const redisPassword = process.env.REDIS_PASSWORD;
+
+    this._isEnabled = !!redisHost;
+
+    if (this._isEnabled && redisHost) {
+      this.initializeClient(redisHost, redisPort, redisPassword);
+    } else {
+      this.logger.warn(
+        'Redis not configured - caching disabled',
+        'RedisConnectionService',
+      );
+    }
+  }
+
+  private initializeClient(
+    host: string,
+    port: number,
+    password?: string,
+  ): void {
+    try {
+      this._client = new Redis({
+        host,
+        port,
+        password,
+        retryStrategy: (times) =>
+          Math.min(times * RETRY_DELAY_MULTIPLIER, RETRY_DELAY_MAX),
+        maxRetriesPerRequest: MAX_RETRIES_PER_REQUEST,
+      });
+
+      this._client.on('connect', () => {
+        this.logger.log(
+          'Redis connected successfully',
+          'RedisConnectionService',
+        );
+      });
+
+      this._client.on('error', (error) => {
+        this.logger.error(
+          'Redis connection error',
+          error.stack,
+          'RedisConnectionService',
+          {
+            error: error.message,
+          },
+        );
+      });
+    } catch (error) {
+      this.logger.error(
+        'Failed to initialize Redis client',
+        error instanceof Error ? error.stack : undefined,
+        'RedisConnectionService',
+      );
+      this._isEnabled = false;
+    }
+  }
+
+  async onModuleDestroy(): Promise<void> {
+    if (this._client) {
+      await this._client.quit();
+      this.logger.log('Redis connection closed', 'RedisConnectionService');
+    }
+  }
+
+  get client(): Redis | null {
+    return this._client;
+  }
+
+  get isEnabled(): boolean {
+    return this._isEnabled;
+  }
+}
diff --git a/src/common/cache/services/cache-core.service.ts b/src/common/cache/services/cache-core.service.ts
new file mode 100644
index 0000000..efaff4a
--- /dev/null
+++ b/src/common/cache/services/cache-core.service.ts
@@ -0,0 +1,122 @@
+/**
+ * Cache Core Service
+ * Handles basic cache operations (get, set, delete, flush)
+ */
+
+import { Injectable } from '@nestjs/common';
+import { RedisConnectionService } from '../redis-connection.service';
+import { AppLoggerService } from '../../logger/logger.service';
+
+@Injectable()
+export class CacheCoreService {
+  constructor(
+    private readonly redisConnection: RedisConnectionService,
+    private readonly logger: AppLoggerService,
+  ) {}
+
+  /**
+   * Get value from cache
+   */
+  async get<T>(key: string): Promise<T | null> {
+    if (!this.isEnabled) return null;
+
+    const client = this.redisConnection.client;
+    if (!client) return null;
+
+    try {
+      const value = await client.get(key);
+      return value ? (JSON.parse(value) as T) : null;
+    } catch (error) {
+      this.logError(`Failed to get cache key: ${key}`, error);
+      return null;
+    }
+  }
+
+  /**
+   * Set value in cache
+   */
+  async set(key: string, value: unknown, ttl?: number): Promise<void> {
+    if (!this.isEnabled) return;
+
+    const client = this.redisConnection.client;
+    if (!client) return;
+
+    try {
+      const serialized = JSON.stringify(value);
+      if (ttl) {
+        await client.setex(key, ttl, serialized);
+      } else {
+        await client.set(key, serialized);
+      }
+    } catch (error) {
+      this.logError(`Failed to set cache key: ${key}`, error);
+    }
+  }
+
+  /**
+   * Delete key from cache
+   */
+  async delete(key: string): Promise<void> {
+    if (!this.isEnabled) return;
+
+    const client = this.redisConnection.client;
+    if (!client) return;
+
+    try {
+      await client.del(key);
+    } catch (error) {
+      this.logError(`Failed to delete cache key: ${key}`, error);
+    }
+  }
+
+  /**
+   * Delete keys matching pattern
+   */
+  async deletePattern(pattern: string): Promise<void> {
+    if (!this.isEnabled) return;
+
+    const client = this.redisConnection.client;
+    if (!client) return;
+
+    try {
+      const keys = await client.keys(pattern);
+      if (keys.length > 0) {
+        await client.del(...keys);
+      }
+    } catch (error) {
+      this.logError(`Failed to delete cache pattern: ${pattern}`, error);
+    }
+  }
+
+  /**
+   * Flush all cache
+   */
+  async flush(): Promise<void> {
+    if (!this.isEnabled) return;
+
+    const client = this.redisConnection.client;
+    if (!client) return;
+
+    try {
+      await client.flushdb();
+      this.logger.log('Cache flushed successfully', 'CacheCoreService');
+    } catch (error) {
+      this.logError('Failed to flush cache', error);
+    }
+  }
+
+  /**
+   * Check if cache is enabled
+   */
+  get isEnabled(): boolean {
+    return this.redisConnection.isEnabled && !!this.redisConnection.client;
+  }
+
+  private logError(message: string, error: unknown): void {
+    this.logger.error(
+      message,
+      error instanceof Error ? error.stack : undefined,
+      'CacheCoreService',
+    );
+  }
+}
diff --git a/src/common/cache/services/cache-patterns.service.ts b/src/common/cache/services/cache-patterns.service.ts
new file mode 100644
index 0000000..d4f13f7
--- /dev/null
+++ b/src/common/cache/services/cache-patterns.service.ts
@@ -0,0 +1,62 @@
+/**
+ * Cache Patterns Service
+ * Implements common cache patterns (locks, cache-aside, etc.)
+ */
+
+import { Injectable } from '@nestjs/common';
+import { CacheLockService } from '../cache-lock.service';
+import { CacheCoreService } from './cache-core.service';
+
+@Injectable()
+export class CachePatternsService {
+  constructor(
+    private readonly lockService: CacheLockService,
+    private readonly coreService: CacheCoreService,
+  ) {}
+
+  /**
+   * Acquire distributed lock
+   */
+  async acquireLock(key: string, ttl: number): Promise<boolean> {
+    return this.lockService.acquireLock(key, ttl);
+  }
+
+  /**
+   * Release distributed lock
+   */
+  async releaseLock(key: string): Promise<void> {
+    return this.lockService.releaseLock(key);
+  }
+
+  /**
+   * Check if lock is held
+   */
+  async isLocked(key: string): Promise<boolean> {
+    return this.lockService.isLocked(key);
+  }
+
+  /**
+   * Cache-aside pattern: get from cache or compute and cache
+   */
+  async getOrSet<T>(
+    key: string,
+    computeFn: () => Promise<T>,
+    ttl?: number,
+  ): Promise<T> {
+    const cached = await this.coreService.get<T>(key);
+    if (cached !== null) {
+      return cached;
+    }
+
+    const value = await computeFn();
+    await this.coreService.set(key, value, ttl);
+    return value;
+  }
+
+  /**
+   * Invalidate cache and related patterns
+   */
+  async invalidatePattern(pattern: string): Promise<void> {
+    return this.coreService.deletePattern(pattern);
+  }
+}
diff --git a/src/common/cache/services/index.ts b/src/common/cache/services/index.ts
new file mode 100644
index 0000000..94f8a68
--- /dev/null
+++ b/src/common/cache/services/index.ts
@@ -0,0 +1,6 @@
+/**
+ * Cache Services - Barrel Export
+ */
+
+export { CacheCoreService } from './cache-core.service';
+export { CachePatternsService } from './cache-patterns.service';
diff --git a/src/common/config/env-auth.validation.ts b/src/common/config/env-auth.validation.ts
new file mode 100644
index 0000000..7fd573d
--- /dev/null
+++ b/src/common/config/env-auth.validation.ts
@@ -0,0 +1,14 @@
+import { IsNotEmpty, IsOptional, IsString } from 'class-validator';
+
+/**
+ * Authentication Environment Variables
+ */
+export class AuthEnvironmentVariables {
+  @IsNotEmpty()
+  @IsString()
+  JWT_SECRET: string;
+
+  @IsOptional()
+  @IsString()
+  JWT_EXPIRATION?: string;
+}
diff --git a/src/common/config/env-database.validation.ts b/src/common/config/env-database.validation.ts
new file mode 100644
index 0000000..98cb2af
--- /dev/null
+++ b/src/common/config/env-database.validation.ts
@@ -0,0 +1,10 @@
+import { IsNotEmpty, IsString } from 'class-validator';
+
+/**
+ * Database Environment Variables
+ */
+export class DatabaseEnvironmentVariables {
+  @IsNotEmpty()
+  @IsString()
+  DATABASE_URL: string;
+}
diff --git a/src/common/config/env-services.validation.ts b/src/common/config/env-services.validation.ts
new file mode 100644
index 0000000..e3b3bb6
--- /dev/null
+++ b/src/common/config/env-services.validation.ts
@@ -0,0 +1,86 @@
+import {
+  IsEnum,
+  IsNumber,
+  IsOptional,
+  IsString,
+  IsUrl,
+  Min,
+  Max,
+} from 'class-validator';
+
+enum Environment {
+  Development = 'development',
+  Production = 'production',
+  Test = 'test',
+}
+
+/**
+ * Services Environment Variables
+ * Includes: Redis, MinIO, Email, Frontend, Logging, and App config
+ */
+export class ServicesEnvironmentVariables {
+  @IsEnum(Environment)
+  @IsOptional()
+  NODE_ENV: Environment = Environment.Development;
+
+  @IsNumber()
+  @Min(1000)
+  @Max(65535)
+  @IsOptional()
+  PORT: number = 3001;
+
+  // Redis
+  @IsOptional()
+  @IsString()
+  REDIS_HOST?: string;
+
+  @IsOptional()
+  @IsNumber()
+  REDIS_PORT?: number;
+
+  @IsOptional()
+  @IsString()
+  REDIS_PASSWORD?: string;
+
+  // MinIO
+  @IsOptional()
+  @IsString()
+  MINIO_ENDPOINT?: string;
+
+  @IsOptional()
+  @IsString()
+  MINIO_ACCESS_KEY?: string;
+
+  @IsOptional()
+  @IsString()
+  MINIO_SECRET_KEY?: string;
+
+  @IsOptional()
+  @IsString()
+  MINIO_BUCKET?: string;
+
+  // Email (SendGrid)
+  @IsOptional()
+  @IsString()
+  SENDGRID_API_KEY?: string;
+
+  @IsOptional()
+  @IsString()
+  EMAIL_FROM?: string;
+
+  @IsOptional()
+  @IsString()
+  EMAIL_FROM_NAME?: string;
+
+  // Frontend
+  @IsOptional()
+  @IsUrl({ require_tld: false })
+  FRONTEND_URL?: string;
+
+  // Logging
+  @IsOptional()
+  @IsString()
+  LOG_LEVEL?: string;
+}
+
+export { Environment };
diff --git a/src/common/config/env.validation.ts b/src/common/config/env.validation.ts
index b151ae5..db70624 100644
--- a/src/common/config/env.validation.ts
+++ b/src/common/config/env.validation.ts
@@ -1,94 +1,59 @@
 import { plainToInstance } from 'class-transformer';
+import { validateSync } from 'class-validator';
+import { DatabaseEnvironmentVariables } from './env-database.validation';
+import { AuthEnvironmentVariables } from './env-auth.validation';
 import {
-  IsEnum,
-  IsNotEmpty,
-  IsNumber,
-  IsOptional,
-  IsString,
-  IsUrl,
-  Min,
-  Max,
-  validateSync,
-} from 'class-validator';
-
-enum Environment {
-  Development = 'development',
-  Production = 'production',
-  Test = 'test',
-}
-
-class EnvironmentVariables {
-  @IsEnum(Environment)
-  @IsOptional()
+  ServicesEnvironmentVariables,
+  Environment,
+} from './env-services.validation';
+
+/**
+ * Combined Environment Variables
+ * Merges all environment variable classes
+ */
+export class EnvironmentVariables
+  implements
+    DatabaseEnvironmentVariables,
+    AuthEnvironmentVariables,
+    ServicesEnvironmentVariables
+{
+  // App config
   NODE_ENV: Environment = Environment.Development;
-
-  @IsNumber()
-  @Min(1000)
-  @Max(65535)
-  @IsOptional()
   PORT: number = 3001;
 
-  @IsNotEmpty()
-  @IsString()
+  // Database
   DATABASE_URL: string;
 
-  @IsNotEmpty()
-  @IsString()
+  // Auth
   JWT_SECRET: string;
-
-  @IsOptional()
-  @IsString()
   JWT_EXPIRATION?: string;
 
-  @IsOptional()
-  @IsString()
+  // Redis
   REDIS_HOST?: string;
-
-  @IsOptional()
-  @IsNumber()
   REDIS_PORT?: number;
-
-  @IsOptional()
-  @IsString()
   REDIS_PASSWORD?: string;
 
-  @IsOptional()
-  @IsString()
+  // MinIO
   MINIO_ENDPOINT?: string;
-
-  @IsOptional()
-  @IsString()
   MINIO_ACCESS_KEY?: string;
-
-  @IsOptional()
-  @IsString()
   MINIO_SECRET_KEY?: string;
-
-  @IsOptional()
-  @IsString()
   MINIO_BUCKET?: string;
 
-  @IsOptional()
-  @IsUrl({ require_tld: false })
-  FRONTEND_URL?: string;
-
-  @IsOptional()
-  @IsString()
-  LOG_LEVEL?: string;
-
-  @IsOptional()
-  @IsString()
+  // Email
   SENDGRID_API_KEY?: string;
-
-  @IsOptional()
-  @IsString()
   EMAIL_FROM?: string;
-
-  @IsOptional()
-  @IsString()
   EMAIL_FROM_NAME?: string;
+
+  // Frontend
+  FRONTEND_URL?: string;
+
+  // Logging
+  LOG_LEVEL?: string;
 }
 
+/**
+ * Validates environment variables
+ */
 export function validate(
   config: Record<string, unknown>,
 ): EnvironmentVariables {
@@ -115,3 +80,8 @@ export function validate(
 
   return validatedConfig;
 }
+
+// Re-export for convenience
+export { DatabaseEnvironmentVariables };
+export { AuthEnvironmentVariables };
+export { ServicesEnvironmentVariables, Environment };
diff --git a/src/common/config/security.config.ts b/src/common/config/security.config.ts
new file mode 100644
index 0000000..d3781c2
--- /dev/null
+++ b/src/common/config/security.config.ts
@@ -0,0 +1,47 @@
+import { INestApplication } from '@nestjs/common';
+import helmet from 'helmet';
+
+/**
+ * Security configuration - Helmet setup
+ * Single Responsibility: Configure security headers only
+ */
+export function configureSecurityHeaders(
+  app: INestApplication,
+  enableSwagger: boolean,
+): void {
+  app.use(
+    helmet({
+      contentSecurityPolicy: enableSwagger
+        ? {
+            directives: {
+              defaultSrc: ["'self'"],
+              scriptSrc: [
+                "'self'",
+                "'unsafe-inline'",
+                "'unsafe-eval'",
+                'https://cdn.jsdelivr.net',
+              ],
+              styleSrc: ["'self'", "'unsafe-inline'", 'https:'],
+              fontSrc: ["'self'", 'https:', 'data:'],
+              imgSrc: ["'self'", 'data:', 'https:'],
+              connectSrc: ["'self'", 'https:'],
+              workerSrc: ["'self'", 'blob:'],
+            },
+          }
+        : undefined,
+    }),
+  );
+}
+
+/**
+ * CORS configuration
+ * Single Responsibility: Configure CORS only
+ */
+export function configureCors(app: INestApplication): void {
+  app.enableCors({
+    origin: process.env.FRONTEND_URL ?? 'http://localhost:3000',
+    credentials: true,
+    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
+    allowedHeaders: ['Content-Type', 'Authorization', 'Accept'],
+  });
+}
diff --git a/src/common/config/swagger.config.ts b/src/common/config/swagger.config.ts
new file mode 100644
index 0000000..6ba8205
--- /dev/null
+++ b/src/common/config/swagger.config.ts
@@ -0,0 +1,197 @@
+import { INestApplication } from '@nestjs/common';
+import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
+import { apiReference } from '@scalar/nestjs-api-reference';
+
+/**
+ * Check if Swagger documentation should be enabled
+ */
+export function isSwaggerEnabled(): boolean {
+  return (
+    process.env.ENABLE_SWAGGER === 'true' ||
+    (process.env.ENABLE_SWAGGER !== 'false' &&
+      process.env.NODE_ENV !== 'production')
+  );
+}
+
+/**
+ * Swagger documentation configuration
+ * Single Responsibility: Configure API documentation only
+ */
+export function configureSwagger(app: INestApplication): void {
+  const config = buildSwaggerConfig();
+  const document = SwaggerModule.createDocument(app, config, {
+    operationIdFactory: (controllerKey: string, methodKey: string) =>
+      `${controllerKey}_${methodKey}`,
+  });
+
+  app.use(
+    '/api/docs',
+    apiReference({
+      spec: { content: document },
+      theme: 'purple',
+      darkMode: true,
+      metaData: { title: 'ProFile API Documentation' },
+      customCss: SCALAR_CUSTOM_CSS,
+    }),
+  );
+}
+
+function buildSwaggerConfig() {
+  return new DocumentBuilder()
+    .setTitle('ProFile API')
+    .setDescription(API_DESCRIPTION)
+    .setVersion('1.0.0')
+    .setContact(
+      'ProFile Team',
+      'https://github.com/your-org/profile',
+      'support@profile.app',
+    )
+    .setLicense('MIT', 'https://opensource.org/licenses/MIT')
+    .addServer(
+      `http://localhost:${process.env.PORT ?? 3001}`,
+      'Development Server',
+    )
+    .addBearerAuth(
+      {
+        type: 'http',
+        scheme: 'bearer',
+        bearerFormat: 'JWT',
+        name: 'Authorization',
+        description: 'Enter your JWT token obtained from /api/auth/login',
+        in: 'header',
+      },
+      'JWT-auth',
+    )
+    .addTag(
+      'auth',
+      'Authentication endpoints - Login, Signup, Password Reset, Email Verification',
+    )
+    .addTag(
+      'users',
+      'User profile management - View and update user information',
+    )
+    .addTag(
+      'onboarding',
+      'User onboarding flow - Complete profile setup for new users',
+    )
+    .addTag(
+      'resumes',
+      'Resume CRUD operations - Create, read, update, and delete resumes with all sections',
+    )
+    .addTag(
+      'upload',
+      'File upload endpoints - Upload profile pictures and attachments',
+    )
+    .addTag('export', 'Export resumes - Generate PDF and DOCX documents')
+    .addTag('github', 'GitHub integration - Import projects and contributions')
+    .build();
+}
+
+const API_DESCRIPTION = `
+## ProFile - Resume & Portfolio Management API
+
+ProFile is a comprehensive platform for creating, managing, and exporting professional resumes and portfolios.
+
+### Features
+- **Authentication**: JWT-based authentication with email verification and password reset
+- **Resume Management**: Full CRUD operations for resumes with multiple sections
+- **Rich Content Sections**: Education, Experience, Skills, Projects, Certifications, and more
+- **Export Options**: Generate PDF and DOCX documents from resumes
+- **File Upload**: Upload profile pictures and attachments via S3-compatible storage
+- **User Onboarding**: Guided onboarding flow for new users
+
+### Authentication
+All protected endpoints require a valid JWT token in the Authorization header:
+\`\`\`
+Authorization: Bearer <your-jwt-token>
+\`\`\`
+
+### Rate Limiting
+- Authentication endpoints: 5 requests per minute
+- General API: 100 requests per minute
+
+### Error Responses
+All errors follow a consistent format:
+\`\`\`json
+{
+  "statusCode": 400,
+  "message": "Error description",
+  "error": "Bad Request"
+}
+\`\`\`
+`.trim();
+
+const SCALAR_CUSTOM_CSS = `
+/* ProFile Dark Purple Theme */
+:root {
+  --scalar-background-1: #1a1625 !important;
+  --scalar-background-2: #252033 !important;
+  --scalar-background-3: #3d2e5c !important;
+  --scalar-background-accent: #7c3aed !important;
+
+  --scalar-color-1: #e9d5ff !important;
+  --scalar-color-2: #c9b3ff !important;
+  --scalar-color-3: #a89dc4 !important;
+  --scalar-color-accent: #a78bfa !important;
+
+  --scalar-border-color: #4c3a6e !important;
+
+  --scalar-color-green: #8b5cf6 !important;
+  --scalar-color-blue: #a855f7 !important;
+  --scalar-color-orange: #c084fc !important;
+  --scalar-color-red: #ef4444 !important;
+
+  --scalar-button-1: #7c3aed !important;
+  --scalar-button-1-hover: #6d28d9 !important;
+  --scalar-button-1-color: #ffffff !important;
+}
+
+/* Sidebar */
+.sidebar { background: #1a1625 !important; border-right: 1px solid #4c3a6e !important; }
+.sidebar-search { background: #252033 !important; border: 1px solid #4c3a6e !important; }
+.sidebar-search input { color: #e9d5ff !important; }
+.sidebar-search input::placeholder { color: #8b7aa8 !important; }
+
+/* Sidebar items */
+[class*="sidebar"] a, [class*="sidebar"] button { color: #c9b3ff !important; }
+[class*="sidebar"] a:hover, [class*="sidebar"] button:hover { background: #252033 !important; }
+
+/* Method badges */
+.scalar-api-reference [data-method="get"] {
+  background: #8b5cf6 !important;
+  color: #fff !important;
+}
+.scalar-api-reference [data-method="post"] {
+  background: #a855f7 !important;
+  color: #fff !important;
+}
+.scalar-api-reference [data-method="put"],
+.scalar-api-reference [data-method="patch"] {
+  background: #c084fc !important;
+  color: #fff !important;
+}
+.scalar-api-reference [data-method="delete"] {
+  background: #ef4444 !important;
+  color: #fff !important;
+}
+
+/* Content area */
+.scalar-api-reference { background: #1a1625 !important; }
+.scalar-card { background: #252033 !important; border-color: #4c3a6e !important; }
+
+/* Code blocks */
+pre, code { background: #1e1a2e !important; }
+
+/* Inputs */
+input, textarea, select {
+  background: #252033 !important;
+  border-color: #4c3a6e !important;
+  color: #e9d5ff !important;
+}
+
+/* Scrollbar */
+::-webkit-scrollbar { width: 8px; height: 8px; }
+::-webkit-scrollbar-track { background: #1a1625; }
+::-webkit-scrollbar-thumb { background: #4c3a6e; border-radius: 4px; }
+::-webkit-scrollbar-thumb:hover { background: #6d28d9; }
+`;
diff --git a/src/common/config/swagger/api-description.ts b/src/common/config/swagger/api-description.ts
new file mode 100644
index 0000000..a7f14d1
--- /dev/null
+++ b/src/common/config/swagger/api-description.ts
@@ -0,0 +1,38 @@
+/**
+ * API Description for Swagger Documentation
+ * Single Responsibility: API description text only
+ */
+
+export const API_DESCRIPTION = `
+## ProFile - Resume & Portfolio Management API
+
+ProFile is a comprehensive platform for creating, managing, and exporting professional resumes and portfolios.
+
+### Features
+- **Authentication**: JWT-based authentication with email verification and password reset
+- **Resume Management**: Full CRUD operations for resumes with multiple sections
+- **Rich Content Sections**: Education, Experience, Skills, Projects, Certifications, and more
+- **Export Options**: Generate PDF and DOCX documents from resumes
+- **File Upload**: Upload profile pictures and attachments via S3-compatible storage
+- **User Onboarding**: Guided onboarding flow for new users
+
+### Authentication
+All protected endpoints require a valid JWT token in the Authorization header:
+\`\`\`
+Authorization: Bearer <your-jwt-token>
+\`\`\`
+
+### Rate Limiting
+- Authentication endpoints: 5 requests per minute
+- General API: 100 requests per minute
+
+### Error Responses
+All errors follow a consistent format:
+\`\`\`json
+{
+  "statusCode": 400,
+  "message": "Error description",
+  "error": "Bad Request"
+}
+\`\`\`
+`.trim();
diff --git a/src/common/config/swagger/index.ts b/src/common/config/swagger/index.ts
new file mode 100644
index 0000000..13ae222
--- /dev/null
+++ b/src/common/config/swagger/index.ts
@@ -0,0 +1,6 @@
+/**
+ * Swagger Config Barrel Export
+ */
+
+export { API_DESCRIPTION } from './api-description';
+export { SCALAR_CUSTOM_CSS } from './scalar-theme';
diff --git a/src/common/config/swagger/scalar-theme.ts b/src/common/config/swagger/scalar-theme.ts
new file mode 100644
index 0000000..82135a8
--- /dev/null
+++ b/src/common/config/swagger/scalar-theme.ts
@@ -0,0 +1,79 @@
+/**
+ * Scalar Custom CSS for Swagger Documentation
+ * Single Responsibility: Custom theme styling only
+ */
+
+export const SCALAR_CUSTOM_CSS = `
+/* ProFile Dark Purple Theme */
+:root {
+  --scalar-background-1: #1a1625 !important;
+  --scalar-background-2: #252033 !important;
+  --scalar-background-3: #3d2e5c !important;
+  --scalar-background-accent: #7c3aed !important;
+
+  --scalar-color-1: #e9d5ff !important;
+  --scalar-color-2: #c9b3ff !important;
+  --scalar-color-3: #a89dc4 !important;
+  --scalar-color-accent: #a78bfa !important;
+
+  --scalar-border-color: #4c3a6e !important;
+
+  --scalar-color-green: #8b5cf6 !important;
+  --scalar-color-blue: #a855f7 !important;
+  --scalar-color-orange: #c084fc !important;
+  --scalar-color-red: #ef4444 !important;
+
+  --scalar-button-1: #7c3aed !important;
+  --scalar-button-1-hover: #6d28d9 !important;
+  --scalar-button-1-color: #ffffff !important;
+}
+
+/* Sidebar */
+.sidebar { background: #1a1625 !important; border-right: 1px solid #4c3a6e !important; }
+.sidebar-search { background: #252033 !important; border: 1px solid #4c3a6e !important; }
+.sidebar-search input { color: #e9d5ff !important; }
+.sidebar-search input::placeholder { color: #8b7aa8 !important; }
+
+/* Sidebar items */
+[class*="sidebar"] a, [class*="sidebar"] button { color: #c9b3ff !important; }
+[class*="sidebar"] a:hover, [class*="sidebar"] button:hover { background: #252033 !important; }
+
+/* Method badges */
+.scalar-api-reference [data-method="get"] {
+  background: #8b5cf6 !important;
+  color: #fff !important;
+}
+.scalar-api-reference [data-method="post"] {
+  background: #a855f7 !important;
+  color: #fff !important;
+}
+.scalar-api-reference [data-method="put"],
+.scalar-api-reference [data-method="patch"] {
+  background: #c084fc !important;
+  color: #fff !important;
+}
+.scalar-api-reference [data-method="delete"] {
+  background: #ef4444 !important;
+  color: #fff !important;
+}
+
+/* Content area */
+.scalar-api-reference { background: #1a1625 !important; }
+.scalar-card { background: #252033 !important; border-color: #4c3a6e !important; }
+
+/* Code blocks */
+pre, code { background: #1e1a2e !important; }
+
+/* Inputs */
+input, textarea, select {
+  background: #252033 !important;
+  border-color: #4c3a6e !important;
+  color: #e9d5ff !important;
+}
+
+/* Scrollbar */
+::-webkit-scrollbar { width: 8px; height: 8px; }
+::-webkit-scrollbar-track { background: #1a1625; }
+::-webkit-scrollbar-thumb { background: #4c3a6e; border-radius: 4px; }
+::-webkit-scrollbar-thumb:hover { background: #6d28d9; }
+`;
diff --git a/src/common/config/validation.config.ts b/src/common/config/validation.config.ts
new file mode 100644
index 0000000..1852cb4
--- /dev/null
+++ b/src/common/config/validation.config.ts
@@ -0,0 +1,42 @@
+import { INestApplication, ValidationPipe } from '@nestjs/common';
+import { Reflector } from '@nestjs/core';
+import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
+import { AllExceptionsFilter } from '../filters/http-exception.filter';
+import { AppLoggerService } from '../logger/logger.service';
+
+/**
+ * Global validation pipe configuration
+ * Single Responsibility: Configure request validation only
+ */
+export function configureValidation(app: INestApplication): void {
+  app.useGlobalPipes(
+    new ValidationPipe({
+      whitelist: true,
+      forbidNonWhitelisted: false,
+      transform: true,
+      transformOptions: {
+        enableImplicitConversion: true,
+      },
+    }),
+  );
+}
+
+/**
+ * Global exception filter configuration
+ * Single Responsibility: Configure error handling only
+ */
+export function configureExceptionHandling(
+  app: INestApplication,
+  logger: AppLoggerService,
+): void {
+  app.useGlobalFilters(new AllExceptionsFilter(logger));
+}
+
+/**
+ * Global guards configuration
+ * Single Responsibility: Configure authentication guards only
+ */
+export function configureGlobalGuards(app: INestApplication): void {
+  const reflector = app.get(Reflector);
+  app.useGlobalGuards(new JwtAuthGuard(reflector));
+}
diff --git a/src/common/constants/app.constants.ts b/src/common/constants/app.constants.ts
index ca11d34..c6abfef 100644
--- a/src/common/constants/app.constants.ts
+++ b/src/common/constants/app.constants.ts
@@ -1,71 +1,55 @@
+/**
+ * Application Constants - Re-export for backward compatibility
+ *
+ * This file has been refactored. All constants are now split into
+ * smaller files under ./config/ directory.
+ *
+ * @see ./config/index.ts for the new structure
+ * @deprecated Import directly from './config' instead
+ */
+
+import {
+  APP_CONFIG,
+  RATE_LIMIT_CONFIG,
+  FILE_UPLOAD_CONFIG,
+  EXPORT_CONFIG,
+  CACHE_CONFIG,
+  CRYPTO_CONSTANTS,
+  API_LIMITS,
+  TIME_MS,
+  TOKEN_EXPIRY,
+  ERROR_MESSAGES,
+  SUCCESS_MESSAGES,
+} from './config';
+
+// Re-export everything
+export {
+  CRYPTO_CONSTANTS,
+  API_LIMITS,
+  TIME_MS,
+  TOKEN_EXPIRY,
+  ERROR_MESSAGES,
+  SUCCESS_MESSAGES,
+};
+
+// Legacy APP_CONSTANTS for backward compatibility
 export const APP_CONSTANTS = {
-  // Authentication
-  JWT_EXPIRATION: '7d',
-  BCRYPT_ROUNDS: 12,
-
-  // Rate Limiting
-  RATE_LIMIT_TTL: 60, // seconds
-  RATE_LIMIT_MAX_REQUESTS: 100,
-  AUTH_RATE_LIMIT_MAX_REQUESTS: 5,
-
-  // Pagination
-  DEFAULT_PAGE_SIZE: 20,
-  MAX_PAGE_SIZE: 100,
-
-  // File Upload
-  MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB
-  ALLOWED_IMAGE_TYPES: ['image/jpeg', 'image/png', 'image/webp'],
-
-  // Export
-  PUPPETEER_TIMEOUT: 30000, // 30 seconds
-  PDF_MAX_PAGES: 10,
-
-  // Cache TTL (in seconds)
-  CACHE_TTL_SHORT: 300, // 5 minutes
-  CACHE_TTL_MEDIUM: 1800, // 30 minutes
-  CACHE_TTL_LONG: 3600, // 1 hour
-
-  // Onboarding
-  ONBOARDING_MAX_RETRY_ATTEMPTS: 3,
-} as const;
-
-export const ERROR_MESSAGES = {
-  // Auth
-  INVALID_CREDENTIALS: 'Invalid email or password',
-  EMAIL_ALREADY_EXISTS: 'Email already registered',
-  USER_NOT_FOUND: 'User not found',
-  UNAUTHORIZED: 'Unauthorized access',
-
-  // Validation
-  INVALID_EMAIL: 'Invalid email format',
-  INVALID_PASSWORD: 'Password must be at least 8 characters',
-  INVALID_DATE: 'Invalid date format',
-
-  // Resources
-  RESUME_NOT_FOUND: 'Resume not found',
-  RESOURCE_NOT_FOUND: 'Resource not found',
-  ACCESS_DENIED: 'Access denied to this resource',
-
-  // Export
-  EXPORT_FAILED: 'Failed to export document',
-  INVALID_EXPORT_FORMAT: 'Invalid export format',
-
-  // Server
-  INTERNAL_SERVER_ERROR: 'Internal server error',
-  SERVICE_UNAVAILABLE: 'Service temporarily unavailable',
-} as const;
-
-export const SUCCESS_MESSAGES = {
-  // Auth
-  USER_REGISTERED: 'User registered successfully',
-  LOGIN_SUCCESS: 'Login successful',
-  LOGOUT_SUCCESS: 'Logout successful',
-
-  // Resources
-  CREATED: 'Resource created successfully',
-  UPDATED: 'Resource updated successfully',
-  DELETED: 'Resource deleted successfully',
-
-  // Onboarding
-  ONBOARDING_COMPLETED: 'Onboarding completed successfully',
+  JWT_EXPIRATION: APP_CONFIG.JWT_EXPIRATION,
+  BCRYPT_ROUNDS: APP_CONFIG.BCRYPT_ROUNDS,
+  RATE_LIMIT_TTL: RATE_LIMIT_CONFIG.TTL,
+  RATE_LIMIT_MAX_REQUESTS: RATE_LIMIT_CONFIG.MAX_REQUESTS,
+  AUTH_RATE_LIMIT_MAX_REQUESTS: RATE_LIMIT_CONFIG.AUTH_MAX_REQUESTS,
+  DEFAULT_PAGE_SIZE: APP_CONFIG.DEFAULT_PAGE_SIZE,
+  MAX_PAGE_SIZE: APP_CONFIG.MAX_PAGE_SIZE,
+  SEARCH_DEFAULT_LIMIT: APP_CONFIG.SEARCH_DEFAULT_LIMIT,
+  SEARCH_AUTOCOMPLETE_LIMIT: APP_CONFIG.SEARCH_AUTOCOMPLETE_LIMIT,
+  SEARCH_MAX_RESULTS: APP_CONFIG.SEARCH_MAX_RESULTS,
+  MAX_FILE_SIZE: FILE_UPLOAD_CONFIG.MAX_SIZE,
+  ALLOWED_IMAGE_TYPES: FILE_UPLOAD_CONFIG.ALLOWED_IMAGE_TYPES,
+  PUPPETEER_TIMEOUT: EXPORT_CONFIG.PUPPETEER_TIMEOUT,
+  PDF_MAX_PAGES: EXPORT_CONFIG.PDF_MAX_PAGES,
+  CACHE_TTL_SHORT: CACHE_CONFIG.TTL_SHORT,
+  CACHE_TTL_MEDIUM: CACHE_CONFIG.TTL_MEDIUM,
+  CACHE_TTL_LONG: CACHE_CONFIG.TTL_LONG,
+  ONBOARDING_MAX_RETRY_ATTEMPTS: APP_CONFIG.ONBOARDING_MAX_RETRY_ATTEMPTS,
 } as const;
diff --git a/src/common/constants/config/api-limits.const.ts b/src/common/constants/config/api-limits.const.ts
new file mode 100644
index 0000000..14e63b4
--- /dev/null
+++ b/src/common/constants/config/api-limits.const.ts
@@ -0,0 +1,13 @@
+/**
+ * API Limits Constants
+ *
+ * Limits for various API operations to prevent abuse
+ * and ensure consistent behavior.
+ */
+export const API_LIMITS = {
+  MAX_REPOS_TO_PROCESS: 20,
+  MAX_CONTRIBUTIONS_TO_SHOW: 10,
+  MAX_SUGGESTIONS: 8,
+  MAX_DEBUG_CHARS: 1000,
+  MAX_PREVIEW_CHARS: 100,
+} as const;
diff --git a/src/common/constants/config/app-config.const.ts b/src/common/constants/config/app-config.const.ts
new file mode 100644
index 0000000..970ab3b
--- /dev/null
+++ b/src/common/constants/config/app-config.const.ts
@@ -0,0 +1,37 @@
+/**
+ * Application Configuration Constants
+ *
+ * Core configuration values for the application.
+ */
+export const APP_CONFIG = {
+  JWT_EXPIRATION: '7d',
+  BCRYPT_ROUNDS: 12,
+  DEFAULT_PAGE_SIZE: 20,
+  MAX_PAGE_SIZE: 100,
+  SEARCH_DEFAULT_LIMIT: 20,
+  SEARCH_AUTOCOMPLETE_LIMIT: 10,
+  SEARCH_MAX_RESULTS: 50,
+  ONBOARDING_MAX_RETRY_ATTEMPTS: 3,
+} as const;
+
+export const RATE_LIMIT_CONFIG = {
+  TTL: 60,
+  MAX_REQUESTS: 100,
+  AUTH_MAX_REQUESTS: 5,
+} as const;
+
+export const FILE_UPLOAD_CONFIG = {
+  MAX_SIZE: 5 * 1024 * 1024,
+  ALLOWED_IMAGE_TYPES: ['image/jpeg', 'image/png', 'image/webp'],
+} as const;
+
+export const EXPORT_CONFIG = {
+  PUPPETEER_TIMEOUT: 30000,
+  PDF_MAX_PAGES: 10,
+} as const;
+
+export const CACHE_CONFIG = {
+  TTL_SHORT: 300,
+  TTL_MEDIUM: 1800,
+  TTL_LONG: 3600,
+} as const;
diff --git a/src/common/constants/config/crypto.const.ts b/src/common/constants/config/crypto.const.ts
new file mode 100644
index 0000000..bdef17a
--- /dev/null
+++ b/src/common/constants/config/crypto.const.ts
@@ -0,0 +1,13 @@
+/**
+ * Crypto Constants
+ *
+ * Constants for cryptographic operations and byte conversions.
+ */
+export const CRYPTO_CONSTANTS = {
+  /** Secure random token size (256 bits) */
+  TOKEN_BYTES: 32,
+  /** Bytes per kilobyte */
+  BYTES_PER_KB: 1024,
+  /** Bytes per megabyte */
+  BYTES_PER_MB: 1024 * 1024,
+} as const;
diff --git a/src/common/constants/config/error-messages.const.ts b/src/common/constants/config/error-messages.const.ts
new file mode 100644
index 0000000..30760e0
--- /dev/null
+++ b/src/common/constants/config/error-messages.const.ts
@@ -0,0 +1,71 @@
+/**
+ * Error Messages Constants
+ *
+ * Standardized error messages for consistent API responses.
+ */
+export const ERROR_MESSAGES = {
+  // Auth
+  INVALID_CREDENTIALS: 'Invalid credentials',
+  EMAIL_ALREADY_EXISTS: 'Email already registered',
+  USER_NOT_FOUND: 'User not found',
+  UNAUTHORIZED: 'Unauthorized access',
+  PASSWORD_INCORRECT: 'Password is incorrect',
+  CURRENT_PASSWORD_INCORRECT: 'Current password is incorrect',
+  EMAIL_ALREADY_IN_USE: 'Email already in use',
+  USERNAME_ALREADY_IN_USE: 'Username is already taken',
+  CANNOT_DELETE_LAST_ADMIN: 'Cannot delete the last admin account',
+  INVALID_INTERNAL_TOKEN: 'Invalid internal token',
+
+  // Tokens
+  INVALID_VERIFICATION_TOKEN: 'Invalid or expired verification token',
+  INVALID_RESET_TOKEN: 'Invalid or expired reset token',
+  TOKEN_EXPIRED: 'Token has expired',
+
+  // Validation
+  INVALID_EMAIL: 'Invalid email format',
+  INVALID_PASSWORD: 'Password must be at least 8 characters',
+  INVALID_DATE: 'Invalid date format',
+  ID_REQUIRED: 'ID is required',
+  ID_MUST_BE_STRING: 'ID must be a string',
+  NO_FILE_PROVIDED: 'No file provided',
+
+  // Resources
+  RESUME_NOT_FOUND: 'Resume not found',
+  RESUME_NOT_FOUND_FOR_USER: 'Resume not found for this user',
+  RESUME_ACCESS_DENIED: 'Resume not found or access denied',
+  SKILL_NOT_FOUND: 'Skill not found',
+  SECTION_NOT_FOUND: 'Section not found',
+  RESOURCE_NOT_FOUND: 'Resource not found',
+  ACCESS_DENIED: 'Access denied to this resource',
+  PUBLIC_PROFILE_NOT_FOUND: 'Public profile not found',
+
+  // Themes
+  THEME_NOT_FOUND: 'Theme not found',
+  THEME_ACCESS_DENIED: 'Theme not found or access denied',
+  CANNOT_DELETE_SYSTEM_THEMES: 'Cannot delete system themes',
+  CAN_ONLY_DELETE_OWN_THEMES: 'Can only delete own themes',
+  CAN_ONLY_EDIT_OWN_THEMES: 'Can only edit own themes',
+  ONLY_ADMINS_CAN_EDIT_SYSTEM_THEMES: 'Only admins can edit system themes',
+  CAN_ONLY_SUBMIT_OWN_THEMES: 'Can only submit own themes',
+  THEME_MUST_BE_PRIVATE_OR_REJECTED: 'Theme must be private or rejected',
+  THEME_NOT_PENDING_APPROVAL: 'Theme is not pending approval',
+  CANNOT_APPROVE_OWN_THEMES: 'Cannot approve own themes',
+  REJECTION_REASON_REQUIRED: 'Rejection reason is required',
+  CANNOT_FORK_THEME: 'Cannot fork this theme',
+
+  // Config Validation
+  LAYOUT_CONFIG_REQUIRED: 'Layout config is required',
+  SECTIONS_MUST_BE_ARRAY: 'Sections must be an array',
+  ITEM_OVERRIDES_MUST_BE_OBJECT: 'Item overrides must be an object',
+
+  // Upload
+  FILE_UPLOAD_UNAVAILABLE: 'File upload service unavailable',
+
+  // Export
+  EXPORT_FAILED: 'Failed to export document',
+  INVALID_EXPORT_FORMAT: 'Invalid export format',
+
+  // Server
+  INTERNAL_SERVER_ERROR: 'Internal server error',
+  SERVICE_UNAVAILABLE: 'Service temporarily unavailable',
+} as const;
diff --git a/src/common/constants/config/index.ts b/src/common/constants/config/index.ts
new file mode 100644
index 0000000..998da27
--- /dev/null
+++ b/src/common/constants/config/index.ts
@@ -0,0 +1,23 @@
+/**
+ * Configuration Constants - Barrel Export
+ *
+ * Re-exports all configuration constants from a single entry point.
+ */
+
+export {
+  APP_CONFIG,
+  RATE_LIMIT_CONFIG,
+  FILE_UPLOAD_CONFIG,
+  EXPORT_CONFIG,
+  CACHE_CONFIG,
+} from './app-config.const';
+
+export { CRYPTO_CONSTANTS } from './crypto.const';
+
+export { API_LIMITS } from './api-limits.const';
+
+export { TIME_MS, TOKEN_EXPIRY } from './time.const';
+
+export { ERROR_MESSAGES } from './error-messages.const';
+
+export { SUCCESS_MESSAGES } from './success-messages.const';
diff --git a/src/common/constants/config/success-messages.const.ts b/src/common/constants/config/success-messages.const.ts
new file mode 100644
index 0000000..598c117
--- /dev/null
+++ b/src/common/constants/config/success-messages.const.ts
@@ -0,0 +1,19 @@
+/**
+ * Success Messages Constants
+ *
+ * Standardized success messages for consistent API responses.
+ */
+export const SUCCESS_MESSAGES = {
+  // Auth
+  USER_REGISTERED: 'User registered successfully',
+  LOGIN_SUCCESS: 'Login successful',
+  LOGOUT_SUCCESS: 'Logout successful',
+
+  // Resources
+  CREATED: 'Resource created successfully',
+  UPDATED: 'Resource updated successfully',
+  DELETED: 'Resource deleted successfully',
+
+  // Onboarding
+  ONBOARDING_COMPLETED: 'Onboarding completed successfully',
+} as const;
diff --git a/src/common/constants/config/time.const.ts b/src/common/constants/config/time.const.ts
new file mode 100644
index 0000000..51be06c
--- /dev/null
+++ b/src/common/constants/config/time.const.ts
@@ -0,0 +1,22 @@
+/**
+ * Time Constants
+ *
+ * Time conversion constants and token expiry durations.
+ * Eliminates magic numbers for time-based calculations.
+ */
+
+/** Time in milliseconds */
+export const TIME_MS = {
+  SECOND: 1000,
+  MINUTE: 60 * 1000,
+  HOUR: 60 * 60 * 1000,
+  DAY: 24 * 60 * 60 * 1000,
+} as const;
+
+/** Token expiration durations */
+export const TOKEN_EXPIRY = {
+  EMAIL_VERIFICATION_HOURS: 24,
+  PASSWORD_RESET_HOURS: 1,
+  CACHE_VALIDITY_DAYS: 7,
+  RECENT_ACTIVITY_DAYS: 30,
+} as const;
diff --git a/src/common/constants/personas/ai-ml.persona.ts b/src/common/constants/personas/ai-ml.persona.ts
new file mode 100644
index 0000000..7ccf3c5
--- /dev/null
+++ b/src/common/constants/personas/ai-ml.persona.ts
@@ -0,0 +1,47 @@
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+
+export const AI_ML_PERSONA: PersonaConfig = {
+  id: TechPersona.AI_ML,
+  name: 'AI/ML Engineer',
+  description: 'Artificial Intelligence, Deep Learning, NLP',
+  icon: '🤖',
+  primaryColor: '#06B6D4',
+  accentColor: '#0891B2',
+  gradient: ['#06B6D4', '#8B5CF6'],
+  skillCategories: [
+    'Deep Learning',
+    'Natural Language Processing',
+    'Computer Vision',
+    'Reinforcement Learning',
+    'ML Frameworks',
+    'MLOps',
+    'Research',
+  ],
+  achievementTypes: [
+    'paper_citations',
+    'model_performance',
+    'research_contribution',
+    'open_source_ml_lib',
+  ],
+  prioritySections: ['publications', 'openSource', 'projects', 'achievements'],
+  keywords: [
+    'tensorflow',
+    'pytorch',
+    'transformers',
+    'bert',
+    'gpt',
+    'llm',
+    'computer-vision',
+    'nlp',
+    'deep-learning',
+    'neural-networks',
+    'gan',
+    'cnn',
+    'rnn',
+    'lstm',
+    'attention',
+    'mlflow',
+    'kubeflow',
+  ],
+};
diff --git a/src/common/constants/personas/backend.persona.ts b/src/common/constants/personas/backend.persona.ts
new file mode 100644
index 0000000..b40135b
--- /dev/null
+++ b/src/common/constants/personas/backend.persona.ts
@@ -0,0 +1,49 @@
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+
+export const BACKEND_PERSONA: PersonaConfig = {
+  id: TechPersona.BACKEND,
+  name: 'Backend Developer',
+  description: 'APIs, Databases, Microservices, Architecture',
+  icon: '⚡',
+  primaryColor: '#3B82F6',
+  accentColor: '#2563EB',
+  gradient: ['#3B82F6', '#8B5CF6'],
+  skillCategories: [
+    'Programming Languages',
+    'Frameworks',
+    'Databases',
+    'API Design',
+    'Microservices',
+    'System Design',
+    'Performance Optimization',
+  ],
+  achievementTypes: [
+    'system_performance',
+    'scalability_achievement',
+    'api_usage',
+    'open_source_library',
+  ],
+  prioritySections: ['experiences', 'openSource', 'projects', 'certifications'],
+  keywords: [
+    'nodejs',
+    'python',
+    'java',
+    'go',
+    'rust',
+    'c#',
+    'spring-boot',
+    'django',
+    'fastapi',
+    'express',
+    'nestjs',
+    'postgresql',
+    'mongodb',
+    'redis',
+    'rabbitmq',
+    'kafka',
+    'grpc',
+    'microservices',
+    'ddd',
+  ],
+};
diff --git a/src/common/constants/personas/cloud.persona.ts b/src/common/constants/personas/cloud.persona.ts
new file mode 100644
index 0000000..1be25f2
--- /dev/null
+++ b/src/common/constants/personas/cloud.persona.ts
@@ -0,0 +1,46 @@
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+
+export const CLOUD_PERSONA: PersonaConfig = {
+  id: TechPersona.CLOUD,
+  name: 'Cloud Architect',
+  description: 'AWS, Azure, GCP, Cloud Native',
+  icon: '☁️',
+  primaryColor: '#0EA5E9',
+  accentColor: '#0284C7',
+  gradient: ['#0EA5E9', '#8B5CF6'],
+  skillCategories: [
+    'Cloud Platforms',
+    'Cloud Architecture',
+    'Serverless',
+    'Infrastructure as Code',
+    'Cloud Security',
+    'Cost Optimization',
+    'Multi-Cloud',
+  ],
+  achievementTypes: [
+    'cost_savings',
+    'cloud_migration',
+    'architecture_design',
+    'cloud_certifications',
+  ],
+  prioritySections: ['certifications', 'experiences', 'projects', 'talks'],
+  keywords: [
+    'aws',
+    'azure',
+    'gcp',
+    'lambda',
+    'ec2',
+    's3',
+    'cloudformation',
+    'terraform',
+    'serverless',
+    'kubernetes',
+    'ecs',
+    'fargate',
+    'cloud-native',
+    'well-architected',
+    'cloud-security',
+    'finops',
+  ],
+};
diff --git a/src/common/constants/personas/data.persona.ts b/src/common/constants/personas/data.persona.ts
new file mode 100644
index 0000000..e1d91d5
--- /dev/null
+++ b/src/common/constants/personas/data.persona.ts
@@ -0,0 +1,53 @@
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+
+export const DATA_PERSONA: PersonaConfig = {
+  id: TechPersona.DATA,
+  name: 'Data Scientist',
+  description: 'Data Analysis, Machine Learning, Big Data',
+  icon: '📊',
+  primaryColor: '#8B5CF6',
+  accentColor: '#A78BFA',
+  gradient: ['#8B5CF6', '#EC4899'],
+  skillCategories: [
+    'Data Analysis',
+    'Machine Learning',
+    'Data Visualization',
+    'Big Data Technologies',
+    'Statistical Analysis',
+    'Data Engineering',
+    'Programming Languages',
+  ],
+  achievementTypes: [
+    'kaggle_medal',
+    'paper_published',
+    'dataset_created',
+    'model_deployed',
+  ],
+  prioritySections: [
+    'publications',
+    'projects',
+    'achievements',
+    'certifications',
+  ],
+  keywords: [
+    'python',
+    'r',
+    'sql',
+    'pandas',
+    'numpy',
+    'scikit-learn',
+    'tensorflow',
+    'pytorch',
+    'keras',
+    'spark',
+    'hadoop',
+    'tableau',
+    'powerbi',
+    'jupyter',
+    'kaggle',
+    'statistics',
+    'regression',
+    'classification',
+  ],
+};
diff --git a/src/common/constants/personas/devops.persona.ts b/src/common/constants/personas/devops.persona.ts
new file mode 100644
index 0000000..c5181e4
--- /dev/null
+++ b/src/common/constants/personas/devops.persona.ts
@@ -0,0 +1,48 @@
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+
+export const DEVOPS_PERSONA: PersonaConfig = {
+  id: TechPersona.DEVOPS,
+  name: 'DevOps Engineer',
+  description: 'Infrastructure, Automation, CI/CD',
+  icon: '⚙️',
+  primaryColor: '#FF6B6B',
+  accentColor: '#FFA500',
+  gradient: ['#FF6B6B', '#FF8E53'],
+  skillCategories: [
+    'Infrastructure as Code',
+    'CI/CD',
+    'Containers & Orchestration',
+    'Cloud Platforms',
+    'Monitoring & Observability',
+    'Configuration Management',
+    'Scripting & Automation',
+  ],
+  achievementTypes: [
+    'infrastructure_scale',
+    'deployment_frequency',
+    'uptime_achievement',
+    'cost_optimization',
+  ],
+  prioritySections: ['openSource', 'certifications', 'talks', 'experiences'],
+  keywords: [
+    'kubernetes',
+    'docker',
+    'terraform',
+    'ansible',
+    'jenkins',
+    'gitlab-ci',
+    'aws',
+    'azure',
+    'gcp',
+    'prometheus',
+    'grafana',
+    'elk',
+    'datadog',
+    'helm',
+    'argocd',
+    'istio',
+    'vault',
+    'consul',
+  ],
+};
diff --git a/src/common/constants/personas/frontend.persona.ts b/src/common/constants/personas/frontend.persona.ts
new file mode 100644
index 0000000..23c7ff4
--- /dev/null
+++ b/src/common/constants/personas/frontend.persona.ts
@@ -0,0 +1,48 @@
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+
+export const FRONTEND_PERSONA: PersonaConfig = {
+  id: TechPersona.FRONTEND,
+  name: 'Frontend Developer',
+  description: 'React, Vue, Angular, Web Performance',
+  icon: '🌐',
+  primaryColor: '#6366F1',
+  accentColor: '#4F46E5',
+  gradient: ['#6366F1', '#EC4899'],
+  skillCategories: [
+    'JavaScript Frameworks',
+    'CSS/Styling',
+    'State Management',
+    'Build Tools',
+    'Web Performance',
+    'Accessibility',
+    'Testing',
+  ],
+  achievementTypes: [
+    'npm_package',
+    'lighthouse_score',
+    'github_stars',
+    'performance_improvement',
+  ],
+  prioritySections: ['projects', 'openSource', 'experiences', 'achievements'],
+  keywords: [
+    'react',
+    'vue',
+    'angular',
+    'typescript',
+    'javascript',
+    'nextjs',
+    'tailwind',
+    'css',
+    'sass',
+    'webpack',
+    'vite',
+    'redux',
+    'zustand',
+    'testing-library',
+    'jest',
+    'cypress',
+    'web-performance',
+    'pwa',
+  ],
+};
diff --git a/src/common/constants/personas/fullstack.persona.ts b/src/common/constants/personas/fullstack.persona.ts
new file mode 100644
index 0000000..d9324fc
--- /dev/null
+++ b/src/common/constants/personas/fullstack.persona.ts
@@ -0,0 +1,49 @@
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+
+export const FULLSTACK_PERSONA: PersonaConfig = {
+  id: TechPersona.FULLSTACK,
+  name: 'Full Stack Developer',
+  description: 'Frontend, Backend, Databases, APIs',
+  icon: '💻',
+  primaryColor: '#10B981',
+  accentColor: '#059669',
+  gradient: ['#10B981', '#3B82F6'],
+  skillCategories: [
+    'Frontend Frameworks',
+    'Backend Technologies',
+    'Databases',
+    'API Development',
+    'DevOps Basics',
+    'UI/UX',
+    'Testing',
+  ],
+  achievementTypes: [
+    'github_stars',
+    'npm_downloads',
+    'open_source_contribution',
+    'hackathon_win',
+  ],
+  prioritySections: ['projects', 'openSource', 'experiences', 'hackathons'],
+  keywords: [
+    'react',
+    'vue',
+    'angular',
+    'nodejs',
+    'express',
+    'nestjs',
+    'typescript',
+    'javascript',
+    'mongodb',
+    'postgresql',
+    'redis',
+    'graphql',
+    'rest',
+    'docker',
+    'git',
+    'aws',
+    'vercel',
+    'nextjs',
+    'tailwind',
+  ],
+};
diff --git a/src/common/constants/personas/game-dev.persona.ts b/src/common/constants/personas/game-dev.persona.ts
new file mode 100644
index 0000000..4ae552b
--- /dev/null
+++ b/src/common/constants/personas/game-dev.persona.ts
@@ -0,0 +1,45 @@
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+
+export const GAME_DEV_PERSONA: PersonaConfig = {
+  id: TechPersona.GAME_DEV,
+  name: 'Game Developer',
+  description: 'Unity, Unreal, Game Design, Graphics',
+  icon: '🎮',
+  primaryColor: '#A855F7',
+  accentColor: '#9333EA',
+  gradient: ['#A855F7', '#EC4899'],
+  skillCategories: [
+    'Game Engines',
+    'Graphics Programming',
+    'Game Design',
+    'Physics',
+    'AI for Games',
+    'Multiplayer',
+    'Optimization',
+  ],
+  achievementTypes: [
+    'game_downloads',
+    'game_awards',
+    'jam_wins',
+    'player_count',
+  ],
+  prioritySections: ['projects', 'hackathons', 'awards', 'experiences'],
+  keywords: [
+    'unity',
+    'unreal-engine',
+    'c#',
+    'c++',
+    'godot',
+    '3d-modeling',
+    'shader',
+    'physics',
+    'multiplayer',
+    'steam',
+    'mobile-games',
+    'game-jam',
+    'procedural-generation',
+    'ai',
+    'networking',
+  ],
+};
diff --git a/src/common/constants/personas/index.ts b/src/common/constants/personas/index.ts
new file mode 100644
index 0000000..c163de4
--- /dev/null
+++ b/src/common/constants/personas/index.ts
@@ -0,0 +1,69 @@
+/**
+ * Tech Personas - Barrel Export
+ *
+ * Aggregates all persona configurations into a single record
+ * and re-exports types and helpers for clean imports.
+ */
+
+// Types and Enum
+export { TechPersona } from './tech-persona.enum';
+export { PersonaConfig } from './persona-config.interface';
+
+// Individual Personas
+export { DEVOPS_PERSONA } from './devops.persona';
+export { SECURITY_PERSONA } from './security.persona';
+export { DATA_PERSONA } from './data.persona';
+export { AI_ML_PERSONA } from './ai-ml.persona';
+export { FULLSTACK_PERSONA } from './fullstack.persona';
+export { MOBILE_PERSONA } from './mobile.persona';
+export { QA_PERSONA } from './qa.persona';
+export { UX_UI_PERSONA } from './ux-ui.persona';
+export { BACKEND_PERSONA } from './backend.persona';
+export { FRONTEND_PERSONA } from './frontend.persona';
+export { CLOUD_PERSONA } from './cloud.persona';
+export { GAME_DEV_PERSONA } from './game-dev.persona';
+
+// Helpers
+export {
+  getPersonaConfig,
+  suggestPersona,
+  getAllPersonaIds,
+  isValidPersona,
+} from './persona.helpers';
+
+// Import personas for aggregation
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+import { DEVOPS_PERSONA } from './devops.persona';
+import { SECURITY_PERSONA } from './security.persona';
+import { DATA_PERSONA } from './data.persona';
+import { AI_ML_PERSONA } from './ai-ml.persona';
+import { FULLSTACK_PERSONA } from './fullstack.persona';
+import { MOBILE_PERSONA } from './mobile.persona';
+import { QA_PERSONA } from './qa.persona';
+import { UX_UI_PERSONA } from './ux-ui.persona';
+import { BACKEND_PERSONA } from './backend.persona';
+import { FRONTEND_PERSONA } from './frontend.persona';
+import { CLOUD_PERSONA } from './cloud.persona';
+import { GAME_DEV_PERSONA } from './game-dev.persona';
+
+/**
+ * Aggregated record of all tech personas
+ *
+ * Use this for iterating over all personas or
+ * accessing a specific persona by its enum key.
+ */
+export const TECH_PERSONAS: Record<TechPersona, PersonaConfig> = {
+  [TechPersona.DEVOPS]: DEVOPS_PERSONA,
+  [TechPersona.SECURITY]: SECURITY_PERSONA,
+  [TechPersona.DATA]: DATA_PERSONA,
+  [TechPersona.AI_ML]: AI_ML_PERSONA,
+  [TechPersona.FULLSTACK]: FULLSTACK_PERSONA,
+  [TechPersona.MOBILE]: MOBILE_PERSONA,
+  [TechPersona.QA]: QA_PERSONA,
+  [TechPersona.UX_UI]: UX_UI_PERSONA,
+  [TechPersona.BACKEND]: BACKEND_PERSONA,
+  [TechPersona.FRONTEND]: FRONTEND_PERSONA,
+  [TechPersona.CLOUD]: CLOUD_PERSONA,
+  [TechPersona.GAME_DEV]: GAME_DEV_PERSONA,
+};
diff --git a/src/common/constants/personas/mobile.persona.ts b/src/common/constants/personas/mobile.persona.ts
new file mode 100644
index 0000000..9a4977b
--- /dev/null
+++ b/src/common/constants/personas/mobile.persona.ts
@@ -0,0 +1,50 @@
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+
+export const MOBILE_PERSONA: PersonaConfig = {
+  id: TechPersona.MOBILE,
+  name: 'Mobile Developer',
+  description: 'iOS, Android, React Native, Flutter',
+  icon: '📱',
+  primaryColor: '#F59E0B',
+  accentColor: '#D97706',
+  gradient: ['#F59E0B', '#EF4444'],
+  skillCategories: [
+    'Mobile Frameworks',
+    'Native Development',
+    'Cross-Platform',
+    'App Architecture',
+    'UI/UX',
+    'App Store Optimization',
+    'Testing',
+  ],
+  achievementTypes: [
+    'app_downloads',
+    'app_rating',
+    'featured_app',
+    'app_revenue',
+  ],
+  prioritySections: [
+    'projects',
+    'experiences',
+    'achievements',
+    'certifications',
+  ],
+  keywords: [
+    'react-native',
+    'flutter',
+    'swift',
+    'kotlin',
+    'ios',
+    'android',
+    'swiftui',
+    'jetpack-compose',
+    'firebase',
+    'realm',
+    'sqlite',
+    'push-notifications',
+    'in-app-purchases',
+    'app-store',
+    'play-store',
+  ],
+};
diff --git a/src/common/constants/personas/persona-config.interface.ts b/src/common/constants/personas/persona-config.interface.ts
new file mode 100644
index 0000000..5f282ea
--- /dev/null
+++ b/src/common/constants/personas/persona-config.interface.ts
@@ -0,0 +1,42 @@
+import { TechPersona } from './tech-persona.enum';
+
+/**
+ * Persona Configuration Interface
+ *
+ * Defines the structure for each tech persona's configuration,
+ * including visual styling, relevant skills, and priority sections.
+ */
+export interface PersonaConfig {
+  /** Unique persona identifier */
+  id: TechPersona;
+
+  /** Display name for the persona */
+  name: string;
+
+  /** Short description of the persona's focus */
+  description: string;
+
+  /** Emoji or icon name representing the persona */
+  icon: string;
+
+  /** Primary theme color (hex) */
+  primaryColor: string;
+
+  /** Accent/secondary color (hex) */
+  accentColor: string;
+
+  /** Gradient colors for visual effects [start, end] */
+  gradient: [string, string];
+
+  /** Relevant skill categories for this persona */
+  skillCategories: string[];
+
+  /** Types of achievements relevant to this persona */
+  achievementTypes: string[];
+
+  /** Resume sections that should be highlighted */
+  prioritySections: string[];
+
+  /** Keywords for persona detection and suggestions */
+  keywords: string[];
+}
diff --git a/src/common/constants/personas/persona.helpers.ts b/src/common/constants/personas/persona.helpers.ts
new file mode 100644
index 0000000..87fc896
--- /dev/null
+++ b/src/common/constants/personas/persona.helpers.ts
@@ -0,0 +1,52 @@
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+import { TECH_PERSONAS } from './index';
+
+/**
+ * Get configuration for a specific persona
+ */
+export function getPersonaConfig(persona: TechPersona): PersonaConfig {
+  return TECH_PERSONAS[persona];
+}
+
+/**
+ * Suggest persona based on job title and skills
+ *
+ * Analyzes keywords from job title and skills to find the best matching
+ * persona. Returns FULLSTACK as default if no strong match is found.
+ */
+export function suggestPersona(
+  jobTitle: string,
+  skills: string[],
+): TechPersona {
+  const jobLower = jobTitle.toLowerCase();
+  const skillsLower = skills.map((s) => s.toLowerCase());
+
+  for (const [persona, config] of Object.entries(TECH_PERSONAS)) {
+    const matchingKeywords = config.keywords.filter(
+      (keyword) =>
+        jobLower.includes(keyword) ||
+        skillsLower.some((skill) => skill.includes(keyword)),
+    );
+
+    if (matchingKeywords.length > 3) {
+      return persona as TechPersona;
+    }
+  }
+
+  return TechPersona.FULLSTACK;
+}
+
+/**
+ * Get all available persona IDs
+ */
+export function getAllPersonaIds(): TechPersona[] {
+  return Object.values(TechPersona);
+}
+
+/**
+ * Check if a string is a valid persona ID
+ */
+export function isValidPersona(value: string): value is TechPersona {
+  return Object.values(TechPersona).includes(value as TechPersona);
+}
diff --git a/src/common/constants/personas/qa.persona.ts b/src/common/constants/personas/qa.persona.ts
new file mode 100644
index 0000000..50e9718
--- /dev/null
+++ b/src/common/constants/personas/qa.persona.ts
@@ -0,0 +1,45 @@
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+
+export const QA_PERSONA: PersonaConfig = {
+  id: TechPersona.QA,
+  name: 'QA Engineer',
+  description: 'Test Automation, Quality Assurance, Testing',
+  icon: '🧪',
+  primaryColor: '#14B8A6',
+  accentColor: '#0D9488',
+  gradient: ['#14B8A6', '#06B6D4'],
+  skillCategories: [
+    'Test Automation',
+    'Manual Testing',
+    'Performance Testing',
+    'Security Testing',
+    'Test Frameworks',
+    'CI/CD Integration',
+    'Bug Tracking',
+  ],
+  achievementTypes: [
+    'bugs_found',
+    'test_coverage',
+    'automation_rate',
+    'quality_improvement',
+  ],
+  prioritySections: ['experiences', 'certifications', 'projects', 'skills'],
+  keywords: [
+    'selenium',
+    'cypress',
+    'playwright',
+    'jest',
+    'junit',
+    'testng',
+    'jmeter',
+    'postman',
+    'rest-assured',
+    'appium',
+    'cucumber',
+    'bdd',
+    'tdd',
+    'continuous-testing',
+    'qa-automation',
+  ],
+};
diff --git a/src/common/constants/personas/security.persona.ts b/src/common/constants/personas/security.persona.ts
new file mode 100644
index 0000000..d623640
--- /dev/null
+++ b/src/common/constants/personas/security.persona.ts
@@ -0,0 +1,54 @@
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+
+export const SECURITY_PERSONA: PersonaConfig = {
+  id: TechPersona.SECURITY,
+  name: 'Security Specialist',
+  description: 'Cybersecurity, Pentesting, Ethical Hacking',
+  icon: '🛡️',
+  primaryColor: '#DC2626',
+  accentColor: '#B91C1C',
+  gradient: ['#DC2626', '#7C2D12'],
+  skillCategories: [
+    'Penetration Testing',
+    'Vulnerability Assessment',
+    'Security Tools',
+    'Cryptography',
+    'Network Security',
+    'Application Security',
+    'Incident Response',
+  ],
+  achievementTypes: [
+    'cve_discovered',
+    'bug_bounty_total',
+    'ctf_wins',
+    'hall_of_fame',
+  ],
+  prioritySections: [
+    'bugBounties',
+    'certifications',
+    'publications',
+    'achievements',
+  ],
+  keywords: [
+    'oscp',
+    'ceh',
+    'cissp',
+    'burp-suite',
+    'metasploit',
+    'nmap',
+    'wireshark',
+    'owasp',
+    'xss',
+    'sql-injection',
+    'csrf',
+    'pentesting',
+    'red-team',
+    'blue-team',
+    'soc',
+    'siem',
+    'ids',
+    'ips',
+    'forensics',
+  ],
+};
diff --git a/src/common/constants/personas/tech-persona.enum.ts b/src/common/constants/personas/tech-persona.enum.ts
new file mode 100644
index 0000000..d624fde
--- /dev/null
+++ b/src/common/constants/personas/tech-persona.enum.ts
@@ -0,0 +1,21 @@
+/**
+ * Tech Persona Enum - Defines all available tech personas
+ *
+ * Each persona represents a specific IT professional archetype
+ * with unique characteristics, skills, and career focus areas.
+ */
+
+export enum TechPersona {
+  DEVOPS = 'devops',
+  SECURITY = 'security',
+  DATA = 'data',
+  FULLSTACK = 'fullstack',
+  MOBILE = 'mobile',
+  AI_ML = 'ai-ml',
+  QA = 'qa',
+  UX_UI = 'ux-ui',
+  BACKEND = 'backend',
+  FRONTEND = 'frontend',
+  CLOUD = 'cloud',
+  GAME_DEV = 'game-dev',
+}
diff --git a/src/common/constants/personas/ux-ui.persona.ts b/src/common/constants/personas/ux-ui.persona.ts
new file mode 100644
index 0000000..5853e5c
--- /dev/null
+++ b/src/common/constants/personas/ux-ui.persona.ts
@@ -0,0 +1,41 @@
+import { TechPersona } from './tech-persona.enum';
+import { PersonaConfig } from './persona-config.interface';
+
+export const UX_UI_PERSONA: PersonaConfig = {
+  id: TechPersona.UX_UI,
+  name: 'UX/UI Designer',
+  description: 'User Experience, Interface Design, Prototyping',
+  icon: '🎨',
+  primaryColor: '#EC4899',
+  accentColor: '#DB2777',
+  gradient: ['#EC4899', '#F59E0B'],
+  skillCategories: [
+    'UI Design',
+    'UX Research',
+    'Prototyping',
+    'Design Systems',
+    'User Testing',
+    'Interaction Design',
+    'Design Tools',
+  ],
+  achievementTypes: [
+    'design_awards',
+    'case_studies',
+    'user_satisfaction',
+    'design_system_adoption',
+  ],
+  prioritySections: ['projects', 'awards', 'experiences', 'certifications'],
+  keywords: [
+    'figma',
+    'sketch',
+    'adobe-xd',
+    'prototyping',
+    'wireframing',
+    'user-research',
+    'usability-testing',
+    'design-systems',
+    'accessibility',
+    'responsive-design',
+    'interaction-design',
+  ],
+};
diff --git a/src/common/constants/tech-personas.ts b/src/common/constants/tech-personas.ts
index 304ecfc..3bc8158 100644
--- a/src/common/constants/tech-personas.ts
+++ b/src/common/constants/tech-personas.ts
@@ -1,642 +1,35 @@
 /**
- * 🎭 TECH PERSONAS - Definições de personalidade por área de TI
+ * Tech Personas - Re-export for backward compatibility
  *
- * Cada persona tem características únicas que definem:
- * - Cores e estilo visual
- * - Skills categories relevantes
- * - Achievements típicos
- * - Seções prioritárias no resume
- */
-
-export enum TechPersona {
-  DEVOPS = 'devops',
-  SECURITY = 'security',
-  DATA = 'data',
-  FULLSTACK = 'fullstack',
-  MOBILE = 'mobile',
-  AI_ML = 'ai-ml',
-  QA = 'qa',
-  UX_UI = 'ux-ui',
-  BACKEND = 'backend',
-  FRONTEND = 'frontend',
-  CLOUD = 'cloud',
-  GAME_DEV = 'game-dev',
-}
-
-interface PersonaConfig {
-  id: TechPersona;
-  name: string;
-  description: string;
-  icon: string; // Emoji ou icon name
-  primaryColor: string; // Cor principal
-  accentColor: string; // Cor de destaque
-  gradient: [string, string]; // Gradiente único
-
-  // Skills categories relevantes
-  skillCategories: string[];
-
-  // Achievement types que fazem sentido
-  achievementTypes: string[];
-
-  // Seções que devem ser destacadas
-  prioritySections: string[];
-
-  // Keywords para suggestions
-  keywords: string[];
-}
-
-export const TECH_PERSONAS: Record<TechPersona, PersonaConfig> = {
-  [TechPersona.DEVOPS]: {
-    id: TechPersona.DEVOPS,
-    name: 'DevOps Engineer',
-    description: 'Infrastructure, Automation, CI/CD',
-    icon: '⚙️',
-    primaryColor: '#FF6B6B',
-    accentColor: '#FFA500',
-    gradient: ['#FF6B6B', '#FF8E53'],
-    skillCategories: [
-      'Infrastructure as Code',
-      'CI/CD',
-      'Containers & Orchestration',
-      'Cloud Platforms',
-      'Monitoring & Observability',
-      'Configuration Management',
-      'Scripting & Automation',
-    ],
-    achievementTypes: [
-      'infrastructure_scale',
-      'deployment_frequency',
-      'uptime_achievement',
-      'cost_optimization',
-    ],
-    prioritySections: ['openSource', 'certifications', 'talks', 'experiences'],
-    keywords: [
-      'kubernetes',
-      'docker',
-      'terraform',
-      'ansible',
-      'jenkins',
-      'gitlab-ci',
-      'aws',
-      'azure',
-      'gcp',
-      'prometheus',
-      'grafana',
-      'elk',
-      'datadog',
-      'helm',
-      'argocd',
-      'istio',
-      'vault',
-      'consul',
-    ],
-  },
-
-  [TechPersona.SECURITY]: {
-    id: TechPersona.SECURITY,
-    name: 'Security Specialist',
-    description: 'Cybersecurity, Pentesting, Ethical Hacking',
-    icon: '🛡️',
-    primaryColor: '#DC2626',
-    accentColor: '#B91C1C',
-    gradient: ['#DC2626', '#7C2D12'],
-    skillCategories: [
-      'Penetration Testing',
-      'Vulnerability Assessment',
-      'Security Tools',
-      'Cryptography',
-      'Network Security',
-      'Application Security',
-      'Incident Response',
-    ],
-    achievementTypes: [
-      'cve_discovered',
-      'bug_bounty_total',
-      'ctf_wins',
-      'hall_of_fame',
-    ],
-    prioritySections: [
-      'bugBounties',
-      'certifications',
-      'publications',
-      'achievements',
-    ],
-    keywords: [
-      'oscp',
-      'ceh',
-      'cissp',
-      'burp-suite',
-      'metasploit',
-      'nmap',
-      'wireshark',
-      'owasp',
-      'xss',
-      'sql-injection',
-      'csrf',
-      'pentesting',
-      'red-team',
-      'blue-team',
-      'soc',
-      'siem',
-      'ids',
-      'ips',
-      'forensics',
-    ],
-  },
-
-  [TechPersona.DATA]: {
-    id: TechPersona.DATA,
-    name: 'Data Scientist',
-    description: 'Data Analysis, Machine Learning, Big Data',
-    icon: '📊',
-    primaryColor: '#8B5CF6',
-    accentColor: '#A78BFA',
-    gradient: ['#8B5CF6', '#EC4899'],
-    skillCategories: [
-      'Data Analysis',
-      'Machine Learning',
-      'Data Visualization',
-      'Big Data Technologies',
-      'Statistical Analysis',
-      'Data Engineering',
-      'Programming Languages',
-    ],
-    achievementTypes: [
-      'kaggle_medal',
-      'paper_published',
-      'dataset_created',
-      'model_deployed',
-    ],
-    prioritySections: [
-      'publications',
-      'projects',
-      'achievements',
-      'certifications',
-    ],
-    keywords: [
-      'python',
-      'r',
-      'sql',
-      'pandas',
-      'numpy',
-      'scikit-learn',
-      'tensorflow',
-      'pytorch',
-      'keras',
-      'spark',
-      'hadoop',
-      'tableau',
-      'powerbi',
-      'jupyter',
-      'kaggle',
-      'statistics',
-      'regression',
-      'classification',
-    ],
-  },
-
-  [TechPersona.AI_ML]: {
-    id: TechPersona.AI_ML,
-    name: 'AI/ML Engineer',
-    description: 'Artificial Intelligence, Deep Learning, NLP',
-    icon: '🤖',
-    primaryColor: '#06B6D4',
-    accentColor: '#0891B2',
-    gradient: ['#06B6D4', '#8B5CF6'],
-    skillCategories: [
-      'Deep Learning',
-      'Natural Language Processing',
-      'Computer Vision',
-      'Reinforcement Learning',
-      'ML Frameworks',
-      'MLOps',
-      'Research',
-    ],
-    achievementTypes: [
-      'paper_citations',
-      'model_performance',
-      'research_contribution',
-      'open_source_ml_lib',
-    ],
-    prioritySections: [
-      'publications',
-      'openSource',
-      'projects',
-      'achievements',
-    ],
-    keywords: [
-      'tensorflow',
-      'pytorch',
-      'transformers',
-      'bert',
-      'gpt',
-      'llm',
-      'computer-vision',
-      'nlp',
-      'deep-learning',
-      'neural-networks',
-      'gan',
-      'cnn',
-      'rnn',
-      'lstm',
-      'attention',
-      'mlflow',
-      'kubeflow',
-    ],
-  },
-
-  [TechPersona.FULLSTACK]: {
-    id: TechPersona.FULLSTACK,
-    name: 'Full Stack Developer',
-    description: 'Frontend, Backend, Databases, APIs',
-    icon: '💻',
-    primaryColor: '#10B981',
-    accentColor: '#059669',
-    gradient: ['#10B981', '#3B82F6'],
-    skillCategories: [
-      'Frontend Frameworks',
-      'Backend Technologies',
-      'Databases',
-      'API Development',
-      'DevOps Basics',
-      'UI/UX',
-      'Testing',
-    ],
-    achievementTypes: [
-      'github_stars',
-      'npm_downloads',
-      'open_source_contribution',
-      'hackathon_win',
-    ],
-    prioritySections: ['projects', 'openSource', 'experiences', 'hackathons'],
-    keywords: [
-      'react',
-      'vue',
-      'angular',
-      'nodejs',
-      'express',
-      'nestjs',
-      'typescript',
-      'javascript',
-      'mongodb',
-      'postgresql',
-      'redis',
-      'graphql',
-      'rest',
-      'docker',
-      'git',
-      'aws',
-      'vercel',
-      'nextjs',
-      'tailwind',
-    ],
-  },
-
-  [TechPersona.MOBILE]: {
-    id: TechPersona.MOBILE,
-    name: 'Mobile Developer',
-    description: 'iOS, Android, React Native, Flutter',
-    icon: '📱',
-    primaryColor: '#F59E0B',
-    accentColor: '#D97706',
-    gradient: ['#F59E0B', '#EF4444'],
-    skillCategories: [
-      'Mobile Frameworks',
-      'Native Development',
-      'Cross-Platform',
-      'App Architecture',
-      'UI/UX',
-      'App Store Optimization',
-      'Testing',
-    ],
-    achievementTypes: [
-      'app_downloads',
-      'app_rating',
-      'featured_app',
-      'app_revenue',
-    ],
-    prioritySections: [
-      'projects',
-      'experiences',
-      'achievements',
-      'certifications',
-    ],
-    keywords: [
-      'react-native',
-      'flutter',
-      'swift',
-      'kotlin',
-      'ios',
-      'android',
-      'swiftui',
-      'jetpack-compose',
-      'firebase',
-      'realm',
-      'sqlite',
-      'push-notifications',
-      'in-app-purchases',
-      'app-store',
-      'play-store',
-    ],
-  },
-
-  [TechPersona.QA]: {
-    id: TechPersona.QA,
-    name: 'QA Engineer',
-    description: 'Test Automation, Quality Assurance, Testing',
-    icon: '🧪',
-    primaryColor: '#14B8A6',
-    accentColor: '#0D9488',
-    gradient: ['#14B8A6', '#06B6D4'],
-    skillCategories: [
-      'Test Automation',
-      'Manual Testing',
-      'Performance Testing',
-      'Security Testing',
-      'Test Frameworks',
-      'CI/CD Integration',
-      'Bug Tracking',
-    ],
-    achievementTypes: [
-      'bugs_found',
-      'test_coverage',
-      'automation_rate',
-      'quality_improvement',
-    ],
-    prioritySections: ['experiences', 'certifications', 'projects', 'skills'],
-    keywords: [
-      'selenium',
-      'cypress',
-      'playwright',
-      'jest',
-      'junit',
-      'testng',
-      'jmeter',
-      'postman',
-      'rest-assured',
-      'appium',
-      'cucumber',
-      'bdd',
-      'tdd',
-      'continuous-testing',
-      'qa-automation',
-    ],
-  },
-
-  [TechPersona.UX_UI]: {
-    id: TechPersona.UX_UI,
-    name: 'UX/UI Designer',
-    description: 'User Experience, Interface Design, Prototyping',
-    icon: '🎨',
-    primaryColor: '#EC4899',
-    accentColor: '#DB2777',
-    gradient: ['#EC4899', '#F59E0B'],
-    skillCategories: [
-      'UI Design',
-      'UX Research',
-      'Prototyping',
-      'Design Systems',
-      'User Testing',
-      'Interaction Design',
-      'Design Tools',
-    ],
-    achievementTypes: [
-      'design_awards',
-      'case_studies',
-      'user_satisfaction',
-      'design_system_adoption',
-    ],
-    prioritySections: ['projects', 'awards', 'experiences', 'certifications'],
-    keywords: [
-      'figma',
-      'sketch',
-      'adobe-xd',
-      'prototyping',
-      'wireframing',
-      'user-research',
-      'usability-testing',
-      'design-systems',
-      'accessibility',
-      'responsive-design',
-      'interaction-design',
-    ],
-  },
-
-  [TechPersona.BACKEND]: {
-    id: TechPersona.BACKEND,
-    name: 'Backend Developer',
-    description: 'APIs, Databases, Microservices, Architecture',
-    icon: '⚡',
-    primaryColor: '#3B82F6',
-    accentColor: '#2563EB',
-    gradient: ['#3B82F6', '#8B5CF6'],
-    skillCategories: [
-      'Programming Languages',
-      'Frameworks',
-      'Databases',
-      'API Design',
-      'Microservices',
-      'System Design',
-      'Performance Optimization',
-    ],
-    achievementTypes: [
-      'system_performance',
-      'scalability_achievement',
-      'api_usage',
-      'open_source_library',
-    ],
-    prioritySections: [
-      'experiences',
-      'openSource',
-      'projects',
-      'certifications',
-    ],
-    keywords: [
-      'nodejs',
-      'python',
-      'java',
-      'go',
-      'rust',
-      'c#',
-      'spring-boot',
-      'django',
-      'fastapi',
-      'express',
-      'nestjs',
-      'postgresql',
-      'mongodb',
-      'redis',
-      'rabbitmq',
-      'kafka',
-      'grpc',
-      'microservices',
-      'ddd',
-    ],
-  },
-
-  [TechPersona.FRONTEND]: {
-    id: TechPersona.FRONTEND,
-    name: 'Frontend Developer',
-    description: 'React, Vue, Angular, Web Performance',
-    icon: '🌐',
-    primaryColor: '#6366F1',
-    accentColor: '#4F46E5',
-    gradient: ['#6366F1', '#EC4899'],
-    skillCategories: [
-      'JavaScript Frameworks',
-      'CSS/Styling',
-      'State Management',
-      'Build Tools',
-      'Web Performance',
-      'Accessibility',
-      'Testing',
-    ],
-    achievementTypes: [
-      'npm_package',
-      'lighthouse_score',
-      'github_stars',
-      'performance_improvement',
-    ],
-    prioritySections: ['projects', 'openSource', 'experiences', 'achievements'],
-    keywords: [
-      'react',
-      'vue',
-      'angular',
-      'typescript',
-      'javascript',
-      'nextjs',
-      'tailwind',
-      'css',
-      'sass',
-      'webpack',
-      'vite',
-      'redux',
-      'zustand',
-      'testing-library',
-      'jest',
-      'cypress',
-      'web-performance',
-      'pwa',
-    ],
-  },
-
-  [TechPersona.CLOUD]: {
-    id: TechPersona.CLOUD,
-    name: 'Cloud Architect',
-    description: 'AWS, Azure, GCP, Cloud Native',
-    icon: '☁️',
-    primaryColor: '#0EA5E9',
-    accentColor: '#0284C7',
-    gradient: ['#0EA5E9', '#8B5CF6'],
-    skillCategories: [
-      'Cloud Platforms',
-      'Cloud Architecture',
-      'Serverless',
-      'Infrastructure as Code',
-      'Cloud Security',
-      'Cost Optimization',
-      'Multi-Cloud',
-    ],
-    achievementTypes: [
-      'cost_savings',
-      'cloud_migration',
-      'architecture_design',
-      'cloud_certifications',
-    ],
-    prioritySections: ['certifications', 'experiences', 'projects', 'talks'],
-    keywords: [
-      'aws',
-      'azure',
-      'gcp',
-      'lambda',
-      'ec2',
-      's3',
-      'cloudformation',
-      'terraform',
-      'serverless',
-      'kubernetes',
-      'ecs',
-      'fargate',
-      'cloud-native',
-      'well-architected',
-      'cloud-security',
-      'finops',
-    ],
-  },
-
-  [TechPersona.GAME_DEV]: {
-    id: TechPersona.GAME_DEV,
-    name: 'Game Developer',
-    description: 'Unity, Unreal, Game Design, Graphics',
-    icon: '🎮',
-    primaryColor: '#A855F7',
-    accentColor: '#9333EA',
-    gradient: ['#A855F7', '#EC4899'],
-    skillCategories: [
-      'Game Engines',
-      'Graphics Programming',
-      'Game Design',
-      'Physics',
-      'AI for Games',
-      'Multiplayer',
-      'Optimization',
-    ],
-    achievementTypes: [
-      'game_downloads',
-      'game_awards',
-      'jam_wins',
-      'player_count',
-    ],
-    prioritySections: ['projects', 'hackathons', 'awards', 'experiences'],
-    keywords: [
-      'unity',
-      'unreal-engine',
-      'c#',
-      'c++',
-      'godot',
-      '3d-modeling',
-      'shader',
-      'physics',
-      'multiplayer',
-      'steam',
-      'mobile-games',
-      'game-jam',
-      'procedural-generation',
-      'ai',
-      'networking',
-    ],
-  },
-};
-
-/**
- * Helper para obter config de uma persona
- */
-export function getPersonaConfig(persona: TechPersona): PersonaConfig {
-  return TECH_PERSONAS[persona];
-}
-
-/**
- * Sugerir persona baseado em skills e job title
+ * This file has been refactored. All persona definitions are now
+ * split into individual files under ./personas/ directory.
+ *
+ * @see ./personas/index.ts for the new structure
+ * @deprecated Import directly from './personas' instead
  */
-export function suggestPersona(
-  jobTitle: string,
-  skills: string[],
-): TechPersona {
-  const jobLower = jobTitle.toLowerCase();
-  const skillsLower = skills.map((s) => s.toLowerCase());
-
-  // Lógica de detecção baseada em keywords
-  for (const [persona, config] of Object.entries(TECH_PERSONAS)) {
-    const matchingKeywords = config.keywords.filter(
-      (keyword) =>
-        jobLower.includes(keyword) ||
-        skillsLower.some((skill) => skill.includes(keyword)),
-    );
-
-    if (matchingKeywords.length > 3) {
-      return persona as TechPersona;
-    }
-  }
 
-  return TechPersona.FULLSTACK; // Default
-}
+export {
+  // Enum & Types
+  TechPersona,
+  PersonaConfig,
+  // Aggregated record
+  TECH_PERSONAS,
+  // Individual personas (for direct access if needed)
+  DEVOPS_PERSONA,
+  SECURITY_PERSONA,
+  DATA_PERSONA,
+  AI_ML_PERSONA,
+  FULLSTACK_PERSONA,
+  MOBILE_PERSONA,
+  QA_PERSONA,
+  UX_UI_PERSONA,
+  BACKEND_PERSONA,
+  FRONTEND_PERSONA,
+  CLOUD_PERSONA,
+  GAME_DEV_PERSONA,
+  // Helper functions
+  getPersonaConfig,
+  suggestPersona,
+  getAllPersonaIds,
+  isValidPersona,
+} from './personas';
diff --git a/src/common/constants/validation.constants.ts b/src/common/constants/validation.constants.ts
index 0675cad..65f5c5c 100644
--- a/src/common/constants/validation.constants.ts
+++ b/src/common/constants/validation.constants.ts
@@ -1,124 +1,22 @@
 /**
- * Validation Constants - Magic Numbers Extraction (Clean Code G25)
- * Centralizes validation rules and limits
+ * Validation Constants - Re-export for backward compatibility
+ *
+ * This file has been refactored. All validation constants are now
+ * split into smaller files under ./validation/ directory.
+ *
+ * @see ./validation/index.ts for the new structure
+ * @deprecated Import directly from './validation' instead
  */
 
-// ==================== STRING LENGTHS ====================
-export const STRING_LENGTH = {
-  MIN: {
-    PASSWORD: 8,
-    USERNAME: 3,
-    NAME: 2,
-    DESCRIPTION: 10,
-  },
-  MAX: {
-    EMAIL: 255,
-    USERNAME: 50,
-    NAME: 100,
-    BIO: 500,
-    DESCRIPTION: 2000,
-    TITLE: 200,
-    URL: 2048,
-  },
-} as const;
-
-// ==================== ARRAY LIMITS ====================
-export const ARRAY_LIMIT = {
-  MAX: {
-    SKILLS_PER_CATEGORY: 20,
-    SKILL_CATEGORIES: 10,
-    EXPERIENCES: 15,
-    EDUCATION: 10,
-    PROJECTS: 20,
-    CERTIFICATIONS: 20,
-    LANGUAGES: 10,
-    AWARDS: 10,
-    RECOMMENDATIONS: 10,
-  },
-} as const;
-
-// ==================== FILE UPLOAD ====================
-export const FILE = {
-  MAX_SIZE_MB: 5,
-  MAX_SIZE_BYTES: 5 * 1024 * 1024,
-  ALLOWED_IMAGE_TYPES: [
-    'image/jpeg',
-    'image/png',
-    'image/webp',
-    'image/svg+xml',
-  ],
-  ALLOWED_DOCUMENT_TYPES: [
-    'application/pdf',
-    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
-  ],
-} as const;
-
-// ==================== REGEX PATTERNS ====================
-export const REGEX = {
-  EMAIL: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
-  URL: /^https?:\/\/.+/,
-  USERNAME: /^[a-zA-Z0-9_-]+$/,
-  PHONE: /^[\d\s\-+()]+$/,
-  HEX_COLOR: /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/,
-  // Password: at least 1 uppercase, 1 lowercase, 1 number, 1 special char
-  PASSWORD: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]+$/,
-} as const;
-
-export const PASSWORD_REQUIREMENTS = {
-  MIN_LENGTH: 8,
-  REQUIREMENTS_MESSAGE:
-    'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character (@$!%*?&)',
-} as const;
-
-// ==================== DATE VALIDATION ====================
-export const DATE = {
-  MIN_YEAR: 1950,
-  MAX_YEAR: new Date().getFullYear() + 10, // allows up to 10 years in the future
-} as const;
-
-// ==================== RATE LIMITING ====================
-export const RATE_LIMIT = {
-  API: {
-    WINDOW_MS: 15 * 60 * 1000, // 15 minutes
-    MAX_REQUESTS: 100,
-  },
-  EXPORT: {
-    WINDOW_MS: 60 * 1000, // 1 minute
-    MAX_REQUESTS: 5,
-  },
-  AUTH: {
-    WINDOW_MS: 15 * 60 * 1000, // 15 minutes
-    MAX_ATTEMPTS: 5,
-  },
-} as const;
-
-// ==================== PAGINATION ====================
-export const PAGINATION = {
-  DEFAULT_PAGE_SIZE: 20,
-  MAX_PAGE_SIZE: 100,
-  MIN_PAGE_SIZE: 5,
-} as const;
-
-// ==================== CACHE TTL ====================
-export const CACHE_TTL = {
-  SHORT: 60, // 1 minute
-  MEDIUM: 300, // 5 minutes
-  LONG: 3600, // 1 hour
-  DAY: 86400, // 24 hours
-} as const;
-
-// ==================== HTTP STATUS ====================
-export const HTTP_STATUS = {
-  OK: 200,
-  CREATED: 201,
-  NO_CONTENT: 204,
-  BAD_REQUEST: 400,
-  UNAUTHORIZED: 401,
-  FORBIDDEN: 403,
-  NOT_FOUND: 404,
-  CONFLICT: 409,
-  UNPROCESSABLE_ENTITY: 422,
-  TOO_MANY_REQUESTS: 429,
-  INTERNAL_SERVER_ERROR: 500,
-  SERVICE_UNAVAILABLE: 503,
-} as const;
+export {
+  STRING_LENGTH,
+  ARRAY_LIMIT,
+  FILE,
+  REGEX,
+  PASSWORD_REQUIREMENTS,
+  DATE,
+  RATE_LIMIT,
+  PAGINATION,
+  CACHE_TTL,
+  HTTP_STATUS,
+} from './validation';
diff --git a/src/common/constants/validation/array-validation.const.ts b/src/common/constants/validation/array-validation.const.ts
new file mode 100644
index 0000000..e7e6e7f
--- /dev/null
+++ b/src/common/constants/validation/array-validation.const.ts
@@ -0,0 +1,18 @@
+/**
+ * Array Validation Constants
+ *
+ * Maximum limits for array fields to prevent abuse.
+ */
+export const ARRAY_LIMIT = {
+  MAX: {
+    SKILLS_PER_CATEGORY: 20,
+    SKILL_CATEGORIES: 10,
+    EXPERIENCES: 15,
+    EDUCATION: 10,
+    PROJECTS: 20,
+    CERTIFICATIONS: 20,
+    LANGUAGES: 10,
+    AWARDS: 10,
+    RECOMMENDATIONS: 10,
+  },
+} as const;
diff --git a/src/common/constants/validation/file-validation.const.ts b/src/common/constants/validation/file-validation.const.ts
new file mode 100644
index 0000000..d9f922a
--- /dev/null
+++ b/src/common/constants/validation/file-validation.const.ts
@@ -0,0 +1,19 @@
+/**
+ * File Validation Constants
+ *
+ * File upload size limits and allowed MIME types.
+ */
+export const FILE = {
+  MAX_SIZE_MB: 5,
+  MAX_SIZE_BYTES: 5 * 1024 * 1024,
+  ALLOWED_IMAGE_TYPES: [
+    'image/jpeg',
+    'image/png',
+    'image/webp',
+    'image/svg+xml',
+  ],
+  ALLOWED_DOCUMENT_TYPES: [
+    'application/pdf',
+    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
+  ],
+} as const;
diff --git a/src/common/constants/validation/index.ts b/src/common/constants/validation/index.ts
new file mode 100644
index 0000000..d5f023d
--- /dev/null
+++ b/src/common/constants/validation/index.ts
@@ -0,0 +1,17 @@
+/**
+ * Validation Constants - Barrel Export
+ *
+ * Re-exports all validation constants from a single entry point.
+ */
+
+export { STRING_LENGTH } from './string-validation.const';
+
+export { ARRAY_LIMIT } from './array-validation.const';
+
+export { FILE } from './file-validation.const';
+
+export { REGEX, PASSWORD_REQUIREMENTS, DATE } from './regex-patterns.const';
+
+export { RATE_LIMIT } from './rate-limit.const';
+
+export { PAGINATION, CACHE_TTL, HTTP_STATUS } from './pagination.const';
diff --git a/src/common/constants/validation/pagination.const.ts b/src/common/constants/validation/pagination.const.ts
new file mode 100644
index 0000000..89b6664
--- /dev/null
+++ b/src/common/constants/validation/pagination.const.ts
@@ -0,0 +1,42 @@
+/**
+ * Pagination Constants
+ *
+ * Default and limit values for paginated API responses.
+ */
+export const PAGINATION = {
+  DEFAULT_PAGE_SIZE: 20,
+  MAX_PAGE_SIZE: 100,
+  MIN_PAGE_SIZE: 5,
+} as const;
+
+/**
+ * Cache TTL Constants
+ *
+ * Time-to-live values for cached data in seconds.
+ */
+export const CACHE_TTL = {
+  SHORT: 60, // 1 minute
+  MEDIUM: 300, // 5 minutes
+  LONG: 3600, // 1 hour
+  DAY: 86400, // 24 hours
+} as const;
+
+/**
+ * HTTP Status Codes
+ *
+ * Common HTTP status codes for consistent API responses.
+ */
+export const HTTP_STATUS = {
+  OK: 200,
+  CREATED: 201,
+  NO_CONTENT: 204,
+  BAD_REQUEST: 400,
+  UNAUTHORIZED: 401,
+  FORBIDDEN: 403,
+  NOT_FOUND: 404,
+  CONFLICT: 409,
+  UNPROCESSABLE_ENTITY: 422,
+  TOO_MANY_REQUESTS: 429,
+  INTERNAL_SERVER_ERROR: 500,
+  SERVICE_UNAVAILABLE: 503,
+} as const;
diff --git a/src/common/constants/validation/rate-limit.const.ts b/src/common/constants/validation/rate-limit.const.ts
new file mode 100644
index 0000000..252ec55
--- /dev/null
+++ b/src/common/constants/validation/rate-limit.const.ts
@@ -0,0 +1,19 @@
+/**
+ * Rate Limiting Constants
+ *
+ * Configuration for API rate limiting.
+ */
+export const RATE_LIMIT = {
+  API: {
+    WINDOW_MS: 15 * 60 * 1000, // 15 minutes
+    MAX_REQUESTS: 100,
+  },
+  EXPORT: {
+    WINDOW_MS: 60 * 1000, // 1 minute
+    MAX_REQUESTS: 5,
+  },
+  AUTH: {
+    WINDOW_MS: 15 * 60 * 1000, // 15 minutes
+    MAX_ATTEMPTS: 5,
+  },
+} as const;
diff --git a/src/common/constants/validation/regex-patterns.const.ts b/src/common/constants/validation/regex-patterns.const.ts
new file mode 100644
index 0000000..b0888b0
--- /dev/null
+++ b/src/common/constants/validation/regex-patterns.const.ts
@@ -0,0 +1,26 @@
+/**
+ * Regex Patterns for Validation
+ *
+ * Common regular expressions for input validation.
+ */
+export const REGEX = {
+  EMAIL: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
+  URL: /^https?:\/\/.+/,
+  USERNAME: /^[a-zA-Z0-9_-]+$/,
+  PHONE: /^[\d\s\-+()]+$/,
+  HEX_COLOR: /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/,
+  /** At least 1 uppercase, 1 lowercase, 1 number, 1 special char */
+  PASSWORD: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]+$/,
+} as const;
+
+export const PASSWORD_REQUIREMENTS = {
+  MIN_LENGTH: 8,
+  REQUIREMENTS_MESSAGE:
+    'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character (@$!%*?&)',
+} as const;
+
+export const DATE = {
+  MIN_YEAR: 1950,
+  /** Allows up to 10 years in the future */
+  MAX_YEAR: new Date().getFullYear() + 10,
+} as const;
diff --git a/src/common/constants/validation/string-validation.const.ts b/src/common/constants/validation/string-validation.const.ts
new file mode 100644
index 0000000..21906dc
--- /dev/null
+++ b/src/common/constants/validation/string-validation.const.ts
@@ -0,0 +1,22 @@
+/**
+ * String Length Validation Constants
+ *
+ * Minimum and maximum lengths for various string fields.
+ */
+export const STRING_LENGTH = {
+  MIN: {
+    PASSWORD: 8,
+    USERNAME: 3,
+    NAME: 2,
+    DESCRIPTION: 10,
+  },
+  MAX: {
+    EMAIL: 255,
+    USERNAME: 50,
+    NAME: 100,
+    BIO: 500,
+    DESCRIPTION: 2000,
+    TITLE: 200,
+    URL: 2048,
+  },
+} as const;
diff --git a/src/common/decorators/current-user.decorator.ts b/src/common/decorators/current-user.decorator.ts
index 0b5d8ec..b6bf68f 100644
--- a/src/common/decorators/current-user.decorator.ts
+++ b/src/common/decorators/current-user.decorator.ts
@@ -9,6 +9,6 @@ export const CurrentUser = createParamDecorator(
     const request = ctx.switchToHttp().getRequest<AuthenticatedRequest>();
     const user = request.user;
 
-    return data ? user?.[data] : user;
+    return data ? user[data] : user;
   },
 );
diff --git a/src/common/email/email.module.ts b/src/common/email/email.module.ts
index de09916..12c83a2 100644
--- a/src/common/email/email.module.ts
+++ b/src/common/email/email.module.ts
@@ -1,11 +1,12 @@
 import { Module } from '@nestjs/common';
 import { ConfigModule } from '@nestjs/config';
 import { EmailService } from './email.service';
+import { EmailSenderService, EmailTemplateService } from './services';
 import { LoggerModule } from '../logger/logger.module';
 
 @Module({
   imports: [ConfigModule, LoggerModule],
-  providers: [EmailService],
+  providers: [EmailService, EmailSenderService, EmailTemplateService],
   exports: [EmailService],
 })
 export class EmailModule {}
diff --git a/src/common/email/email.service.spec.ts b/src/common/email/email.service.spec.ts
index 60a9ce5..b59a55c 100644
--- a/src/common/email/email.service.spec.ts
+++ b/src/common/email/email.service.spec.ts
@@ -1,25 +1,22 @@
 import { Test, TestingModule } from '@nestjs/testing';
-import { ConfigService } from '@nestjs/config';
-import * as sgMail from '@sendgrid/mail';
 import { EmailService } from './email.service';
-import { AppLoggerService } from '../logger/logger.service';
-
-jest.mock('@sendgrid/mail');
+import { EmailSenderService } from './services/email-sender.service';
+import { EmailTemplateService } from './services/email-template.service';
 
 describe('EmailService', () => {
   let service: EmailService;
-  let configService: ConfigService;
-  let logger: AppLoggerService;
+  let senderService: jest.Mocked<EmailSenderService>;
+  let templateService: jest.Mocked<EmailTemplateService>;
 
-  const mockConfigService = {
-    get: jest.fn(),
+  const mockSenderService = {
+    sendEmail: jest.fn(),
   };
 
-  const mockLogger = {
-    log: jest.fn(),
-    warn: jest.fn(),
-    error: jest.fn(),
-    debug: jest.fn(),
+  const mockTemplateService = {
+    sendVerificationEmail: jest.fn(),
+    sendPasswordResetEmail: jest.fn(),
+    sendWelcomeEmail: jest.fn(),
+    sendPasswordChangedEmail: jest.fn(),
   };
 
   beforeEach(async () => {
@@ -29,420 +26,58 @@ describe('EmailService', () => {
       providers: [
         EmailService,
         {
-          provide: ConfigService,
-          useValue: mockConfigService,
+          provide: EmailSenderService,
+          useValue: mockSenderService,
         },
         {
-          provide: AppLoggerService,
-          useValue: mockLogger,
+          provide: EmailTemplateService,
+          useValue: mockTemplateService,
         },
       ],
     }).compile();
 
-    configService = module.get<ConfigService>(ConfigService);
-    logger = module.get<AppLoggerService>(AppLoggerService);
-  });
-
-  describe('initialization', () => {
-    it('should configure SendGrid when API key is provided', async () => {
-      mockConfigService.get.mockImplementation((key: string) => {
-        switch (key) {
-          case 'SENDGRID_API_KEY':
-            return 'test-api-key';
-          case 'EMAIL_FROM':
-            return 'test@example.com';
-          case 'EMAIL_FROM_NAME':
-            return 'Test App';
-          default:
-            return undefined;
-        }
-      });
-
-      const module: TestingModule = await Test.createTestingModule({
-        providers: [
-          EmailService,
-          {
-            provide: ConfigService,
-            useValue: mockConfigService,
-          },
-          {
-            provide: AppLoggerService,
-            useValue: mockLogger,
-          },
-        ],
-      }).compile();
-
-      const service = module.get<EmailService>(EmailService);
-
-      expect(sgMail.setApiKey).toHaveBeenCalledWith('test-api-key');
-      expect(mockLogger.log).toHaveBeenCalledWith(
-        'SendGrid configured successfully',
-        'EmailService',
-      );
-    });
-
-    it('should warn when API key is not provided', async () => {
-      mockConfigService.get.mockImplementation((key: string) => {
-        if (key === 'SENDGRID_API_KEY') return undefined;
-        if (key === 'EMAIL_FROM') return 'test@example.com';
-        if (key === 'EMAIL_FROM_NAME') return 'Test App';
-        return undefined;
-      });
-
-      const module: TestingModule = await Test.createTestingModule({
-        providers: [
-          EmailService,
-          {
-            provide: ConfigService,
-            useValue: mockConfigService,
-          },
-          {
-            provide: AppLoggerService,
-            useValue: mockLogger,
-          },
-        ],
-      }).compile();
-
-      const service = module.get<EmailService>(EmailService);
-
-      expect(mockLogger.warn).toHaveBeenCalledWith(
-        'SendGrid API key not found. Email sending will be disabled.',
-        'EmailService',
-      );
-    });
-
-    it('should use default values when EMAIL_FROM and EMAIL_FROM_NAME are not provided', async () => {
-      mockConfigService.get.mockImplementation((key: string) => {
-        if (key === 'SENDGRID_API_KEY') return 'test-api-key';
-        return undefined;
-      });
-
-      const module: TestingModule = await Test.createTestingModule({
-        providers: [
-          EmailService,
-          {
-            provide: ConfigService,
-            useValue: mockConfigService,
-          },
-          {
-            provide: AppLoggerService,
-            useValue: mockLogger,
-          },
-        ],
-      }).compile();
-
-      const service = module.get<EmailService>(EmailService);
-
-      expect(sgMail.setApiKey).toHaveBeenCalledWith('test-api-key');
-    });
+    service = module.get<EmailService>(EmailService);
+    senderService = module.get(EmailSenderService);
+    templateService = module.get(EmailTemplateService);
   });
 
   describe('sendEmail', () => {
-    beforeEach(async () => {
-      mockConfigService.get.mockImplementation((key: string) => {
-        switch (key) {
-          case 'SENDGRID_API_KEY':
-            return 'test-api-key';
-          case 'EMAIL_FROM':
-            return 'noreply@test.com';
-          case 'EMAIL_FROM_NAME':
-            return 'Test App';
-          default:
-            return undefined;
-        }
-      });
-
-      const module: TestingModule = await Test.createTestingModule({
-        providers: [
-          EmailService,
-          {
-            provide: ConfigService,
-            useValue: mockConfigService,
-          },
-          {
-            provide: AppLoggerService,
-            useValue: mockLogger,
-          },
-        ],
-      }).compile();
-
-      service = module.get<EmailService>(EmailService);
-    });
-
-    it('should send email successfully', async () => {
-      const mockSend = jest.fn().mockResolvedValue([{ statusCode: 202 }]);
-      (sgMail.send as jest.Mock) = mockSend;
-
-      await service.sendEmail({
-        to: 'user@example.com',
-        subject: 'Test Subject',
-        html: '<p>Test content</p>',
-      });
-
-      expect(mockSend).toHaveBeenCalledWith({
-        to: 'user@example.com',
-        from: {
-          email: 'noreply@test.com',
-          name: 'Test App',
-        },
-        subject: 'Test Subject',
-        html: '<p>Test content</p>',
-        text: 'Test content',
-      });
-
-      expect(mockLogger.log).toHaveBeenCalledWith(
-        'Email sent successfully',
-        'EmailService',
-        {
-          to: 'user@example.com',
-          subject: 'Test Subject',
-        },
-      );
-    });
-
-    it('should use provided text when available', async () => {
-      const mockSend = jest.fn().mockResolvedValue([{ statusCode: 202 }]);
-      (sgMail.send as jest.Mock) = mockSend;
-
-      await service.sendEmail({
+    it('should delegate to senderService', async () => {
+      const options = {
         to: 'user@example.com',
         subject: 'Test Subject',
         html: '<p>Test content</p>',
-        text: 'Custom plain text',
-      });
-
-      expect(mockSend).toHaveBeenCalledWith(
-        expect.objectContaining({
-          text: 'Custom plain text',
-        }),
-      );
-    });
-
-    it('should strip HTML for plain text when text is not provided', async () => {
-      const mockSend = jest.fn().mockResolvedValue([{ statusCode: 202 }]);
-      (sgMail.send as jest.Mock) = mockSend;
-
-      await service.sendEmail({
-        to: 'user@example.com',
-        subject: 'Test Subject',
-        html: '<h1>Title</h1><p>Paragraph content</p><script>alert("xss")</script>',
-      });
-
-      expect(mockSend).toHaveBeenCalledWith(
-        expect.objectContaining({
-          text: expect.not.stringContaining('<'),
-        }),
-      );
-    });
+      };
 
-    it('should handle email sending errors', async () => {
-      const mockError = new Error('SendGrid API error');
-      const mockSend = jest.fn().mockRejectedValue(mockError);
-      (sgMail.send as jest.Mock) = mockSend;
+      mockSenderService.sendEmail.mockResolvedValue(undefined);
 
-      await expect(
-        service.sendEmail({
-          to: 'user@example.com',
-          subject: 'Test Subject',
-          html: '<p>Test content</p>',
-        }),
-      ).rejects.toThrow('SendGrid API error');
+      await service.sendEmail(options);
 
-      expect(mockLogger.error).toHaveBeenCalledWith(
-        'Failed to send email',
-        mockError.stack,
-        'EmailService',
-        expect.objectContaining({
-          to: 'user@example.com',
-          subject: 'Test Subject',
-          error: 'SendGrid API error',
-        }),
-      );
-    });
-
-    it('should skip sending when service is not configured', async () => {
-      mockConfigService.get.mockImplementation((key: string) => {
-        if (key === 'SENDGRID_API_KEY') return undefined;
-        if (key === 'EMAIL_FROM') return 'test@example.com';
-        return undefined;
-      });
-
-      const module: TestingModule = await Test.createTestingModule({
-        providers: [
-          EmailService,
-          {
-            provide: ConfigService,
-            useValue: mockConfigService,
-          },
-          {
-            provide: AppLoggerService,
-            useValue: mockLogger,
-          },
-        ],
-      }).compile();
-
-      const unconfiguredService = module.get<EmailService>(EmailService);
-      const mockSend = jest.fn();
-      (sgMail.send as jest.Mock) = mockSend;
-
-      await unconfiguredService.sendEmail({
-        to: 'user@example.com',
-        subject: 'Test Subject',
-        html: '<p>Test content</p>',
-      });
-
-      expect(mockSend).not.toHaveBeenCalled();
-      expect(mockLogger.warn).toHaveBeenCalledWith(
-        'Email service not configured. Skipping email send.',
-        'EmailService',
-        expect.objectContaining({
-          to: 'user@example.com',
-          subject: 'Test Subject',
-        }),
-      );
+      expect(senderService.sendEmail).toHaveBeenCalledWith(options);
     });
   });
 
   describe('sendVerificationEmail', () => {
-    beforeEach(async () => {
-      mockConfigService.get.mockImplementation((key: string) => {
-        switch (key) {
-          case 'SENDGRID_API_KEY':
-            return 'test-api-key';
-          case 'EMAIL_FROM':
-            return 'noreply@test.com';
-          case 'EMAIL_FROM_NAME':
-            return 'Test App';
-          case 'FRONTEND_URL':
-            return 'https://app.example.com';
-          default:
-            return undefined;
-        }
-      });
-
-      const module: TestingModule = await Test.createTestingModule({
-        providers: [
-          EmailService,
-          {
-            provide: ConfigService,
-            useValue: mockConfigService,
-          },
-          {
-            provide: AppLoggerService,
-            useValue: mockLogger,
-          },
-        ],
-      }).compile();
-
-      service = module.get<EmailService>(EmailService);
-    });
-
-    it('should send verification email with correct URL', async () => {
-      const mockSend = jest.fn().mockResolvedValue([{ statusCode: 202 }]);
-      (sgMail.send as jest.Mock) = mockSend;
+    it('should delegate to templateService', async () => {
+      mockTemplateService.sendVerificationEmail.mockResolvedValue(undefined);
 
       await service.sendVerificationEmail(
         'user@example.com',
         'John Doe',
-        'verification-token-123',
-      );
-
-      expect(mockSend).toHaveBeenCalledWith(
-        expect.objectContaining({
-          to: 'user@example.com',
-          subject: 'Verifique seu email - ProFile',
-          html: expect.stringContaining(
-            'https://app.example.com/auth/verify-email?token=verification-token-123',
-          ),
-        }),
+        'token-123',
       );
-    });
 
-    it('should use default frontend URL when not configured', async () => {
-      mockConfigService.get.mockImplementation((key: string) => {
-        switch (key) {
-          case 'SENDGRID_API_KEY':
-            return 'test-api-key';
-          case 'EMAIL_FROM':
-            return 'noreply@test.com';
-          case 'FRONTEND_URL':
-            return undefined;
-          default:
-            return undefined;
-        }
-      });
-
-      const module: TestingModule = await Test.createTestingModule({
-        providers: [
-          EmailService,
-          {
-            provide: ConfigService,
-            useValue: mockConfigService,
-          },
-          {
-            provide: AppLoggerService,
-            useValue: mockLogger,
-          },
-        ],
-      }).compile();
-
-      const serviceWithDefaults = module.get<EmailService>(EmailService);
-      const mockSend = jest.fn().mockResolvedValue([{ statusCode: 202 }]);
-      (sgMail.send as jest.Mock) = mockSend;
-
-      await serviceWithDefaults.sendVerificationEmail(
+      expect(templateService.sendVerificationEmail).toHaveBeenCalledWith(
         'user@example.com',
         'John Doe',
         'token-123',
       );
-
-      expect(mockSend).toHaveBeenCalledWith(
-        expect.objectContaining({
-          html: expect.stringContaining(
-            'http://localhost:3000/auth/verify-email?token=token-123',
-          ),
-        }),
-      );
     });
   });
 
   describe('sendPasswordResetEmail', () => {
-    beforeEach(async () => {
-      mockConfigService.get.mockImplementation((key: string) => {
-        switch (key) {
-          case 'SENDGRID_API_KEY':
-            return 'test-api-key';
-          case 'EMAIL_FROM':
-            return 'noreply@test.com';
-          case 'EMAIL_FROM_NAME':
-            return 'Test App';
-          case 'FRONTEND_URL':
-            return 'https://app.example.com';
-          default:
-            return undefined;
-        }
-      });
-
-      const module: TestingModule = await Test.createTestingModule({
-        providers: [
-          EmailService,
-          {
-            provide: ConfigService,
-            useValue: mockConfigService,
-          },
-          {
-            provide: AppLoggerService,
-            useValue: mockLogger,
-          },
-        ],
-      }).compile();
-
-      service = module.get<EmailService>(EmailService);
-    });
-
-    it('should send password reset email with correct URL', async () => {
-      const mockSend = jest.fn().mockResolvedValue([{ statusCode: 202 }]);
-      (sgMail.send as jest.Mock) = mockSend;
+    it('should delegate to templateService', async () => {
+      mockTemplateService.sendPasswordResetEmail.mockResolvedValue(undefined);
 
       await service.sendPasswordResetEmail(
         'user@example.com',
@@ -450,106 +85,36 @@ describe('EmailService', () => {
         'reset-token-456',
       );
 
-      expect(mockSend).toHaveBeenCalledWith(
-        expect.objectContaining({
-          to: 'user@example.com',
-          subject: 'Redefinir senha - ProFile',
-          html: expect.stringContaining(
-            'https://app.example.com/auth/reset-password?token=reset-token-456',
-          ),
-        }),
+      expect(templateService.sendPasswordResetEmail).toHaveBeenCalledWith(
+        'user@example.com',
+        'Jane Smith',
+        'reset-token-456',
       );
     });
   });
 
   describe('sendWelcomeEmail', () => {
-    beforeEach(async () => {
-      mockConfigService.get.mockImplementation((key: string) => {
-        switch (key) {
-          case 'SENDGRID_API_KEY':
-            return 'test-api-key';
-          case 'EMAIL_FROM':
-            return 'noreply@test.com';
-          default:
-            return undefined;
-        }
-      });
-
-      const module: TestingModule = await Test.createTestingModule({
-        providers: [
-          EmailService,
-          {
-            provide: ConfigService,
-            useValue: mockConfigService,
-          },
-          {
-            provide: AppLoggerService,
-            useValue: mockLogger,
-          },
-        ],
-      }).compile();
-
-      service = module.get<EmailService>(EmailService);
-    });
-
-    it('should send welcome email', async () => {
-      const mockSend = jest.fn().mockResolvedValue([{ statusCode: 202 }]);
-      (sgMail.send as jest.Mock) = mockSend;
+    it('should delegate to templateService', async () => {
+      mockTemplateService.sendWelcomeEmail.mockResolvedValue(undefined);
 
       await service.sendWelcomeEmail('user@example.com', 'Alex Johnson');
 
-      expect(mockSend).toHaveBeenCalledWith(
-        expect.objectContaining({
-          to: 'user@example.com',
-          subject: 'Bem-vindo ao ProFile! 🎉',
-          html: expect.stringContaining('Alex Johnson'),
-        }),
+      expect(templateService.sendWelcomeEmail).toHaveBeenCalledWith(
+        'user@example.com',
+        'Alex Johnson',
       );
     });
   });
 
   describe('sendPasswordChangedEmail', () => {
-    beforeEach(async () => {
-      mockConfigService.get.mockImplementation((key: string) => {
-        switch (key) {
-          case 'SENDGRID_API_KEY':
-            return 'test-api-key';
-          case 'EMAIL_FROM':
-            return 'noreply@test.com';
-          default:
-            return undefined;
-        }
-      });
-
-      const module: TestingModule = await Test.createTestingModule({
-        providers: [
-          EmailService,
-          {
-            provide: ConfigService,
-            useValue: mockConfigService,
-          },
-          {
-            provide: AppLoggerService,
-            useValue: mockLogger,
-          },
-        ],
-      }).compile();
-
-      service = module.get<EmailService>(EmailService);
-    });
-
-    it('should send password changed notification email', async () => {
-      const mockSend = jest.fn().mockResolvedValue([{ statusCode: 202 }]);
-      (sgMail.send as jest.Mock) = mockSend;
+    it('should delegate to templateService', async () => {
+      mockTemplateService.sendPasswordChangedEmail.mockResolvedValue(undefined);
 
       await service.sendPasswordChangedEmail('user@example.com', 'Sam Wilson');
 
-      expect(mockSend).toHaveBeenCalledWith(
-        expect.objectContaining({
-          to: 'user@example.com',
-          subject: 'Sua senha foi alterada - ProFile',
-          html: expect.stringContaining('Sam Wilson'),
-        }),
+      expect(templateService.sendPasswordChangedEmail).toHaveBeenCalledWith(
+        'user@example.com',
+        'Sam Wilson',
       );
     });
   });
diff --git a/src/common/email/email.service.ts b/src/common/email/email.service.ts
index 174e199..cb05eb0 100644
--- a/src/common/email/email.service.ts
+++ b/src/common/email/email.service.ts
@@ -1,156 +1,65 @@
-import { Injectable } from '@nestjs/common';
-import { ConfigService } from '@nestjs/config';
-import * as sgMail from '@sendgrid/mail';
-import { AppLoggerService } from '../logger/logger.service';
-import { getVerificationEmailTemplate } from './templates/verification.template';
-import { getPasswordResetTemplate } from './templates/password-reset.template';
-import { getWelcomeEmailTemplate } from './templates/welcome.template';
-import { getPasswordChangedTemplate } from './templates/password-changed.template';
+/**
+ * Email Service (Facade)
+ * Delegates to specialized services for email operations
+ */
 
-export interface SendEmailOptions {
-  to: string;
-  subject: string;
-  html: string;
-  text?: string;
-}
+import { Injectable } from '@nestjs/common';
+import {
+  EmailSenderService,
+  type SendEmailOptions,
+} from './services/email-sender.service';
+import { EmailTemplateService } from './services/email-template.service';
 
 @Injectable()
 export class EmailService {
-  private readonly fromEmail: string;
-  private readonly fromName: string;
-  private readonly isConfigured: boolean;
-
   constructor(
-    private readonly configService: ConfigService,
-    private readonly logger: AppLoggerService,
-  ) {
-    const apiKey = this.configService.get<string>('SENDGRID_API_KEY');
-    this.fromEmail =
-      this.configService.get<string>('EMAIL_FROM') || 'noreply@profile.com';
-    this.fromName =
-      this.configService.get<string>('EMAIL_FROM_NAME') || 'ProFile';
-
-    if (apiKey) {
-      sgMail.setApiKey(apiKey);
-      this.isConfigured = true;
-      this.logger.log('SendGrid configured successfully', 'EmailService');
-    } else {
-      this.isConfigured = false;
-      this.logger.warn(
-        'SendGrid API key not found. Email sending will be disabled.',
-        'EmailService',
-      );
-    }
-  }
+    private readonly senderService: EmailSenderService,
+    private readonly templateService: EmailTemplateService,
+  ) {}
 
+  /**
+   * Send email
+   */
   async sendEmail(options: SendEmailOptions): Promise<void> {
-    if (!this.isConfigured) {
-      this.logger.warn(
-        'Email service not configured. Skipping email send.',
-        'EmailService',
-        { to: options.to, subject: options.subject },
-      );
-      return;
-    }
-
-    try {
-      const msg = {
-        to: options.to,
-        from: {
-          email: this.fromEmail,
-          name: this.fromName,
-        },
-        subject: options.subject,
-        html: options.html,
-        text: options.text || this.stripHtml(options.html),
-      };
-
-      await sgMail.send(msg);
-
-      this.logger.log('Email sent successfully', 'EmailService', {
-        to: options.to,
-        subject: options.subject,
-      });
-    } catch (error) {
-      this.logger.error(
-        'Failed to send email',
-        error instanceof Error ? error.stack : 'Unknown error',
-        'EmailService',
-        {
-          to: options.to,
-          subject: options.subject,
-          error: error instanceof Error ? error.message : 'Unknown error',
-        },
-      );
-      throw error;
-    }
+    return this.senderService.sendEmail(options);
   }
 
+  /**
+   * Send verification email
+   */
   async sendVerificationEmail(
     email: string,
     name: string,
     token: string,
   ): Promise<void> {
-    const frontendUrl =
-      this.configService.get<string>('FRONTEND_URL') || 'http://localhost:3000';
-    const verificationUrl = `${frontendUrl}/auth/verify-email?token=${token}`;
-
-    const html = getVerificationEmailTemplate(name, verificationUrl);
-
-    await this.sendEmail({
-      to: email,
-      subject: 'Verifique seu email - ProFile',
-      html,
-    });
+    return this.templateService.sendVerificationEmail(email, name, token);
   }
 
+  /**
+   * Send password reset email
+   */
   async sendPasswordResetEmail(
     email: string,
     name: string,
     token: string,
   ): Promise<void> {
-    const frontendUrl =
-      this.configService.get<string>('FRONTEND_URL') || 'http://localhost:3000';
-    const resetUrl = `${frontendUrl}/auth/reset-password?token=${token}`;
-
-    const html = getPasswordResetTemplate(name, resetUrl);
-
-    await this.sendEmail({
-      to: email,
-      subject: 'Redefinir senha - ProFile',
-      html,
-    });
+    return this.templateService.sendPasswordResetEmail(email, name, token);
   }
 
+  /**
+   * Send welcome email
+   */
   async sendWelcomeEmail(email: string, name: string): Promise<void> {
-    const html = getWelcomeEmailTemplate(name);
-
-    await this.sendEmail({
-      to: email,
-      subject: 'Bem-vindo ao ProFile! 🎉',
-      html,
-    });
-  }
-
-  async sendPasswordChangedEmail(email: string, name: string): Promise<void> {
-    const html = getPasswordChangedTemplate(name);
-
-    await this.sendEmail({
-      to: email,
-      subject: 'Sua senha foi alterada - ProFile',
-      html,
-    });
+    return this.templateService.sendWelcomeEmail(email, name);
   }
 
   /**
-   * Strip HTML tags for plain text version
+   * Send password changed email
    */
-  private stripHtml(html: string): string {
-    return html
-      .replace(/<style[^>]*>.*<\/style>/gm, '')
-      .replace(/<script[^>]*>.*<\/script>/gm, '')
-      .replace(/<[^>]+>/gm, '')
-      .replace(/\s+/g, ' ')
-      .trim();
+  async sendPasswordChangedEmail(email: string, name: string): Promise<void> {
+    return this.templateService.sendPasswordChangedEmail(email, name);
   }
 }
+
+// Re-export types for backward compatibility
+export type { SendEmailOptions };
diff --git a/src/common/email/services/email-sender.service.ts b/src/common/email/services/email-sender.service.ts
new file mode 100644
index 0000000..f0db1e3
--- /dev/null
+++ b/src/common/email/services/email-sender.service.ts
@@ -0,0 +1,104 @@
+/**
+ * Email Sender Service
+ * Handles email sending via SendGrid
+ */
+
+import { Injectable } from '@nestjs/common';
+import { ConfigService } from '@nestjs/config';
+import * as sgMail from '@sendgrid/mail';
+import { AppLoggerService } from '../../logger/logger.service';
+
+export interface SendEmailOptions {
+  to: string;
+  subject: string;
+  html: string;
+  text?: string;
+}
+
+@Injectable()
+export class EmailSenderService {
+  private readonly fromEmail: string;
+  private readonly fromName: string;
+  private readonly isConfigured: boolean;
+
+  constructor(
+    private readonly configService: ConfigService,
+    private readonly logger: AppLoggerService,
+  ) {
+    const apiKey = this.configService.get<string>('SENDGRID_API_KEY');
+    this.fromEmail =
+      this.configService.get<string>('EMAIL_FROM') ?? 'noreply@profile.com';
+    this.fromName =
+      this.configService.get<string>('EMAIL_FROM_NAME') ?? 'ProFile';
+
+    if (apiKey) {
+      sgMail.setApiKey(apiKey);
+      this.isConfigured = true;
+      this.logger.log('SendGrid configured successfully', 'EmailSenderService');
+    } else {
+      this.isConfigured = false;
+      this.logger.warn(
+        'SendGrid API key not found. Email sending will be disabled.',
+        'EmailSenderService',
+      );
+    }
+  }
+
+  /**
+   * Send email via SendGrid
+   */
+  async sendEmail(options: SendEmailOptions): Promise<void> {
+    if (!this.isConfigured) {
+      this.logger.warn(
+        'Email service not configured. Skipping email send.',
+        'EmailSenderService',
+        { to: options.to, subject: options.subject },
+      );
+      return;
+    }
+
+    try {
+      const msg = {
+        to: options.to,
+        from: {
+          email: this.fromEmail,
+          name: this.fromName,
+        },
+        subject: options.subject,
+        html: options.html,
+        text: options.text ?? this.stripHtml(options.html),
+      };
+
+      await sgMail.send(msg);
+
+      this.logger.log('Email sent successfully', 'EmailSenderService', {
+        to: options.to,
+        subject: options.subject,
+      });
+    } catch (error) {
+      this.logger.error(
+        'Failed to send email',
+        error instanceof Error ? error.stack : 'Unknown error',
+        'EmailSenderService',
+        {
+          to: options.to,
+          subject: options.subject,
+          error: error instanceof Error ? error.message : 'Unknown error',
+        },
+      );
+      throw error;
+    }
+  }
+
+  /**
+   * Strip HTML tags for plain text version
+   */
+  private stripHtml(html: string): string {
+    return html
+      .replace(/<style[^>]*>.*<\/style>/gm, '')
+      .replace(/<script[^>]*>.*<\/script>/gm, '')
+      .replace(/<[^>]+>/gm, '')
+      .replace(/\s+/g, ' ')
+      .trim();
+  }
+}
diff --git a/src/common/email/services/email-template.service.ts b/src/common/email/services/email-template.service.ts
new file mode 100644
index 0000000..406b141
--- /dev/null
+++ b/src/common/email/services/email-template.service.ts
@@ -0,0 +1,88 @@
+/**
+ * Email Template Service
+ * Handles email template generation and sending
+ */
+
+import { Injectable } from '@nestjs/common';
+import { ConfigService } from '@nestjs/config';
+import { EmailSenderService } from './email-sender.service';
+import { getVerificationEmailTemplate } from '../templates/verification.template';
+import { getPasswordResetTemplate } from '../templates/password-reset.template';
+import { getWelcomeEmailTemplate } from '../templates/welcome.template';
+import { getPasswordChangedTemplate } from '../templates/password-changed.template';
+
+@Injectable()
+export class EmailTemplateService {
+  constructor(
+    private readonly senderService: EmailSenderService,
+    private readonly configService: ConfigService,
+  ) {}
+
+  /**
+   * Send verification email
+   */
+  async sendVerificationEmail(
+    email: string,
+    name: string,
+    token: string,
+  ): Promise<void> {
+    const frontendUrl =
+      this.configService.get<string>('FRONTEND_URL') ?? 'http://localhost:3000';
+    const verificationUrl = `${frontendUrl}/auth/verify-email?token=${token}`;
+
+    const html = getVerificationEmailTemplate(name, verificationUrl);
+
+    await this.senderService.sendEmail({
+      to: email,
+      subject: 'Verifique seu email - ProFile',
+      html,
+    });
+  }
+
+  /**
+   * Send password reset email
+   */
+  async sendPasswordResetEmail(
+    email: string,
+    name: string,
+    token: string,
+  ): Promise<void> {
+    const frontendUrl =
+      this.configService.get<string>('FRONTEND_URL') ?? 'http://localhost:3000';
+    const resetUrl = `${frontendUrl}/auth/reset-password?token=${token}`;
+
+    const html = getPasswordResetTemplate(name, resetUrl);
+
+    await this.senderService.sendEmail({
+      to: email,
+      subject: 'Redefinir senha - ProFile',
+      html,
+    });
+  }
+
+  /**
+   * Send welcome email
+   */
+  async sendWelcomeEmail(email: string, name: string): Promise<void> {
+    const html = getWelcomeEmailTemplate(name);
+
+    await this.senderService.sendEmail({
+      to: email,
+      subject: 'Bem-vindo ao ProFile! 🎉',
+      html,
+    });
+  }
+
+  /**
+   * Send password changed email
+   */
+  async sendPasswordChangedEmail(email: string, name: string): Promise<void> {
+    const html = getPasswordChangedTemplate(name);
+
+    await this.senderService.sendEmail({
+      to: email,
+      subject: 'Sua senha foi alterada - ProFile',
+      html,
+    });
+  }
+}
diff --git a/src/common/email/services/index.ts b/src/common/email/services/index.ts
new file mode 100644
index 0000000..24aa56b
--- /dev/null
+++ b/src/common/email/services/index.ts
@@ -0,0 +1,9 @@
+/**
+ * Email Services - Barrel Export
+ */
+
+export {
+  EmailSenderService,
+  type SendEmailOptions,
+} from './email-sender.service';
+export { EmailTemplateService } from './email-template.service';
diff --git a/src/common/email/templates/base.template.ts b/src/common/email/templates/base.template.ts
index 97271dc..c090d45 100644
--- a/src/common/email/templates/base.template.ts
+++ b/src/common/email/templates/base.template.ts
@@ -88,8 +88,8 @@ export const getBaseTemplate = (content: string, title: string) => `
     <div class="email-footer">
       <p>&copy; ${new Date().getFullYear()} ProFile. Todos os direitos reservados.</p>
       <p>
-        <a href="${process.env.FRONTEND_URL || 'http://localhost:3000'}">Acessar ProFile</a> |
-        <a href="${process.env.FRONTEND_URL || 'http://localhost:3000'}/help">Ajuda</a>
+        <a href="${process.env.FRONTEND_URL ?? 'http://localhost:3000'}">Acessar ProFile</a> |
+        <a href="${process.env.FRONTEND_URL ?? 'http://localhost:3000'}/help">Ajuda</a>
       </p>
     </div>
   </div>
diff --git a/src/common/email/templates/password-changed.template.ts b/src/common/email/templates/password-changed.template.ts
index ab947cf..9f9b4b4 100644
--- a/src/common/email/templates/password-changed.template.ts
+++ b/src/common/email/templates/password-changed.template.ts
@@ -21,7 +21,7 @@ export const getPasswordChangedTemplate = (name: string): string => {
       </p>
     </div>
     <div style="text-align: center; margin-top: 32px;">
-      <a href="${process.env.FRONTEND_URL || 'http://localhost:3000'}/login" class="btn">
+      <a href="${process.env.FRONTEND_URL ?? 'http://localhost:3000'}/login" class="btn">
         Fazer login
       </a>
     </div>
diff --git a/src/common/email/templates/welcome.template.ts b/src/common/email/templates/welcome.template.ts
index adb5473..0d2741c 100644
--- a/src/common/email/templates/welcome.template.ts
+++ b/src/common/email/templates/welcome.template.ts
@@ -23,13 +23,13 @@ export const getWelcomeEmailTemplate = (name: string): string => {
       <li>🌐 Compartilhar seu portfólio online</li>
     </ul>
     <div style="text-align: center; margin-top: 32px;">
-      <a href="${process.env.FRONTEND_URL || 'http://localhost:3000'}/dashboard" class="btn">
+      <a href="${process.env.FRONTEND_URL ?? 'http://localhost:3000'}/dashboard" class="btn">
         Começar agora
       </a>
     </div>
     <div class="divider"></div>
     <p class="text-muted" style="text-align: center;">
-      Precisa de ajuda? Confira nosso <a href="${process.env.FRONTEND_URL || 'http://localhost:3000'}/help" style="color: #3B82F6;">guia de início rápido</a>
+      Precisa de ajuda? Confira nosso <a href="${process.env.FRONTEND_URL ?? 'http://localhost:3000'}/help" style="color: #3B82F6;">guia de início rápido</a>
     </p>
   `;
 
diff --git a/src/common/guards/roles.guard.ts b/src/common/guards/roles.guard.ts
index 3a9d4c5..5bcd18e 100644
--- a/src/common/guards/roles.guard.ts
+++ b/src/common/guards/roles.guard.ts
@@ -8,21 +8,22 @@ export class RolesGuard implements CanActivate {
   constructor(private reflector: Reflector) {}
 
   canActivate(context: ExecutionContext): boolean {
-    const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>(
-      ROLES_KEY,
-      [context.getHandler(), context.getClass()],
-    );
+    const requiredRoles = this.reflector.getAllAndOverride<
+      UserRole[] | undefined
+    >(ROLES_KEY, [context.getHandler(), context.getClass()]);
 
     if (!requiredRoles) {
       return true;
     }
 
-    const { user } = context.switchToHttp().getRequest();
+    const request = context
+      .switchToHttp()
+      .getRequest<{ user?: { role: UserRole } }>();
 
-    if (!user) {
+    if (!request.user) {
       return false;
     }
 
-    return requiredRoles.some((role) => user.role === role);
+    return requiredRoles.some((role) => request.user.role === role);
   }
 }
diff --git a/src/common/logger/logger.service.ts b/src/common/logger/logger.service.ts
index affe504..0e0a2ff 100644
--- a/src/common/logger/logger.service.ts
+++ b/src/common/logger/logger.service.ts
@@ -10,7 +10,7 @@ export class AppLoggerService implements NestLoggerService {
     const isProduction = process.env.NODE_ENV === 'production';
 
     this.logger = winston.createLogger({
-      level: process.env.LOG_LEVEL || (isProduction ? 'info' : 'debug'),
+      level: process.env.LOG_LEVEL ?? (isProduction ? 'info' : 'debug'),
       format: winston.format.combine(
         winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
         winston.format.errors({ stack: true }),
@@ -29,7 +29,14 @@ export class AppLoggerService implements NestLoggerService {
                   log += ` ${JSON.stringify(meta)}`;
                 }
                 if (stack) {
-                  const stk = String(stack);
+                  let stk: string;
+                  if (typeof stack === 'string') {
+                    stk = stack;
+                  } else if (stack instanceof Error) {
+                    stk = stack.stack ?? stack.message;
+                  } else {
+                    stk = JSON.stringify(stack);
+                  }
                   log += `\n${stk}`;
                 }
                 return log;
diff --git a/src/common/pipes/parse-cuid.pipe.ts b/src/common/pipes/parse-cuid.pipe.ts
index 08ce69d..6671818 100644
--- a/src/common/pipes/parse-cuid.pipe.ts
+++ b/src/common/pipes/parse-cuid.pipe.ts
@@ -1,4 +1,5 @@
 import { PipeTransform, Injectable, BadRequestException } from '@nestjs/common';
+import { ERROR_MESSAGES } from '../constants/app.constants';
 
 /**
  * Validates that a string is a valid CUID (Collision-resistant Unique Identifier).
@@ -10,11 +11,11 @@ export class ParseCuidPipe implements PipeTransform<string, string> {
 
   transform(value: string): string {
     if (!value) {
-      throw new BadRequestException('ID is required');
+      throw new BadRequestException(ERROR_MESSAGES.ID_REQUIRED);
     }
 
     if (typeof value !== 'string') {
-      throw new BadRequestException('ID must be a string');
+      throw new BadRequestException(ERROR_MESSAGES.ID_MUST_BE_STRING);
     }
 
     // Check if it matches CUID format
diff --git a/src/common/pipes/zod-validation.pipe.ts b/src/common/pipes/zod-validation.pipe.ts
deleted file mode 100644
index 538dafd..0000000
--- a/src/common/pipes/zod-validation.pipe.ts
+++ /dev/null
@@ -1,21 +0,0 @@
-import { PipeTransform, Injectable, BadRequestException } from '@nestjs/common';
-import { ZodSchema, ZodError } from 'zod';
-
-@Injectable()
-export class ZodValidationPipe implements PipeTransform {
-  constructor(private schema: ZodSchema) {}
-
-  transform(value: unknown): unknown {
-    try {
-      return this.schema.parse(value);
-    } catch (error) {
-      if (error instanceof ZodError) {
-        throw new BadRequestException({
-          message: 'Validation failed',
-          errors: error.errors,
-        });
-      }
-      throw error;
-    }
-  }
-}
diff --git a/src/common/services/s3-upload.service.ts b/src/common/services/s3-upload.service.ts
index 78ecb6c..15ca4d6 100644
--- a/src/common/services/s3-upload.service.ts
+++ b/src/common/services/s3-upload.service.ts
@@ -21,18 +21,18 @@ export class S3UploadService {
 
     this._isEnabled = !!(endpoint && accessKeyId && secretAccessKey && bucket);
 
-    if (this._isEnabled) {
+    if (this._isEnabled && endpoint && accessKeyId && secretAccessKey) {
       try {
         this.client = new S3Client({
-          endpoint: endpoint!,
+          endpoint,
           region: 'us-east-1', // MinIO requires a region but doesn't use it
           credentials: {
-            accessKeyId: accessKeyId!,
-            secretAccessKey: secretAccessKey!,
+            accessKeyId,
+            secretAccessKey,
           },
           forcePathStyle: true, // Required for MinIO
         });
-        this.bucket = bucket || null;
+        this.bucket = bucket ?? null;
         this.logger.log('MinIO upload service initialized', 'S3UploadService', {
           endpoint,
           bucket,
diff --git a/src/export/__mocks__/puppeteer.mock.ts b/src/export/__mocks__/puppeteer.mock.ts
index df1d0c8..94e8bd4 100644
--- a/src/export/__mocks__/puppeteer.mock.ts
+++ b/src/export/__mocks__/puppeteer.mock.ts
@@ -46,7 +46,9 @@ export const createMockPage = (): MockPage => ({
   pdf: jest.fn().mockResolvedValue(Buffer.from('mock-pdf-content')),
   screenshot: jest.fn().mockResolvedValue(undefined),
   addStyleTag: jest.fn().mockResolvedValue(undefined),
-  content: jest.fn().mockResolvedValue('<html><body><div id="banner"></div></body></html>'),
+  content: jest
+    .fn()
+    .mockResolvedValue('<html><body><div id="banner"></div></body></html>'),
   $: jest.fn().mockResolvedValue(null),
   close: jest.fn().mockResolvedValue(undefined),
 });
diff --git a/src/export/builders/docx-education.builder.ts b/src/export/builders/docx-education.builder.ts
new file mode 100644
index 0000000..de97330
--- /dev/null
+++ b/src/export/builders/docx-education.builder.ts
@@ -0,0 +1,63 @@
+/**
+ * DOCX Education Builder
+ * Builds education section paragraphs for DOCX export
+ */
+
+import { Paragraph, TextRun } from 'docx';
+import { Education } from '@prisma/client';
+
+export class DocxEducationBuilder {
+  create(edu: Education): Paragraph[] {
+    const { startDate, endDate } = this.formatDateRange(edu);
+
+    return [
+      this.createDegreeParagraph(edu),
+      this.createInstitutionParagraph(edu.institution, startDate, endDate),
+    ];
+  }
+
+  private formatDateRange(edu: Education): {
+    startDate: string;
+    endDate: string;
+  } {
+    const startDate = new Date(edu.startDate).toLocaleDateString('en-US', {
+      year: 'numeric',
+      month: 'short',
+    });
+    const endDate = edu.endDate
+      ? new Date(edu.endDate).toLocaleDateString('en-US', {
+          year: 'numeric',
+          month: 'short',
+        })
+      : 'Present';
+
+    return { startDate, endDate };
+  }
+
+  private createDegreeParagraph(edu: Education): Paragraph {
+    return new Paragraph({
+      children: [
+        new TextRun({ text: edu.degree, bold: true }),
+        new TextRun({ text: ` in ${edu.field}` }),
+      ],
+      spacing: { after: 50 },
+    });
+  }
+
+  private createInstitutionParagraph(
+    institution: string,
+    startDate: string,
+    endDate: string,
+  ): Paragraph {
+    return new Paragraph({
+      children: [
+        new TextRun({
+          text: `${institution} | ${startDate} - ${endDate}`,
+          italics: true,
+          color: '595959',
+        }),
+      ],
+      spacing: { after: 200 },
+    });
+  }
+}
diff --git a/src/export/builders/docx-experience.builder.ts b/src/export/builders/docx-experience.builder.ts
new file mode 100644
index 0000000..a430925
--- /dev/null
+++ b/src/export/builders/docx-experience.builder.ts
@@ -0,0 +1,73 @@
+/**
+ * DOCX Experience Builder
+ * Builds experience section paragraphs for DOCX export
+ */
+
+import { Paragraph, TextRun } from 'docx';
+import { Experience } from '@prisma/client';
+
+export class DocxExperienceBuilder {
+  create(exp: Experience): Paragraph[] {
+    const { startDate, endDate } = this.formatDateRange(exp);
+
+    return [
+      this.createPositionParagraph(exp),
+      this.createLocationDateParagraph(exp.location, startDate, endDate),
+      this.createDescriptionParagraph(exp.description),
+    ];
+  }
+
+  private formatDateRange(exp: Experience): {
+    startDate: string;
+    endDate: string;
+  } {
+    const startDate = new Date(exp.startDate).toLocaleDateString('en-US', {
+      year: 'numeric',
+      month: 'short',
+    });
+    const endDate = exp.endDate
+      ? new Date(exp.endDate).toLocaleDateString('en-US', {
+          year: 'numeric',
+          month: 'short',
+        })
+      : 'Present';
+
+    return { startDate, endDate };
+  }
+
+  private createPositionParagraph(exp: Experience): Paragraph {
+    return new Paragraph({
+      children: [
+        new TextRun({ text: exp.position, bold: true }),
+        new TextRun({ text: ` at ${exp.company}`, bold: true }),
+      ],
+      spacing: { after: 50 },
+    });
+  }
+
+  private createLocationDateParagraph(
+    location: string | null,
+    startDate: string,
+    endDate: string,
+  ): Paragraph {
+    return new Paragraph({
+      children: [
+        new TextRun({
+          text: `${location ?? ''} | ${startDate} - ${endDate}`,
+          italics: true,
+          color: '595959',
+        }),
+      ],
+      spacing: { after: 100 },
+    });
+  }
+
+  private createDescriptionParagraph(description: string | null): Paragraph {
+    return new Paragraph({
+      text: description ?? '',
+      bullet: { level: 0 },
+      indent: { left: 720 },
+      spacing: { after: 200 },
+    });
+  }
+}
diff --git a/src/export/builders/docx-header.builder.ts b/src/export/builders/docx-header.builder.ts
new file mode 100644
index 0000000..6fa175c
--- /dev/null
+++ b/src/export/builders/docx-header.builder.ts
@@ -0,0 +1,100 @@
+/**
+ * DOCX Header Builder
+ * Builds document header section for DOCX export
+ */
+
+import {
+  Paragraph,
+  TextRun,
+  HeadingLevel,
+  AlignmentType,
+  Header,
+  PageNumber,
+  BorderStyle,
+} from 'docx';
+
+interface UserHeaderData {
+  displayName: string | null;
+  email: string | null;
+  phone: string | null;
+  website: string | null;
+  linkedin: string | null;
+  github: string | null;
+  bio: string | null;
+}
+
+export class DocxHeaderBuilder {
+  createPageHeader(): Header {
+    return new Header({
+      children: [
+        new Paragraph({
+          alignment: AlignmentType.RIGHT,
+          children: [
+            new TextRun({
+              children: ['Page ', PageNumber.CURRENT],
+              style: 'default',
+            }),
+          ],
+        }),
+      ],
+    });
+  }
+
+  createTitleParagraph(displayName: string | null): Paragraph {
+    return new Paragraph({
+      text: displayName ?? 'Unnamed User',
+      heading: HeadingLevel.TITLE,
+      alignment: AlignmentType.CENTER,
+    });
+  }
+
+  createContactParagraph(user: UserHeaderData): Paragraph {
+    return new Paragraph({
+      alignment: AlignmentType.CENTER,
+      style: 'default',
+      children: [
+        new TextRun(user.email ?? ''),
+        ...(user.phone ? [new TextRun(` | ${user.phone}`)] : []),
+      ],
+    });
+  }
+
+  createLinksParagraph(user: UserHeaderData): Paragraph {
+    return new Paragraph({
+      alignment: AlignmentType.CENTER,
+      style: 'default',
+      children: [
+        ...(user.website ? [new TextRun(user.website)] : []),
+        ...(user.linkedin
+          ? [new TextRun(`${user.website ? ' | ' : ''}${user.linkedin}`)]
+          : []),
+        ...(user.github
+          ? [
+              new TextRun(
+                `${user.website || user.linkedin ? ' | ' : ''}${user.github}`,
+              ),
+            ]
+          : []),
+      ],
+    });
+  }
+
+  createSummaryParagraph(bio: string | null): Paragraph {
+    return new Paragraph({
+      text: bio ?? '',
+      style: 'default',
+      thematicBreak: true,
+    });
+  }
+
+  createSectionHeading(text: string): Paragraph {
+    return new Paragraph({
+      text,
+      heading: HeadingLevel.HEADING_1,
+      border: {
+        bottom: { color: 'auto', space: 1, size: 6, style: BorderStyle.SINGLE },
+      },
+      spacing: { after: 200, before: 300 },
+    });
+  }
+}
diff --git a/src/export/builders/docx-project.builder.ts b/src/export/builders/docx-project.builder.ts
new file mode 100644
index 0000000..ee74485
--- /dev/null
+++ b/src/export/builders/docx-project.builder.ts
@@ -0,0 +1,37 @@
+/**
+ * DOCX Project Builder
+ * Builds project section paragraphs for DOCX export
+ */
+
+import { Paragraph, TextRun } from 'docx';
+import { Project } from '@prisma/client';
+
+export class DocxProjectBuilder {
+  create(proj: Project): Paragraph[] {
+    return [
+      this.createTitleParagraph(proj),
+      this.createDescriptionParagraph(proj.description),
+    ];
+  }
+
+  private createTitleParagraph(proj: Project): Paragraph {
+    return new Paragraph({
+      children: [
+        new TextRun({ text: proj.name, bold: true }),
+        ...(proj.url
+          ? [new TextRun({ text: ` - ${proj.url}`, style: 'Hyperlink' })]
+          : []),
+      ],
+      spacing: { after: 50 },
+    });
+  }
+
+  private createDescriptionParagraph(description: string | null): Paragraph {
+    return new Paragraph({
+      text: description ?? '',
+      bullet: { level: 0 },
+      indent: { left: 720 },
+      spacing: { after: 200 },
+    });
+  }
+}
diff --git a/src/export/builders/docx-skills.builder.ts b/src/export/builders/docx-skills.builder.ts
new file mode 100644
index 0000000..ab080d5
--- /dev/null
+++ b/src/export/builders/docx-skills.builder.ts
@@ -0,0 +1,33 @@
+/**
+ * DOCX Skills and Languages Builder
+ * Builds skills and languages paragraphs for DOCX export
+ */
+
+import { Paragraph, TextRun } from 'docx';
+import { Skill, Language } from '@prisma/client';
+
+export class DocxSkillsBuilder {
+  createSkillsParagraph(skills: Skill[]): Paragraph {
+    return new Paragraph({
+      children: skills.map(
+        (skill, index) =>
+          new TextRun({
+            text: `${skill.name}${index < skills.length - 1 ? ' • ' : ''}`,
+          }),
+      ),
+      spacing: { after: 200 },
+    });
+  }
+
+  createLanguagesParagraph(languages: Language[]): Paragraph {
+    return new Paragraph({
+      children: languages.map(
+        (lang, index) =>
+          new TextRun({
+            text: `${lang.name} (${lang.level})${index < languages.length - 1 ? ' | ' : ''}`,
+          }),
+      ),
+      spacing: { after: 200 },
+    });
+  }
+}
diff --git a/src/export/builders/index.ts b/src/export/builders/index.ts
new file mode 100644
index 0000000..bc11203
--- /dev/null
+++ b/src/export/builders/index.ts
@@ -0,0 +1,9 @@
+/**
+ * DOCX Builders - Barrel Export
+ */
+
+export { DocxHeaderBuilder } from './docx-header.builder';
+export { DocxExperienceBuilder } from './docx-experience.builder';
+export { DocxEducationBuilder } from './docx-education.builder';
+export { DocxProjectBuilder } from './docx-project.builder';
+export { DocxSkillsBuilder } from './docx-skills.builder';
diff --git a/src/export/controllers/export-banner.controller.ts b/src/export/controllers/export-banner.controller.ts
new file mode 100644
index 0000000..29e83c2
--- /dev/null
+++ b/src/export/controllers/export-banner.controller.ts
@@ -0,0 +1,76 @@
+/**
+ * Export Banner Controller
+ * Handles LinkedIn banner export
+ */
+
+import {
+  Controller,
+  Get,
+  Query,
+  UseGuards,
+  StreamableFile,
+  Header,
+  InternalServerErrorException,
+} from '@nestjs/common';
+import {
+  ApiTags,
+  ApiOperation,
+  ApiResponse,
+  ApiBearerAuth,
+  ApiQuery,
+  ApiProduces,
+} from '@nestjs/swagger';
+import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
+import { BannerCaptureService } from '../services/banner-capture.service';
+import { AppLoggerService } from '../../common/logger/logger.service';
+
+@ApiTags('export')
+@ApiBearerAuth('JWT-auth')
+@Controller('export')
+export class ExportBannerController {
+  constructor(
+    private readonly bannerCaptureService: BannerCaptureService,
+    private readonly logger: AppLoggerService,
+  ) {
+    this.logger.setContext(ExportBannerController.name);
+  }
+
+  @UseGuards(JwtAuthGuard)
+  @Get('banner')
+  @Header('Content-Type', 'image/png')
+  @Header('Content-Disposition', 'attachment; filename="linkedin-banner.png"')
+  @ApiOperation({ summary: 'Export LinkedIn banner image' })
+  @ApiProduces('image/png')
+  @ApiQuery({
+    name: 'palette',
+    required: false,
+    description: 'Color palette name',
+  })
+  @ApiQuery({
+    name: 'logo',
+    required: false,
+    description: 'Logo URL to include in banner',
+  })
+  @ApiResponse({ status: 200, description: 'PNG image file' })
+  @ApiResponse({ status: 400, description: 'Failed to generate banner' })
+  @ApiResponse({ status: 401, description: 'Unauthorized' })
+  async exportBanner(
+    @Query('palette') palette?: string,
+    @Query('logo') logoUrl?: string,
+  ): Promise<StreamableFile> {
+    try {
+      const buffer = await this.bannerCaptureService.capture(palette, logoUrl);
+      return new StreamableFile(buffer);
+    } catch (error) {
+      this.logger.errorWithMeta('Failed to generate banner', {
+        palette,
+        logoUrl,
+        error: error instanceof Error ? error.message : String(error),
+        stack: error instanceof Error ? error.stack : undefined,
+      });
+      throw new InternalServerErrorException(
+        'Failed to generate banner. Please try again later.',
+      );
+    }
+  }
+}
diff --git a/src/export/controllers/export-docx.controller.ts b/src/export/controllers/export-docx.controller.ts
new file mode 100644
index 0000000..e08d7c4
--- /dev/null
+++ b/src/export/controllers/export-docx.controller.ts
@@ -0,0 +1,69 @@
+/**
+ * Export DOCX Controller
+ * Handles DOCX resume export
+ */
+
+import {
+  Controller,
+  Get,
+  UseGuards,
+  StreamableFile,
+  Header,
+  InternalServerErrorException,
+} from '@nestjs/common';
+import {
+  ApiTags,
+  ApiOperation,
+  ApiResponse,
+  ApiBearerAuth,
+  ApiProduces,
+} from '@nestjs/swagger';
+import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
+import { ResumeDOCXService } from '../services/resume-docx.service';
+import { CurrentUser } from '../../common/decorators/current-user.decorator';
+import { UserPayload } from '../../auth/interfaces/auth-request.interface';
+import { AppLoggerService } from '../../common/logger/logger.service';
+
+@ApiTags('export')
+@ApiBearerAuth('JWT-auth')
+@Controller('export')
+export class ExportDocxController {
+  constructor(
+    private readonly resumeDOCXService: ResumeDOCXService,
+    private readonly logger: AppLoggerService,
+  ) {
+    this.logger.setContext(ExportDocxController.name);
+  }
+
+  @UseGuards(JwtAuthGuard)
+  @Get('resume/docx')
+  @Header(
+    'Content-Type',
+    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
+  )
+  @Header('Content-Disposition', 'attachment; filename="resume.docx"')
+  @ApiOperation({ summary: 'Export resume as DOCX document' })
+  @ApiProduces(
+    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
+  )
+  @ApiResponse({ status: 200, description: 'DOCX document file' })
+  @ApiResponse({ status: 400, description: 'Failed to generate DOCX' })
+  @ApiResponse({ status: 401, description: 'Unauthorized' })
+  async exportResumeDOCX(
+    @CurrentUser() user: UserPayload,
+  ): Promise<StreamableFile> {
+    try {
+      const buffer = await this.resumeDOCXService.generate(user.userId);
+      return new StreamableFile(buffer);
+    } catch (error) {
+      this.logger.errorWithMeta('Failed to generate DOCX', {
+        userId: user.userId,
+        error: error instanceof Error ? error.message : String(error),
+        stack: error instanceof Error ? error.stack : undefined,
+      });
+      throw new InternalServerErrorException(
+        'Failed to generate DOCX. Please try again later.',
+      );
+    }
+  }
+}
diff --git a/src/export/controllers/export-pdf.controller.ts b/src/export/controllers/export-pdf.controller.ts
new file mode 100644
index 0000000..48adb05
--- /dev/null
+++ b/src/export/controllers/export-pdf.controller.ts
@@ -0,0 +1,92 @@
+/**
+ * Export PDF Controller
+ * Handles PDF resume export
+ */
+
+import {
+  Controller,
+  Get,
+  Query,
+  UseGuards,
+  StreamableFile,
+  Header,
+  InternalServerErrorException,
+} from '@nestjs/common';
+import {
+  ApiTags,
+  ApiOperation,
+  ApiResponse,
+  ApiBearerAuth,
+  ApiQuery,
+  ApiProduces,
+} from '@nestjs/swagger';
+import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
+import { ResumePDFService } from '../services/resume-pdf.service';
+import { CurrentUser } from '../../common/decorators/current-user.decorator';
+import { UserPayload } from '../../auth/interfaces/auth-request.interface';
+import { AppLoggerService } from '../../common/logger/logger.service';
+
+@ApiTags('export')
+@ApiBearerAuth('JWT-auth')
+@Controller('export')
+export class ExportPdfController {
+  constructor(
+    private readonly resumePDFService: ResumePDFService,
+    private readonly logger: AppLoggerService,
+  ) {
+    this.logger.setContext(ExportPdfController.name);
+  }
+
+  @UseGuards(JwtAuthGuard)
+  @Get('resume/pdf')
+  @Header('Content-Type', 'application/pdf')
+  @Header('Content-Disposition', 'attachment; filename="resume.pdf"')
+  @ApiOperation({ summary: 'Export resume as PDF document' })
+  @ApiProduces('application/pdf')
+  @ApiQuery({
+    name: 'palette',
+    required: false,
+    description: 'Color palette name for styling',
+  })
+  @ApiQuery({
+    name: 'lang',
+    required: false,
+    description: 'Language code (e.g., en, pt)',
+  })
+  @ApiQuery({
+    name: 'bannerColor',
+    required: false,
+    description: 'Custom banner color (hex)',
+  })
+  @ApiResponse({ status: 200, description: 'PDF document file' })
+  @ApiResponse({ status: 400, description: 'Failed to generate PDF' })
+  @ApiResponse({ status: 401, description: 'Unauthorized' })
+  async exportResumePDF(
+    @CurrentUser() user: UserPayload,
+    @Query('palette') palette?: string,
+    @Query('lang') lang?: string,
+    @Query('bannerColor') bannerColor?: string,
+  ): Promise<StreamableFile> {
+    try {
+      const buffer = await this.resumePDFService.generate({
+        palette,
+        lang,
+        bannerColor,
+        userId: user.userId,
+      });
+      return new StreamableFile(buffer);
+    } catch (error) {
+      this.logger.errorWithMeta('Failed to generate PDF', {
+        userId: user.userId,
+        palette,
+        lang,
+        bannerColor,
+        error: error instanceof Error ? error.message : String(error),
+        stack: error instanceof Error ? error.stack : undefined,
+      });
+      throw new InternalServerErrorException(
+        'Failed to generate PDF. Please try again later.',
+      );
+    }
+  }
+}
diff --git a/src/export/controllers/index.ts b/src/export/controllers/index.ts
new file mode 100644
index 0000000..b730d8a
--- /dev/null
+++ b/src/export/controllers/index.ts
@@ -0,0 +1,7 @@
+/**
+ * Export Controllers - Barrel Export
+ */
+
+export { ExportBannerController } from './export-banner.controller';
+export { ExportPdfController } from './export-pdf.controller';
+export { ExportDocxController } from './export-docx.controller';
diff --git a/src/export/export.controller.ts b/src/export/export.controller.ts
index 0659a9b..c973967 100644
--- a/src/export/export.controller.ts
+++ b/src/export/export.controller.ts
@@ -5,7 +5,6 @@ import {
   UseGuards,
   StreamableFile,
   Header,
-  BadRequestException,
   InternalServerErrorException,
 } from '@nestjs/common';
 import {
diff --git a/src/export/export.module.ts b/src/export/export.module.ts
index f4cb0ea..6988989 100644
--- a/src/export/export.module.ts
+++ b/src/export/export.module.ts
@@ -1,21 +1,39 @@
 import { Module } from '@nestjs/common';
-import { ExportController } from './export.controller';
+import {
+  ExportBannerController,
+  ExportPdfController,
+  ExportDocxController,
+} from './controllers';
 import { BannerCaptureService } from './services/banner-capture.service';
 import { ResumePDFService } from './services/resume-pdf.service';
 import { BrowserManagerService } from './services/browser-manager.service';
 import { ResumeDOCXService } from './services/resume-docx.service';
+import { DocxBuilderService } from './services/docx-builder.service';
+import { DocxSectionsService } from './services/docx-sections.service';
+import { DocxStylesService } from './services/docx-styles.service';
+import { PdfGeneratorService } from './services/pdf-generator.service';
+import { PdfTemplateService } from './services/pdf-template.service';
 import { ResumesModule } from '../resumes/resumes.module';
 import { UsersModule } from '../users/users.module';
 import { LoggerModule } from '../common/logger/logger.module';
 
 @Module({
   imports: [ResumesModule, UsersModule, LoggerModule],
-  controllers: [ExportController],
+  controllers: [
+    ExportBannerController,
+    ExportPdfController,
+    ExportDocxController,
+  ],
   providers: [
     BannerCaptureService,
     ResumePDFService,
     BrowserManagerService,
     ResumeDOCXService,
+    DocxBuilderService,
+    DocxSectionsService,
+    DocxStylesService,
+    PdfGeneratorService,
+    PdfTemplateService,
   ],
   exports: [
     BannerCaptureService,
diff --git a/src/export/helpers/banner-page-setup.helper.ts b/src/export/helpers/banner-page-setup.helper.ts
new file mode 100644
index 0000000..68eab97
--- /dev/null
+++ b/src/export/helpers/banner-page-setup.helper.ts
@@ -0,0 +1,73 @@
+/**
+ * Banner Page Setup Helper
+ * Handles page configuration and navigation for banner capture
+ */
+
+import { Page } from 'puppeteer';
+import { ConfigService } from '@nestjs/config';
+import { Logger } from '@nestjs/common';
+import {
+  VIEWPORT,
+  TIMEOUT,
+  DEBUG_PATH,
+  DEFAULT,
+} from '../constants/ui.constants';
+
+export class BannerPageSetup {
+  private readonly logger = new Logger(BannerPageSetup.name);
+
+  constructor(private readonly configService: ConfigService) {}
+
+  async setupPage(page: Page): Promise<void> {
+    await page.setViewport({
+      width: VIEWPORT.BANNER.WIDTH,
+      height: VIEWPORT.BANNER.HEIGHT,
+      deviceScaleFactor: VIEWPORT.BANNER.SCALE_FACTOR,
+    });
+  }
+
+  buildBannerUrl(palette: string, logoUrl: string): string {
+    const host =
+      this.configService.get<string>('FRONTEND_HOST') ?? DEFAULT.HOST;
+    const port =
+      this.configService.get<number>('FRONTEND_PORT') ?? DEFAULT.PORT;
+
+    let url = `http://${host}:${port}/?palette=${encodeURIComponent(palette)}`;
+    if (logoUrl) {
+      url += `&logo=${encodeURIComponent(logoUrl)}`;
+    }
+    return url;
+  }
+
+  async navigateToPage(page: Page, url: string): Promise<void> {
+    try {
+      await page.goto(url, {
+        waitUntil: 'domcontentloaded',
+        timeout: TIMEOUT.PAGE_LOAD,
+      });
+    } catch (err) {
+      await page.screenshot({ path: DEBUG_PATH.BANNER_GOTO_ERROR });
+      this.logger.error('[BannerCapture] Error during page.goto:', err);
+      throw err;
+    }
+
+    await page.screenshot({ path: DEBUG_PATH.BANNER_AFTER_GOTO });
+    await page.content();
+    this.logger.debug('[BannerCapture] HTML after goto');
+  }
+
+  async applyQualityStyles(page: Page): Promise<void> {
+    await page.addStyleTag({
+      content: `
+        #banner, #banner * {
+          -webkit-font-smoothing: antialiased !important;
+          -moz-osx-font-smoothing: grayscale !important;
+          text-rendering: optimizeLegibility !important;
+          image-rendering: -webkit-optimize-contrast !important;
+          image-rendering: crisp-edges !important;
+          image-rendering: pixelated !important;
+        }
+      `,
+    });
+  }
+}
diff --git a/src/export/helpers/banner-ready-waiter.helper.ts b/src/export/helpers/banner-ready-waiter.helper.ts
new file mode 100644
index 0000000..f2ba548
--- /dev/null
+++ b/src/export/helpers/banner-ready-waiter.helper.ts
@@ -0,0 +1,80 @@
+/**
+ * Banner Ready Waiter Helper
+ * Waits for banner elements to render completely
+ */
+
+import { Page } from 'puppeteer';
+import { Logger } from '@nestjs/common';
+import { TIMEOUT, DEBUG_PATH } from '../constants/ui.constants';
+import { API_LIMITS } from '../../common/constants/app.constants';
+
+export class BannerReadyWaiter {
+  private readonly logger = new Logger(BannerReadyWaiter.name);
+
+  async waitForBannerReady(page: Page, logoUrl: string): Promise<void> {
+    await this.waitForBannerElement(page);
+    await page.evaluateHandle('document.fonts.ready');
+
+    if (logoUrl) {
+      await this.waitForLogo(page);
+    }
+
+    await this.waitForCodeBlock(page);
+  }
+
+  private async waitForBannerElement(page: Page): Promise<void> {
+    try {
+      await page.waitForSelector('#banner', { timeout: TIMEOUT.SELECTOR_WAIT });
+    } catch (err) {
+      await this.debugBannerError(page);
+      throw err;
+    }
+  }
+
+  private async debugBannerError(page: Page): Promise<void> {
+    await page.screenshot({ path: DEBUG_PATH.BANNER_WAIT_ERROR });
+    const html = await page.content();
+
+    const bannerMatch = html.match(
+      /<section[^>]*id=["']banner["'][^>]*>([\s\S]*?)<\/section>/i,
+    );
+    if (bannerMatch) {
+      this.logger.error('[BannerCapture] #banner HTML snippet found');
+    } else {
+      const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
+      this.logger.error(
+        '[BannerCapture] <body> HTML snippet:',
+        bodyMatch
+          ? bodyMatch[1].slice(0, API_LIMITS.MAX_DEBUG_CHARS)
+          : html.slice(0, API_LIMITS.MAX_DEBUG_CHARS),
+      );
+    }
+  }
+
+  private async waitForLogo(page: Page): Promise<void> {
+    await page.waitForSelector('#company-logo', { timeout: TIMEOUT.LOGO_LOAD });
+    await page.waitForFunction(
+      () => {
+        const img = document.getElementById(
+          'company-logo',
+        ) as HTMLImageElement | null;
+        return img ? img.complete && img.naturalWidth > 0 : true;
+      },
+      { timeout: TIMEOUT.LOGO_LOAD },
+    );
+  }
+
+  private async waitForCodeBlock(page: Page): Promise<void> {
+    await page.screenshot({ path: DEBUG_PATH.BANNER_BEFORE_CODE });
+
+    await page.waitForFunction(
+      () => {
+        const code = document.getElementById('code');
+        return code && code.innerHTML.trim().length > 0;
+      },
+      { timeout: TIMEOUT.CODE_BLOCK_RENDER },
+    );
+
+    await page.screenshot({ path: DEBUG_PATH.BANNER_AFTER_CODE });
+  }
+}
diff --git a/src/export/helpers/index.ts b/src/export/helpers/index.ts
new file mode 100644
index 0000000..ca18fa2
--- /dev/null
+++ b/src/export/helpers/index.ts
@@ -0,0 +1,11 @@
+/**
+ * Export Helpers - Barrel Export
+ */
+
+export { PdfPageSetup, type ResumePDFOptions } from './pdf-page-setup.helper';
+export {
+  PdfStyleExtractor,
+  type ExtractedStyles,
+} from './pdf-style-extractor.helper';
+export { BannerPageSetup } from './banner-page-setup.helper';
+export { BannerReadyWaiter } from './banner-ready-waiter.helper';
diff --git a/src/export/helpers/pdf-page-setup.helper.ts b/src/export/helpers/pdf-page-setup.helper.ts
new file mode 100644
index 0000000..90d2002
--- /dev/null
+++ b/src/export/helpers/pdf-page-setup.helper.ts
@@ -0,0 +1,75 @@
+/**
+ * PDF Page Setup Helper
+ * Handles Puppeteer page configuration and navigation
+ */
+
+import { Page } from 'puppeteer';
+import { ConfigService } from '@nestjs/config';
+import { Logger } from '@nestjs/common';
+import {
+  VIEWPORT,
+  TIMEOUT,
+  DEBUG_PATH,
+  DEFAULT,
+} from '../constants/ui.constants';
+
+export interface ResumePDFOptions {
+  palette?: string;
+  lang?: string;
+  bannerColor?: string;
+  userId?: string;
+}
+
+export class PdfPageSetup {
+  private readonly logger = new Logger(PdfPageSetup.name);
+
+  constructor(private readonly configService: ConfigService) {}
+
+  async setupPage(page: Page): Promise<void> {
+    await page.setViewport({
+      width: VIEWPORT.RESUME.WIDTH,
+      height: VIEWPORT.RESUME.HEIGHT,
+      deviceScaleFactor: VIEWPORT.RESUME.SCALE_FACTOR,
+    });
+  }
+
+  buildResumeUrl(options: ResumePDFOptions): string {
+    const {
+      palette = DEFAULT.PALETTE,
+      lang = DEFAULT.LANGUAGE,
+      bannerColor,
+      userId,
+    } = options;
+    const host =
+      this.configService.get<string>('FRONTEND_HOST') ?? DEFAULT.HOST;
+    const port =
+      this.configService.get<number>('FRONTEND_PORT') ?? DEFAULT.PORT;
+
+    let url = `http://${host}:${port}/protected/resume?export=1&palette=${encodeURIComponent(palette)}&lang=${encodeURIComponent(lang)}`;
+
+    if (bannerColor) url += `&bannerColor=${encodeURIComponent(bannerColor)}`;
+    if (userId) url += `&user=${encodeURIComponent(userId)}`;
+
+    return url;
+  }
+
+  async navigateToPage(page: Page, url: string): Promise<void> {
+    try {
+      await page.goto(url, {
+        waitUntil: 'domcontentloaded',
+        timeout: TIMEOUT.PAGE_LOAD,
+      });
+    } catch (err) {
+      await page.screenshot({ path: DEBUG_PATH.RESUME_GOTO_ERROR });
+      this.logger.error('[ResumePDF] Error during page.goto:', err);
+      throw err;
+    }
+  }
+
+  async waitForResumeReady(page: Page): Promise<void> {
+    await page.waitForSelector('#resume', { timeout: TIMEOUT.SELECTOR_WAIT });
+    await page.waitForSelector('#resume[data-ready="1"]', {
+      timeout: TIMEOUT.SELECTOR_WAIT,
+    });
+  }
+}
diff --git a/src/export/helpers/pdf-style-extractor.helper.ts b/src/export/helpers/pdf-style-extractor.helper.ts
new file mode 100644
index 0000000..095e328
--- /dev/null
+++ b/src/export/helpers/pdf-style-extractor.helper.ts
@@ -0,0 +1,95 @@
+/**
+ * PDF Style Extractor
+ * Extracts styles and renders clean page for PDF generation
+ */
+
+import { Page } from 'puppeteer';
+import { TIMEOUT } from '../constants/ui.constants';
+
+export interface ExtractedStyles {
+  linkTags: string[];
+  styleTags: string[];
+  resumeHTML: string;
+  cssVars: string;
+}
+
+export class PdfStyleExtractor {
+  async extractStyles(page: Page): Promise<ExtractedStyles> {
+    return await page.evaluate(() => {
+      const linkTags = Array.from(
+        document.querySelectorAll('head link[rel="stylesheet"]'),
+      ).map((l) => (l as HTMLLinkElement).outerHTML);
+
+      const styleTags = Array.from(document.querySelectorAll('head style')).map(
+        (s) => (s as HTMLStyleElement).outerHTML,
+      );
+
+      const resumeEl = document.querySelector('#resume');
+      const rootStyle = document.documentElement.style;
+      const varNames = Array.from(rootStyle).filter((n) => n.startsWith('--'));
+      const cssVars = varNames
+        .map((name) => `${name}: ${rootStyle.getPropertyValue(name)};`)
+        .join(' ');
+
+      return {
+        linkTags,
+        styleTags,
+        resumeHTML: resumeEl ? resumeEl.outerHTML : '',
+        cssVars,
+      };
+    });
+  }
+
+  async renderCleanPage(
+    page: Page,
+    pageUrl: string,
+    styles: ExtractedStyles,
+  ): Promise<void> {
+    const origin = new URL(pageUrl).origin;
+    const { linkTags, styleTags, resumeHTML, cssVars } = styles;
+
+    await page.setContent(
+      this.buildCleanHtml(origin, linkTags, styleTags, resumeHTML, cssVars),
+      {
+        waitUntil: 'domcontentloaded',
+      },
+    );
+
+    await page.emulateMediaType('print');
+    await page.evaluateHandle('document.fonts.ready');
+    await new Promise((resolve) => setTimeout(resolve, TIMEOUT.FONT_READY));
+  }
+
+  private buildCleanHtml(
+    origin: string,
+    linkTags: string[],
+    styleTags: string[],
+    resumeHTML: string,
+    cssVars: string,
+  ): string {
+    return `<!doctype html>
+      <html>
+        <head>
+          <base href="${origin}">
+          ${linkTags.join('\n')}
+          ${styleTags.join('\n')}
+          <style>
+            :root { ${cssVars} }
+            html, body { margin: 0 !important; padding: 0 !important; background: #fff !important; }
+            * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
+            @page { margin: 0; }
+            [data-no-print] { display: none !important; visibility: hidden !important; }
+            #resume, #resume * { break-inside: avoid; page-break-inside: avoid; }
+            #resume .bg-\\[var\\(--accent\\)\\], #resume .bg-\\[var\\(--accent\\)\\] * { color: #fff !important; }
+            #resume a, #resume a:visited, #resume a:active { text-decoration: none !important; outline: none !important; box-shadow: none !important; }
+            #resume *:focus { outline: none !important; box-shadow: none !important; }
+            #resume [class*="ring-"], #resume [class*="focus:ring-"] { box-shadow: none !important; }
+            #resume [class*="border-b"] { border-right: 0 !important; }
+          </style>
+        </head>
+        <body>
+          ${resumeHTML}
+        </body>
+      </html>`;
+  }
+}
diff --git a/src/export/services/banner-capture.service.spec.ts b/src/export/services/banner-capture.service.spec.ts
index fcb2c83..9bdedb9 100644
--- a/src/export/services/banner-capture.service.spec.ts
+++ b/src/export/services/banner-capture.service.spec.ts
@@ -1,6 +1,3 @@
-/* eslint-disable @typescript-eslint/no-unsafe-assignment */
-/* eslint-disable @typescript-eslint/no-unsafe-member-access */
-/* eslint-disable @typescript-eslint/unbound-method */
 import { Test, TestingModule } from '@nestjs/testing';
 import { ConfigService } from '@nestjs/config';
 import { BannerCaptureService } from './banner-capture.service';
diff --git a/src/export/services/banner-capture.service.ts b/src/export/services/banner-capture.service.ts
index 9392beb..439017d 100644
--- a/src/export/services/banner-capture.service.ts
+++ b/src/export/services/banner-capture.service.ts
@@ -1,37 +1,29 @@
 /**
- * Banner Capture Service - Single Responsibility Pattern
- *
- * Single Responsibility:
- * - Capture screenshots of banners in high quality
- * - Configure viewport and wait for complete rendering
- * - Return PNG buffer of rendered banner
- *
- * Uncle Bob: "Do one thing and do it well"
+ * Banner Capture Service
+ * Captures screenshots of banners in high quality
  */
 
 import { Injectable, Logger } from '@nestjs/common';
 import { Page } from 'puppeteer';
 import { BrowserManagerService } from './browser-manager.service';
-import {
-  VIEWPORT,
-  TIMEOUT,
-  DEBUG_PATH,
-  DEFAULT,
-} from '../constants/ui.constants';
+import { BannerPageSetup, BannerReadyWaiter } from '../helpers';
 import { ConfigService } from '@nestjs/config';
+import { DEFAULT } from '../constants/ui.constants';
 
 @Injectable()
 export class BannerCaptureService {
   private readonly logger = new Logger(BannerCaptureService.name);
+  private readonly pageSetup: BannerPageSetup;
+  private readonly readyWaiter: BannerReadyWaiter;
 
   constructor(
     private readonly browserManager: BrowserManagerService,
     private readonly configService: ConfigService,
-  ) {}
+  ) {
+    this.pageSetup = new BannerPageSetup(configService);
+    this.readyWaiter = new BannerReadyWaiter();
+  }
 
-  /**
-   * Captures banner screenshot in high quality
-   */
   async capture(
     palette: string = DEFAULT.PALETTE,
     logoUrl: string = '',
@@ -40,167 +32,17 @@ export class BannerCaptureService {
     const page = await browser.newPage();
 
     try {
-      await this.setupPage(page);
-      const url = this.buildBannerUrl(palette, logoUrl);
-      await this.navigateToPage(page, url);
-      await this.waitForBannerReady(page, logoUrl);
-      await this.applyQualityStyles(page);
+      await this.pageSetup.setupPage(page);
+      const url = this.pageSetup.buildBannerUrl(palette, logoUrl);
+      await this.pageSetup.navigateToPage(page, url);
+      await this.readyWaiter.waitForBannerReady(page, logoUrl);
+      await this.pageSetup.applyQualityStyles(page);
       return await this.captureBannerElement(page);
     } finally {
       await page.close();
     }
   }
 
-  /**
-   * Configures viewport in high resolution
-   */
-  private async setupPage(page: Page): Promise<void> {
-    await page.setViewport({
-      width: VIEWPORT.BANNER.WIDTH,
-      height: VIEWPORT.BANNER.HEIGHT,
-      deviceScaleFactor: VIEWPORT.BANNER.SCALE_FACTOR,
-    });
-  }
-
-  /**
-   * Builds banner URL
-   */
-  private buildBannerUrl(palette: string, logoUrl: string): string {
-    const host =
-      this.configService.get<string>('FRONTEND_HOST') || DEFAULT.HOST;
-    const port =
-      this.configService.get<number>('FRONTEND_PORT') || DEFAULT.PORT;
-
-    let url = `http://${host}:${port}/?palette=${encodeURIComponent(palette)}`;
-    if (logoUrl) {
-      url += `&logo=${encodeURIComponent(logoUrl)}`;
-    }
-    return url;
-  }
-
-  /**
-   * Navigates to banner page with error handling
-   */
-  private async navigateToPage(page: Page, url: string): Promise<void> {
-    try {
-      await page.goto(url, {
-        waitUntil: 'domcontentloaded',
-        timeout: TIMEOUT.PAGE_LOAD,
-      });
-    } catch (err) {
-      await page.screenshot({ path: DEBUG_PATH.BANNER_GOTO_ERROR });
-      this.logger.error('[BannerCapture] Error during page.goto:', err);
-      throw err;
-    }
-
-    // DEBUG: Screenshot and log after navigation
-    await page.screenshot({ path: DEBUG_PATH.BANNER_AFTER_GOTO });
-    await page.content(); // Ensure page content is ready
-    this.logger.debug('[BannerCapture] HTML after goto');
-  }
-
-  /**
-   * Waits for complete banner rendering
-   */
-  private async waitForBannerReady(page: Page, logoUrl: string): Promise<void> {
-    // Wait for #banner element
-    try {
-      await page.waitForSelector('#banner', { timeout: TIMEOUT.SELECTOR_WAIT });
-    } catch (err) {
-      await this.debugBannerError(page);
-      throw err;
-    }
-
-    // Wait for fonts to load
-    await page.evaluateHandle('document.fonts.ready');
-
-    // Wait for logo if exists
-    if (logoUrl) {
-      await this.waitForLogo(page);
-    }
-
-    // Wait for code block to render
-    await this.waitForCodeBlock(page);
-  }
-
-  /**
-   * Debug when #banner is not found
-   */
-  private async debugBannerError(page: Page): Promise<void> {
-    await page.screenshot({ path: DEBUG_PATH.BANNER_WAIT_ERROR });
-    const html = await page.content();
-
-    const bannerMatch = html.match(
-      /<section[^>]*id=["']banner["'][^>]*>([\s\S]*?)<\/section>/i,
-    );
-    if (bannerMatch) {
-      this.logger.error('[BannerCapture] #banner HTML snippet found');
-    } else {
-      const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
-      this.logger.error(
-        '[BannerCapture] <body> HTML snippet:',
-        bodyMatch ? bodyMatch[1].slice(0, 1000) : html.slice(0, 1000),
-      );
-    }
-  }
-
-  /**
-   * Waits for logo to load completely
-   */
-  private async waitForLogo(page: Page): Promise<void> {
-    await page.waitForSelector('#company-logo', { timeout: TIMEOUT.LOGO_LOAD });
-    await page.waitForFunction(
-      () => {
-        const img = document.getElementById(
-          'company-logo',
-        ) as HTMLImageElement | null;
-        return img ? img.complete && img.naturalWidth > 0 : true;
-      },
-      { timeout: TIMEOUT.LOGO_LOAD },
-    );
-  }
-
-  /**
-   * Waits for code block to render
-   */
-  private async waitForCodeBlock(page: Page): Promise<void> {
-    // DEBUG: Screenshot and log before
-    await page.screenshot({ path: DEBUG_PATH.BANNER_BEFORE_CODE });
-
-    // Wait for content to render
-    await page.waitForFunction(
-      () => {
-        const code = document.getElementById('code');
-        return code && code.innerHTML.trim().length > 0;
-      },
-      { timeout: TIMEOUT.CODE_BLOCK_RENDER },
-    );
-
-    // DEBUG: Screenshot and log after
-    await page.screenshot({ path: DEBUG_PATH.BANNER_AFTER_CODE });
-  }
-
-  /**
-   * Applies quality styles (antialiasing)
-   */
-  private async applyQualityStyles(page: Page): Promise<void> {
-    await page.addStyleTag({
-      content: `
-        #banner, #banner * {
-          -webkit-font-smoothing: antialiased !important;
-          -moz-osx-font-smoothing: grayscale !important;
-          text-rendering: optimizeLegibility !important;
-          image-rendering: -webkit-optimize-contrast !important;
-          image-rendering: crisp-edges !important;
-          image-rendering: pixelated !important;
-        }
-      `,
-    });
-  }
-
-  /**
-   * Captures screenshot of #banner element
-   */
   private async captureBannerElement(page: Page): Promise<Buffer> {
     const banner = await page.$('#banner');
     if (!banner) {
diff --git a/src/export/services/browser-manager.service.spec.ts b/src/export/services/browser-manager.service.spec.ts
index eb8bae2..ebf330e 100644
--- a/src/export/services/browser-manager.service.spec.ts
+++ b/src/export/services/browser-manager.service.spec.ts
@@ -51,7 +51,9 @@ describe('BrowserManagerService', () => {
       const error = new Error('Browser launch failed');
       (puppeteer.launch as jest.Mock).mockRejectedValueOnce(error);
 
-      await expect(service.getBrowser()).rejects.toThrow('Browser launch failed');
+      await expect(service.getBrowser()).rejects.toThrow(
+        'Browser launch failed',
+      );
     });
   });
 
diff --git a/src/export/services/docx-builder.service.ts b/src/export/services/docx-builder.service.ts
new file mode 100644
index 0000000..5cfea25
--- /dev/null
+++ b/src/export/services/docx-builder.service.ts
@@ -0,0 +1,70 @@
+/**
+ * DOCX Builder Service
+ * Orchestrates DOCX document generation
+ */
+
+import { Injectable, NotFoundException } from '@nestjs/common';
+import { Document, Packer } from 'docx';
+import { ResumesRepository } from '../../resumes/resumes.repository';
+import { UsersRepository } from '../../users/users.repository';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
+import { DocxSectionsService } from './docx-sections.service';
+import { DocxStylesService } from './docx-styles.service';
+import {
+  Resume,
+  Experience,
+  Education,
+  Skill,
+  Project,
+  Language,
+} from '@prisma/client';
+
+type FullResume = Resume & {
+  experiences: Experience[];
+  education: Education[];
+  skills: Skill[];
+  projects: Project[];
+  languages: Language[];
+};
+
+@Injectable()
+export class DocxBuilderService {
+  constructor(
+    private readonly resumesRepository: ResumesRepository,
+    private readonly usersRepository: UsersRepository,
+    private readonly sectionsService: DocxSectionsService,
+    private readonly stylesService: DocxStylesService,
+  ) {}
+
+  /**
+   * Generate DOCX document for user resume
+   */
+  async generate(userId: string): Promise<Buffer> {
+    const { user, resume } = await this.loadUserAndResume(userId);
+
+    const doc = new Document({
+      sections: [this.sectionsService.createMainSection(user, resume)],
+      styles: this.stylesService.getDocumentStyles(),
+    });
+
+    return Packer.toBuffer(doc);
+  }
+
+  /**
+   * Load user and resume data
+   */
+  private async loadUserAndResume(userId: string) {
+    const user = await this.usersRepository.getUser(userId);
+    if (!user) {
+      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
+    }
+
+    const resumeData = await this.resumesRepository.findByUserId(userId);
+    if (!resumeData) {
+      throw new NotFoundException(ERROR_MESSAGES.RESUME_NOT_FOUND_FOR_USER);
+    }
+
+    const resume = resumeData as FullResume;
+    return { user, resume };
+  }
+}
diff --git a/src/export/services/docx-sections.service.ts b/src/export/services/docx-sections.service.ts
new file mode 100644
index 0000000..611e715
--- /dev/null
+++ b/src/export/services/docx-sections.service.ts
@@ -0,0 +1,89 @@
+/**
+ * DOCX Sections Service
+ * Handles section creation for DOCX exports
+ */
+
+import { Injectable } from '@nestjs/common';
+import { SectionType, ISectionOptions } from 'docx';
+import {
+  DocxHeaderBuilder,
+  DocxExperienceBuilder,
+  DocxEducationBuilder,
+  DocxProjectBuilder,
+  DocxSkillsBuilder,
+} from '../builders';
+import {
+  Resume,
+  Experience,
+  Education,
+  Skill,
+  Project,
+  Language,
+} from '@prisma/client';
+
+type FullResume = Resume & {
+  experiences: Experience[];
+  education: Education[];
+  skills: Skill[];
+  projects: Project[];
+  languages: Language[];
+};
+
+type User = {
+  displayName: string | null;
+  bio: string | null;
+  email: string | null;
+  phone: string | null;
+  location: string | null;
+  linkedin: string | null;
+  github: string | null;
+  website: string | null;
+};
+
+@Injectable()
+export class DocxSectionsService {
+  private readonly headerBuilder = new DocxHeaderBuilder();
+  private readonly experienceBuilder = new DocxExperienceBuilder();
+  private readonly educationBuilder = new DocxEducationBuilder();
+  private readonly projectBuilder = new DocxProjectBuilder();
+  private readonly skillsBuilder = new DocxSkillsBuilder();
+
+  /**
+   * Create main section with all resume content
+   */
+  createMainSection(user: User, resume: FullResume): ISectionOptions {
+    return {
+      headers: { default: this.headerBuilder.createPageHeader() },
+      properties: {
+        type: SectionType.NEXT_PAGE,
+        page: {
+          margin: {
+            top: '0.5in',
+            right: '0.5in',
+            bottom: '0.5in',
+            left: '0.5in',
+          },
+        },
+      },
+      children: [
+        this.headerBuilder.createTitleParagraph(user.displayName),
+        this.headerBuilder.createContactParagraph(user),
+        this.headerBuilder.createLinksParagraph(user),
+        this.headerBuilder.createSectionHeading('Summary'),
+        this.headerBuilder.createSummaryParagraph(user.bio),
+        this.headerBuilder.createSectionHeading('Experience'),
+        ...resume.experiences.flatMap((exp) =>
+          this.experienceBuilder.create(exp),
+        ),
+        this.headerBuilder.createSectionHeading('Education'),
+        ...resume.education.flatMap((edu) => this.educationBuilder.create(edu)),
+        this.headerBuilder.createSectionHeading('Skills'),
+        this.skillsBuilder.createSkillsParagraph(resume.skills),
+        this.headerBuilder.createSectionHeading('Projects'),
+        ...resume.projects.flatMap((proj) => this.projectBuilder.create(proj)),
+        this.headerBuilder.createSectionHeading('Languages'),
+        this.skillsBuilder.createLanguagesParagraph(resume.languages),
+      ],
+    };
+  }
+}
diff --git a/src/export/services/docx-styles.service.ts b/src/export/services/docx-styles.service.ts
new file mode 100644
index 0000000..90a066d
--- /dev/null
+++ b/src/export/services/docx-styles.service.ts
@@ -0,0 +1,27 @@
+/**
+ * DOCX Styles Service
+ * Handles document styling for DOCX exports
+ */
+
+import { Injectable } from '@nestjs/common';
+
+@Injectable()
+export class DocxStylesService {
+  /**
+   * Get document styles configuration
+   */
+  getDocumentStyles() {
+    return {
+      paragraphStyles: [
+        {
+          id: 'default',
+          name: 'Default',
+          basedOn: 'Normal',
+          next: 'Normal',
+          quickFormat: true,
+          run: { font: 'Calibri', size: 22 },
+        },
+      ],
+    };
+  }
+}
diff --git a/src/export/services/pdf-generator.service.ts b/src/export/services/pdf-generator.service.ts
new file mode 100644
index 0000000..61bcec7
--- /dev/null
+++ b/src/export/services/pdf-generator.service.ts
@@ -0,0 +1,74 @@
+/**
+ * PDF Generator Service
+ * Core PDF generation logic
+ */
+
+import { Injectable, Logger } from '@nestjs/common';
+import { Page } from 'puppeteer';
+import { BrowserManagerService } from './browser-manager.service';
+import { PdfTemplateService } from './pdf-template.service';
+import { ResumePDFOptions } from '../helpers';
+
+@Injectable()
+export class PdfGeneratorService {
+  private readonly logger = new Logger(PdfGeneratorService.name);
+
+  constructor(
+    private readonly browserManager: BrowserManagerService,
+    private readonly templateService: PdfTemplateService,
+  ) {}
+
+  /**
+   * Generate PDF from resume
+   */
+  async generate(options: ResumePDFOptions = {}): Promise<Buffer> {
+    const browser = await this.browserManager.getBrowser();
+    const page = await browser.newPage();
+
+    try {
+      const pageSetup = this.templateService.getPageSetup();
+      const styleExtractor = this.templateService.getStyleExtractor();
+
+      await pageSetup.setupPage(page);
+      const url = pageSetup.buildResumeUrl(options);
+      await pageSetup.navigateToPage(page, url);
+      await pageSetup.waitForResumeReady(page);
+
+      const styles = await styleExtractor.extractStyles(page);
+      await styleExtractor.renderCleanPage(page, url, styles);
+
+      return await this.generatePDF(page);
+    } finally {
+      await page.close();
+    }
+  }
+
+  /**
+   * Generate PDF buffer from page
+   */
+  private async generatePDF(page: Page): Promise<Buffer> {
+    const contentHeightMm = await this.calculateContentHeight(page);
+    const pdfConfig = this.templateService.getPdfConfig();
+
+    return Buffer.from(
+      await page.pdf({
+        ...pdfConfig,
+        height: `${contentHeightMm}mm`,
+      }),
+    );
+  }
+
+  /**
+   * Calculate content height in millimeters
+   */
+  private async calculateContentHeight(page: Page): Promise<number> {
+    return await page.evaluate(() => {
+      const pxToMm = 0.264583;
+      const el = document.querySelector('#resume');
+      const heightPx = el
+        ? Math.ceil(el.scrollHeight)
+        : Math.ceil(document.body.scrollHeight);
+      return Math.ceil(heightPx * pxToMm) + 2;
+    });
+  }
+}
diff --git a/src/export/services/pdf-template.service.ts b/src/export/services/pdf-template.service.ts
new file mode 100644
index 0000000..db9b5ee
--- /dev/null
+++ b/src/export/services/pdf-template.service.ts
@@ -0,0 +1,46 @@
+/**
+ * PDF Template Service
+ * Handles PDF template configuration and styling
+ */
+
+import { Injectable } from '@nestjs/common';
+import { ConfigService } from '@nestjs/config';
+import { PdfPageSetup, PdfStyleExtractor } from '../helpers';
+import { PDF } from '../constants/ui.constants';
+
+@Injectable()
+export class PdfTemplateService {
+  private readonly pageSetup: PdfPageSetup;
+  private readonly styleExtractor: PdfStyleExtractor;
+
+  constructor(private readonly configService: ConfigService) {
+    this.pageSetup = new PdfPageSetup(configService);
+    this.styleExtractor = new PdfStyleExtractor();
+  }
+
+  /**
+   * Get page setup helper
+   */
+  getPageSetup(): PdfPageSetup {
+    return this.pageSetup;
+  }
+
+  /**
+   * Get style extractor helper
+   */
+  getStyleExtractor(): PdfStyleExtractor {
+    return this.styleExtractor;
+  }
+
+  /**
+   * Get PDF configuration constants
+   */
+  getPdfConfig() {
+    return {
+      width: `${PDF.A3_WIDTH_MM}mm`,
+      margin: PDF.MARGIN,
+      printBackground: true,
+      preferCSSPageSize: false,
+    };
+  }
+}
diff --git a/src/export/services/resume-docx.service.spec.ts b/src/export/services/resume-docx.service.spec.ts
index de14cbe..c0dbf6e 100644
--- a/src/export/services/resume-docx.service.spec.ts
+++ b/src/export/services/resume-docx.service.spec.ts
@@ -1,78 +1,14 @@
 import { Test, TestingModule } from '@nestjs/testing';
 import { NotFoundException } from '@nestjs/common';
 import { ResumeDOCXService } from './resume-docx.service';
-import { ResumesRepository } from '../../resumes/resumes.repository';
-import { UsersRepository } from '../../users/users.repository';
+import { DocxBuilderService } from './docx-builder.service';
 
 describe('ResumeDOCXService', () => {
   let service: ResumeDOCXService;
-  let resumesRepository: jest.Mocked<ResumesRepository>;
-  let usersRepository: jest.Mocked<UsersRepository>;
+  let builderService: jest.Mocked<DocxBuilderService>;
 
-  const mockUser = {
-    id: 'user-123',
-    email: 'test@example.com',
-    displayName: 'John Doe',
-    phone: '+1234567890',
-    website: 'https://johndoe.com',
-    linkedin: 'linkedin.com/in/johndoe',
-    github: 'github.com/johndoe',
-    bio: 'Experienced software engineer',
-  };
-
-  const mockResume = {
-    id: 'resume-123',
-    userId: 'user-123',
-    title: 'Test Resume',
-    experiences: [
-      {
-        id: 'exp-1',
-        position: 'Senior Developer',
-        company: 'Tech Corp',
-        location: 'San Francisco, CA',
-        startDate: new Date('2020-01-01'),
-        endDate: null,
-        description: 'Led development team',
-        current: true,
-      },
-      {
-        id: 'exp-2',
-        position: 'Developer',
-        company: 'Startup Inc',
-        location: 'New York, NY',
-        startDate: new Date('2018-06-01'),
-        endDate: new Date('2019-12-31'),
-        description: 'Built web applications',
-        current: false,
-      },
-    ],
-    education: [
-      {
-        id: 'edu-1',
-        degree: 'BS',
-        field: 'Computer Science',
-        institution: 'MIT',
-        startDate: new Date('2014-09-01'),
-        endDate: new Date('2018-05-31'),
-      },
-    ],
-    skills: [
-      { id: 'skill-1', name: 'TypeScript', level: 'Expert', category: 'Languages' },
-      { id: 'skill-2', name: 'React', level: 'Advanced', category: 'Frontend' },
-      { id: 'skill-3', name: 'Node.js', level: 'Advanced', category: 'Backend' },
-    ],
-    projects: [
-      {
-        id: 'proj-1',
-        name: 'E-commerce Platform',
-        description: 'Built scalable e-commerce solution',
-        url: 'https://github.com/johndoe/ecommerce',
-      },
-    ],
-    languages: [
-      { id: 'lang-1', name: 'English', level: 'Native' },
-      { id: 'lang-2', name: 'Spanish', level: 'Intermediate' },
-    ],
+  const mockBuilderService = {
+    generate: jest.fn(),
   };
 
   beforeEach(async () => {
@@ -80,23 +16,14 @@ describe('ResumeDOCXService', () => {
       providers: [
         ResumeDOCXService,
         {
-          provide: ResumesRepository,
-          useValue: {
-            findByUserId: jest.fn(),
-          },
-        },
-        {
-          provide: UsersRepository,
-          useValue: {
-            getUser: jest.fn(),
-          },
+          provide: DocxBuilderService,
+          useValue: mockBuilderService,
         },
       ],
     }).compile();
 
     service = module.get<ResumeDOCXService>(ResumeDOCXService);
-    resumesRepository = module.get(ResumesRepository);
-    usersRepository = module.get(UsersRepository);
+    builderService = module.get(DocxBuilderService);
   });
 
   afterEach(() => {
@@ -105,19 +32,20 @@ describe('ResumeDOCXService', () => {
 
   describe('generate', () => {
     it('should generate DOCX for complete resume', async () => {
-      usersRepository.getUser.mockResolvedValue(mockUser as any);
-      resumesRepository.findByUserId.mockResolvedValue(mockResume as any);
+      const mockBuffer = Buffer.from('mock-docx-content');
+      mockBuilderService.generate.mockResolvedValue(mockBuffer);
 
       const result = await service.generate('user-123');
 
       expect(result).toBeInstanceOf(Buffer);
-      expect(result.length).toBeGreaterThan(0);
-      expect(usersRepository.getUser).toHaveBeenCalledWith('user-123');
-      expect(resumesRepository.findByUserId).toHaveBeenCalledWith('user-123');
+      expect(result).toEqual(mockBuffer);
+      expect(builderService.generate).toHaveBeenCalledWith('user-123');
     });
 
     it('should throw NotFoundException when user not found', async () => {
-      usersRepository.getUser.mockResolvedValue(null);
+      mockBuilderService.generate.mockRejectedValue(
+        new NotFoundException('User not found'),
+      );
 
       await expect(service.generate('non-existent-user')).rejects.toThrow(
         NotFoundException,
@@ -128,368 +56,25 @@ describe('ResumeDOCXService', () => {
     });
 
     it('should throw NotFoundException when resume not found', async () => {
-      usersRepository.getUser.mockResolvedValue(mockUser as any);
-      resumesRepository.findByUserId.mockResolvedValue(null);
+      mockBuilderService.generate.mockRejectedValue(
+        new NotFoundException('Resume not found for this user'),
+      );
 
-      await expect(service.generate('user-123')).rejects.toThrow(NotFoundException);
+      await expect(service.generate('user-123')).rejects.toThrow(
+        NotFoundException,
+      );
       await expect(service.generate('user-123')).rejects.toThrow(
         'Resume not found for this user',
       );
     });
 
-    it('should handle resume with empty sections', async () => {
-      const emptyResume = {
-        ...mockResume,
-        experiences: [],
-        education: [],
-        skills: [],
-        projects: [],
-        languages: [],
-      };
-
-      usersRepository.getUser.mockResolvedValue(mockUser as any);
-      resumesRepository.findByUserId.mockResolvedValue(emptyResume as any);
-
-      const result = await service.generate('user-123');
-
-      expect(result).toBeInstanceOf(Buffer);
-      expect(result.length).toBeGreaterThan(0);
-    });
-
-    it('should handle user with minimal fields', async () => {
-      const minimalUser = {
-        id: 'user-123',
-        email: 'test@example.com',
-        displayName: null,
-        phone: null,
-        website: null,
-        linkedin: null,
-        github: null,
-        bio: null,
-      };
-
-      usersRepository.getUser.mockResolvedValue(minimalUser as any);
-      resumesRepository.findByUserId.mockResolvedValue({
-        ...mockResume,
-        experiences: [],
-        education: [],
-        skills: [],
-        projects: [],
-        languages: [],
-      } as any);
-
-      const result = await service.generate('user-123');
-
-      expect(result).toBeInstanceOf(Buffer);
-    });
-
-    it('should handle null/undefined user fields gracefully', async () => {
-      const userWithNulls = {
-        id: 'user-123',
-        email: null,
-        displayName: undefined,
-        phone: undefined,
-        website: undefined,
-        linkedin: undefined,
-        github: undefined,
-        bio: undefined,
-      };
-
-      usersRepository.getUser.mockResolvedValue(userWithNulls as any);
-      resumesRepository.findByUserId.mockResolvedValue({
-        ...mockResume,
-        experiences: [],
-        education: [],
-        skills: [],
-        projects: [],
-        languages: [],
-      } as any);
-
-      const result = await service.generate('user-123');
-
-      expect(result).toBeInstanceOf(Buffer);
-    });
-  });
-
-  describe('date formatting', () => {
-    it('should format dates correctly for experiences', async () => {
-      const resumeWithDates = {
-        ...mockResume,
-        experiences: [
-          {
-            id: 'exp-1',
-            position: 'Developer',
-            company: 'Company',
-            location: 'City',
-            startDate: new Date('2020-03-15'),
-            endDate: new Date('2021-11-30'),
-            description: 'Work',
-            current: false,
-          },
-        ],
-        education: [],
-        skills: [],
-        projects: [],
-        languages: [],
-      };
-
-      usersRepository.getUser.mockResolvedValue(mockUser as any);
-      resumesRepository.findByUserId.mockResolvedValue(resumeWithDates as any);
-
-      const result = await service.generate('user-123');
-
-      expect(result).toBeInstanceOf(Buffer);
-      // The dates should be formatted as "Mar 2020 - Nov 2021" in the document
-    });
-
-    it('should show "Present" for current positions', async () => {
-      const resumeWithCurrentJob = {
-        ...mockResume,
-        experiences: [
-          {
-            id: 'exp-1',
-            position: 'Developer',
-            company: 'Company',
-            location: 'City',
-            startDate: new Date('2020-01-01'),
-            endDate: null,
-            description: 'Current work',
-            current: true,
-          },
-        ],
-        education: [],
-        skills: [],
-        projects: [],
-        languages: [],
-      };
-
-      usersRepository.getUser.mockResolvedValue(mockUser as any);
-      resumesRepository.findByUserId.mockResolvedValue(resumeWithCurrentJob as any);
-
-      const result = await service.generate('user-123');
-
-      expect(result).toBeInstanceOf(Buffer);
-      // endDate null should result in "Present"
-    });
-
-    it('should handle education date formatting', async () => {
-      const resumeWithEducation = {
-        ...mockResume,
-        experiences: [],
-        education: [
-          {
-            id: 'edu-1',
-            degree: 'PhD',
-            field: 'Physics',
-            institution: 'Stanford',
-            startDate: new Date('2018-09-01'),
-            endDate: null, // Ongoing
-          },
-        ],
-        skills: [],
-        projects: [],
-        languages: [],
-      };
-
-      usersRepository.getUser.mockResolvedValue(mockUser as any);
-      resumesRepository.findByUserId.mockResolvedValue(resumeWithEducation as any);
-
-      const result = await service.generate('user-123');
-
-      expect(result).toBeInstanceOf(Buffer);
-    });
-  });
-
-  describe('skills formatting', () => {
-    it('should format skills with bullet separator', async () => {
-      const resumeWithSkills = {
-        ...mockResume,
-        experiences: [],
-        education: [],
-        skills: [
-          { id: 's1', name: 'JavaScript', level: 'Expert', category: 'Lang' },
-          { id: 's2', name: 'Python', level: 'Advanced', category: 'Lang' },
-          { id: 's3', name: 'SQL', level: 'Intermediate', category: 'DB' },
-        ],
-        projects: [],
-        languages: [],
-      };
-
-      usersRepository.getUser.mockResolvedValue(mockUser as any);
-      resumesRepository.findByUserId.mockResolvedValue(resumeWithSkills as any);
-
-      const result = await service.generate('user-123');
+    it('should handle errors from builder service', async () => {
+      const error = new Error('Builder service error');
+      mockBuilderService.generate.mockRejectedValue(error);
 
-      expect(result).toBeInstanceOf(Buffer);
-      // Skills should be formatted as "JavaScript • Python • SQL"
-    });
-
-    it('should handle single skill', async () => {
-      const resumeWithOneSkill = {
-        ...mockResume,
-        experiences: [],
-        education: [],
-        skills: [{ id: 's1', name: 'TypeScript', level: 'Expert', category: 'Lang' }],
-        projects: [],
-        languages: [],
-      };
-
-      usersRepository.getUser.mockResolvedValue(mockUser as any);
-      resumesRepository.findByUserId.mockResolvedValue(resumeWithOneSkill as any);
-
-      const result = await service.generate('user-123');
-
-      expect(result).toBeInstanceOf(Buffer);
-    });
-  });
-
-  describe('languages formatting', () => {
-    it('should format languages with level in parentheses', async () => {
-      const resumeWithLanguages = {
-        ...mockResume,
-        experiences: [],
-        education: [],
-        skills: [],
-        projects: [],
-        languages: [
-          { id: 'l1', name: 'English', level: 'Native' },
-          { id: 'l2', name: 'French', level: 'Fluent' },
-        ],
-      };
-
-      usersRepository.getUser.mockResolvedValue(mockUser as any);
-      resumesRepository.findByUserId.mockResolvedValue(resumeWithLanguages as any);
-
-      const result = await service.generate('user-123');
-
-      expect(result).toBeInstanceOf(Buffer);
-      // Languages should be formatted as "English (Native) | French (Fluent)"
-    });
-  });
-
-  describe('projects formatting', () => {
-    it('should include project URL when available', async () => {
-      const resumeWithProjects = {
-        ...mockResume,
-        experiences: [],
-        education: [],
-        skills: [],
-        projects: [
-          {
-            id: 'p1',
-            name: 'Project With URL',
-            description: 'Description here',
-            url: 'https://github.com/user/project',
-          },
-        ],
-        languages: [],
-      };
-
-      usersRepository.getUser.mockResolvedValue(mockUser as any);
-      resumesRepository.findByUserId.mockResolvedValue(resumeWithProjects as any);
-
-      const result = await service.generate('user-123');
-
-      expect(result).toBeInstanceOf(Buffer);
-    });
-
-    it('should handle project without URL', async () => {
-      const resumeWithProjects = {
-        ...mockResume,
-        experiences: [],
-        education: [],
-        skills: [],
-        projects: [
-          {
-            id: 'p1',
-            name: 'Project Without URL',
-            description: 'Description here',
-            url: null,
-          },
-        ],
-        languages: [],
-      };
-
-      usersRepository.getUser.mockResolvedValue(mockUser as any);
-      resumesRepository.findByUserId.mockResolvedValue(resumeWithProjects as any);
-
-      const result = await service.generate('user-123');
-
-      expect(result).toBeInstanceOf(Buffer);
-    });
-
-    it('should handle project with empty description', async () => {
-      const resumeWithProjects = {
-        ...mockResume,
-        experiences: [],
-        education: [],
-        skills: [],
-        projects: [
-          {
-            id: 'p1',
-            name: 'Project',
-            description: null,
-            url: null,
-          },
-        ],
-        languages: [],
-      };
-
-      usersRepository.getUser.mockResolvedValue(mockUser as any);
-      resumesRepository.findByUserId.mockResolvedValue(resumeWithProjects as any);
-
-      const result = await service.generate('user-123');
-
-      expect(result).toBeInstanceOf(Buffer);
-    });
-  });
-
-  describe('contact info formatting', () => {
-    it('should format contact info with separators', async () => {
-      const userWithAllContacts = {
-        ...mockUser,
-        website: 'https://example.com',
-        linkedin: 'linkedin.com/in/user',
-        github: 'github.com/user',
-      };
-
-      usersRepository.getUser.mockResolvedValue(userWithAllContacts as any);
-      resumesRepository.findByUserId.mockResolvedValue({
-        ...mockResume,
-        experiences: [],
-        education: [],
-        skills: [],
-        projects: [],
-        languages: [],
-      } as any);
-
-      const result = await service.generate('user-123');
-
-      expect(result).toBeInstanceOf(Buffer);
-      // Should be formatted with " | " separators
-    });
-
-    it('should handle user with only linkedin', async () => {
-      const userWithOnlyLinkedin = {
-        ...mockUser,
-        website: null,
-        linkedin: 'linkedin.com/in/user',
-        github: null,
-      };
-
-      usersRepository.getUser.mockResolvedValue(userWithOnlyLinkedin as any);
-      resumesRepository.findByUserId.mockResolvedValue({
-        ...mockResume,
-        experiences: [],
-        education: [],
-        skills: [],
-        projects: [],
-        languages: [],
-      } as any);
-
-      const result = await service.generate('user-123');
-
-      expect(result).toBeInstanceOf(Buffer);
+      await expect(service.generate('user-123')).rejects.toThrow(
+        'Builder service error',
+      );
     });
   });
 });
diff --git a/src/export/services/resume-docx.service.ts b/src/export/services/resume-docx.service.ts
index e1edad9..5754252 100644
--- a/src/export/services/resume-docx.service.ts
+++ b/src/export/services/resume-docx.service.ts
@@ -1,295 +1,19 @@
-import { Injectable, NotFoundException } from '@nestjs/common';
-import {
-  Document,
-  Packer,
-  Paragraph,
-  TextRun,
-  HeadingLevel,
-  AlignmentType,
-  SectionType,
-  Header,
-  PageNumber,
-  BorderStyle,
-} from 'docx';
-import { ResumesRepository } from '../../resumes/resumes.repository';
-import { UsersRepository } from '../../users/users.repository';
-import {
-  Resume,
-  Experience,
-  Education,
-  Skill,
-  Project,
-  Language,
-} from '@prisma/client';
+/**
+ * Resume DOCX Service (Facade)
+ * Delegates to specialized services for DOCX generation
+ */
 
-type FullResume = Resume & {
-  experiences: Experience[];
-  education: Education[];
-  skills: Skill[];
-  projects: Project[];
-  languages: Language[];
-};
+import { Injectable } from '@nestjs/common';
+import { DocxBuilderService } from './docx-builder.service';
 
 @Injectable()
 export class ResumeDOCXService {
-  constructor(
-    private readonly resumesRepository: ResumesRepository,
-    private readonly usersRepository: UsersRepository,
-  ) {}
+  constructor(private readonly builderService: DocxBuilderService) {}
 
+  /**
+   * Generate DOCX document for user resume
+   */
   async generate(userId: string): Promise<Buffer> {
-    const user = await this.usersRepository.getUser(userId);
-    if (!user) {
-      throw new NotFoundException('User not found');
-    }
-
-    const resume = (await this.resumesRepository.findByUserId(
-      userId,
-    )) as FullResume;
-    if (!resume) {
-      throw new NotFoundException('Resume not found for this user');
-    }
-
-    const doc = new Document({
-      sections: [
-        {
-          headers: {
-            default: new Header({
-              children: [
-                new Paragraph({
-                  alignment: AlignmentType.RIGHT,
-                  children: [
-                    new TextRun({
-                      children: ['Page ', PageNumber.CURRENT],
-                      style: 'default',
-                    }),
-                  ],
-                }),
-              ],
-            }),
-          },
-          properties: {
-            type: SectionType.NEXT_PAGE,
-            page: {
-              margin: {
-                top: '0.5in',
-                right: '0.5in',
-                bottom: '0.5in',
-                left: '0.5in',
-              },
-            },
-          },
-          children: [
-            // --- Header Section ---
-            new Paragraph({
-              text: user.displayName || 'Unnamed User',
-              heading: HeadingLevel.TITLE,
-              alignment: AlignmentType.CENTER,
-            }),
-            new Paragraph({
-              alignment: AlignmentType.CENTER,
-              style: 'default',
-              children: [
-                new TextRun(user.email || ''),
-                ...(user.phone ? [new TextRun(` | ${user.phone}`)] : []),
-              ],
-            }),
-            new Paragraph({
-              alignment: AlignmentType.CENTER,
-              style: 'default',
-              children: [
-                ...(user.website ? [new TextRun(user.website)] : []),
-                ...(user.linkedin
-                  ? [
-                      new TextRun(
-                        `${user.website ? ' | ' : ''}${user.linkedin}`,
-                      ),
-                    ]
-                  : []),
-                ...(user.github
-                  ? [
-                      new TextRun(
-                        `${user.website || user.linkedin ? ' | ' : ''}${user.github}`,
-                      ),
-                    ]
-                  : []),
-              ],
-            }),
-
-            // --- Summary Section ---
-            this.createSectionHeading('Summary'),
-            new Paragraph({
-              text: user.bio || '',
-              style: 'default',
-              thematicBreak: true,
-            }),
-
-            // --- Experience Section ---
-            this.createSectionHeading('Experience'),
-            ...resume.experiences.flatMap((exp) => this.createExperience(exp)),
-
-            // --- Education Section ---
-            this.createSectionHeading('Education'),
-            ...resume.education.flatMap((edu) => this.createEducation(edu)),
-
-            // --- Skills Section ---
-            this.createSectionHeading('Skills'),
-            this.createSkillsParagraph(resume.skills),
-
-            // --- Projects Section ---
-            this.createSectionHeading('Projects'),
-            ...resume.projects.flatMap((proj) => this.createProject(proj)),
-
-            // --- Languages Section ---
-            this.createSectionHeading('Languages'),
-            this.createLanguagesParagraph(resume.languages),
-          ],
-        },
-      ],
-      styles: {
-        paragraphStyles: [
-          {
-            id: 'default',
-            name: 'Default',
-            basedOn: 'Normal',
-            next: 'Normal',
-            quickFormat: true,
-            run: {
-              font: 'Calibri',
-              size: 22, // 11pt
-            },
-          },
-        ],
-      },
-    });
-
-    return Packer.toBuffer(doc);
-  }
-
-  private createSectionHeading(text: string): Paragraph {
-    return new Paragraph({
-      text,
-      heading: HeadingLevel.HEADING_1,
-      border: {
-        bottom: { color: 'auto', space: 1, size: 6, style: BorderStyle.SINGLE },
-      },
-      spacing: { after: 200, before: 300 },
-    });
-  }
-
-  private createExperience(exp: Experience): Paragraph[] {
-    const startDate = new Date(exp.startDate).toLocaleDateString('en-US', {
-      year: 'numeric',
-      month: 'short',
-    });
-    const endDate = exp.endDate
-      ? new Date(exp.endDate).toLocaleDateString('en-US', {
-          year: 'numeric',
-          month: 'short',
-        })
-      : 'Present';
-
-    return [
-      new Paragraph({
-        children: [
-          new TextRun({ text: exp.position, bold: true }),
-          new TextRun({ text: ` at ${exp.company}`, bold: true }),
-        ],
-        spacing: { after: 50 },
-      }),
-      new Paragraph({
-        children: [
-          new TextRun({
-            text: `${exp.location} | ${startDate} - ${endDate}`,
-            italics: true,
-            color: '595959',
-          }),
-        ],
-        spacing: { after: 100 },
-      }),
-      new Paragraph({
-        text: exp.description || '',
-        bullet: { level: 0 },
-        indent: { left: 720 },
-        spacing: { after: 200 },
-      }),
-    ];
-  }
-
-  private createEducation(edu: Education): Paragraph[] {
-    const startDate = new Date(edu.startDate).toLocaleDateString('en-US', {
-      year: 'numeric',
-      month: 'short',
-    });
-    const endDate = edu.endDate
-      ? new Date(edu.endDate).toLocaleDateString('en-US', {
-          year: 'numeric',
-          month: 'short',
-        })
-      : 'Present';
-
-    return [
-      new Paragraph({
-        children: [
-          new TextRun({ text: edu.degree, bold: true }),
-          new TextRun({ text: ` in ${edu.field}` }),
-        ],
-        spacing: { after: 50 },
-      }),
-      new Paragraph({
-        children: [
-          new TextRun({
-            text: `${edu.institution} | ${startDate} - ${endDate}`,
-            italics: true,
-            color: '595959',
-          }),
-        ],
-        spacing: { after: 200 },
-      }),
-    ];
-  }
-
-  private createSkillsParagraph(skills: Skill[]): Paragraph {
-    return new Paragraph({
-      children: skills.map(
-        (skill, index) =>
-          new TextRun({
-            text: `${skill.name}${index < skills.length - 1 ? ' • ' : ''}`,
-          }),
-      ),
-      spacing: { after: 200 },
-    });
-  }
-
-  private createLanguagesParagraph(languages: Language[]): Paragraph {
-    return new Paragraph({
-      children: languages.map(
-        (lang, index) =>
-          new TextRun({
-            text: `${lang.name} (${lang.level})${index < languages.length - 1 ? ' | ' : ''}`,
-          }),
-      ),
-      spacing: { after: 200 },
-    });
-  }
-
-  private createProject(proj: Project): Paragraph[] {
-    return [
-      new Paragraph({
-        children: [
-          new TextRun({ text: proj.name, bold: true }),
-          ...(proj.url
-            ? [new TextRun({ text: ` - ${proj.url}`, style: 'Hyperlink' })]
-            : []),
-        ],
-        spacing: { after: 50 },
-      }),
-      new Paragraph({
-        text: proj.description || '',
-        bullet: { level: 0 },
-        indent: { left: 720 },
-        spacing: { after: 200 },
-      }),
-    ];
+    return this.builderService.generate(userId);
   }
 }
diff --git a/src/export/services/resume-pdf.service.spec.ts b/src/export/services/resume-pdf.service.spec.ts
index ce02fbe..9944f2f 100644
--- a/src/export/services/resume-pdf.service.spec.ts
+++ b/src/export/services/resume-pdf.service.spec.ts
@@ -1,48 +1,28 @@
 import { Test, TestingModule } from '@nestjs/testing';
-import { ConfigService } from '@nestjs/config';
 import { ResumePDFService } from './resume-pdf.service';
-import { BrowserManagerService } from './browser-manager.service';
-import { createMockPage, createMockBrowser, MockPage, MockBrowser } from '../__mocks__/puppeteer.mock';
-import { VIEWPORT, TIMEOUT, DEFAULT } from '../constants/ui.constants';
+import { PdfGeneratorService } from './pdf-generator.service';
 
 describe('ResumePDFService', () => {
   let service: ResumePDFService;
-  let browserManagerService: jest.Mocked<BrowserManagerService>;
-  let configService: jest.Mocked<ConfigService>;
-  let mockPage: MockPage;
-  let mockBrowser: MockBrowser;
+  let generatorService: jest.Mocked<PdfGeneratorService>;
 
   beforeEach(async () => {
-    mockPage = createMockPage();
-    mockBrowser = createMockBrowser(mockPage);
+    const mockGeneratorService = {
+      generate: jest.fn().mockResolvedValue(Buffer.from('pdf-content')),
+    };
 
     const module: TestingModule = await Test.createTestingModule({
       providers: [
         ResumePDFService,
         {
-          provide: BrowserManagerService,
-          useValue: {
-            getBrowser: jest.fn().mockResolvedValue(mockBrowser),
-          },
-        },
-        {
-          provide: ConfigService,
-          useValue: {
-            get: jest.fn((key: string) => {
-              const config: Record<string, string | number> = {
-                FRONTEND_HOST: 'localhost',
-                FRONTEND_PORT: 3000,
-              };
-              return config[key];
-            }),
-          },
+          provide: PdfGeneratorService,
+          useValue: mockGeneratorService,
         },
       ],
     }).compile();
 
     service = module.get<ResumePDFService>(ResumePDFService);
-    browserManagerService = module.get(BrowserManagerService);
-    configService = module.get(ConfigService);
+    generatorService = module.get(PdfGeneratorService);
   });
 
   afterEach(() => {
@@ -51,239 +31,60 @@ describe('ResumePDFService', () => {
 
   describe('generate', () => {
     it('should generate PDF for valid resume with default options', async () => {
-      // Setup successful page evaluation
-      mockPage.evaluate.mockResolvedValue({
-        linkTags: ['<link rel="stylesheet" href="/styles.css">'],
-        styleTags: ['<style>body { margin: 0; }</style>'],
-        resumeHTML: '<div id="resume" data-ready="1">Content</div>',
-        cssVars: '--accent: #333;',
-      });
-      mockPage.pdf.mockResolvedValue(Buffer.from('pdf-content'));
-
       const result = await service.generate();
 
       expect(result).toBeInstanceOf(Buffer);
-      expect(browserManagerService.getBrowser).toHaveBeenCalled();
-      expect(mockBrowser.newPage).toHaveBeenCalled();
-      expect(mockPage.close).toHaveBeenCalled();
+      expect(generatorService.generate).toHaveBeenCalledWith({});
     });
 
     it('should use custom palette parameter', async () => {
-      mockPage.evaluate.mockResolvedValue({
-        linkTags: [],
-        styleTags: [],
-        resumeHTML: '<div id="resume">Content</div>',
-        cssVars: '',
-      });
-
       await service.generate({ palette: 'ocean' });
 
-      expect(mockPage.goto).toHaveBeenCalledWith(
-        expect.stringContaining('palette=ocean'),
-        expect.any(Object),
-      );
+      expect(generatorService.generate).toHaveBeenCalledWith({
+        palette: 'ocean',
+      });
     });
 
     it('should use custom language parameter', async () => {
-      mockPage.evaluate.mockResolvedValue({
-        linkTags: [],
-        styleTags: [],
-        resumeHTML: '<div id="resume">Content</div>',
-        cssVars: '',
-      });
-
       await service.generate({ lang: 'en' });
 
-      expect(mockPage.goto).toHaveBeenCalledWith(
-        expect.stringContaining('lang=en'),
-        expect.any(Object),
-      );
+      expect(generatorService.generate).toHaveBeenCalledWith({ lang: 'en' });
     });
 
     it('should include bannerColor when provided', async () => {
-      mockPage.evaluate.mockResolvedValue({
-        linkTags: [],
-        styleTags: [],
-        resumeHTML: '<div id="resume">Content</div>',
-        cssVars: '',
-      });
-
       await service.generate({ bannerColor: 'blue' });
 
-      expect(mockPage.goto).toHaveBeenCalledWith(
-        expect.stringContaining('bannerColor=blue'),
-        expect.any(Object),
-      );
+      expect(generatorService.generate).toHaveBeenCalledWith({
+        bannerColor: 'blue',
+      });
     });
 
     it('should include userId when provided', async () => {
-      mockPage.evaluate.mockResolvedValue({
-        linkTags: [],
-        styleTags: [],
-        resumeHTML: '<div id="resume">Content</div>',
-        cssVars: '',
-      });
-
       await service.generate({ userId: 'user-123' });
 
-      expect(mockPage.goto).toHaveBeenCalledWith(
-        expect.stringContaining('user=user-123'),
-        expect.any(Object),
-      );
-    });
-
-    it('should close page even on error', async () => {
-      mockPage.goto.mockRejectedValue(new Error('Navigation failed'));
-
-      await expect(service.generate()).rejects.toThrow('Navigation failed');
-      expect(mockPage.close).toHaveBeenCalled();
-    });
-
-    it('should handle page navigation timeout', async () => {
-      mockPage.goto.mockRejectedValue(new Error('Timeout exceeded'));
-
-      await expect(service.generate()).rejects.toThrow('Timeout exceeded');
-    });
-
-    it('should handle missing #resume element', async () => {
-      mockPage.waitForSelector.mockRejectedValue(
-        new Error('waiting for selector "#resume" failed: timeout'),
-      );
-
-      await expect(service.generate()).rejects.toThrow('waiting for selector');
-    });
-
-    it('should set correct viewport dimensions', async () => {
-      mockPage.evaluate.mockResolvedValue({
-        linkTags: [],
-        styleTags: [],
-        resumeHTML: '<div id="resume">Content</div>',
-        cssVars: '',
-      });
-
-      await service.generate();
-
-      expect(mockPage.setViewport).toHaveBeenCalledWith({
-        width: VIEWPORT.RESUME.WIDTH,
-        height: VIEWPORT.RESUME.HEIGHT,
-        deviceScaleFactor: VIEWPORT.RESUME.SCALE_FACTOR,
+      expect(generatorService.generate).toHaveBeenCalledWith({
+        userId: 'user-123',
       });
     });
 
-    it('should wait for document fonts ready', async () => {
-      mockPage.evaluate.mockResolvedValue({
-        linkTags: [],
-        styleTags: [],
-        resumeHTML: '<div id="resume">Content</div>',
-        cssVars: '',
-      });
-
-      await service.generate();
-
-      expect(mockPage.evaluateHandle).toHaveBeenCalledWith('document.fonts.ready');
-    });
-
-    it('should emulate print media type', async () => {
-      mockPage.evaluate.mockResolvedValue({
-        linkTags: [],
-        styleTags: [],
-        resumeHTML: '<div id="resume">Content</div>',
-        cssVars: '',
-      });
-
-      await service.generate();
-
-      expect(mockPage.emulateMediaType).toHaveBeenCalledWith('print');
-    });
-
-    it('should use default host and port when not configured', async () => {
-      configService.get.mockReturnValue(undefined);
-      mockPage.evaluate.mockResolvedValue({
-        linkTags: [],
-        styleTags: [],
-        resumeHTML: '<div id="resume">Content</div>',
-        cssVars: '',
-      });
-
-      await service.generate();
-
-      expect(mockPage.goto).toHaveBeenCalledWith(
-        expect.stringContaining(`http://${DEFAULT.HOST}:${DEFAULT.PORT}`),
-        expect.any(Object),
-      );
-    });
-  });
-
-  describe('buildResumeUrl', () => {
-    it('should build URL with all parameters', async () => {
-      mockPage.evaluate.mockResolvedValue({
-        linkTags: [],
-        styleTags: [],
-        resumeHTML: '<div id="resume">Content</div>',
-        cssVars: '',
-      });
-
-      await service.generate({
+    it('should pass through all options to generator', async () => {
+      const options = {
         palette: 'midnight',
         lang: 'pt-br',
         bannerColor: 'purple',
         userId: 'abc-123',
-      });
-
-      const call = mockPage.goto.mock.calls[0][0] as string;
-      expect(call).toContain('palette=midnight');
-      expect(call).toContain('lang=pt-br');
-      expect(call).toContain('bannerColor=purple');
-      expect(call).toContain('user=abc-123');
-      expect(call).toContain('export=1');
-    });
-
-    it('should URL-encode special characters in parameters', async () => {
-      mockPage.evaluate.mockResolvedValue({
-        linkTags: [],
-        styleTags: [],
-        resumeHTML: '<div id="resume">Content</div>',
-        cssVars: '',
-      });
+      };
 
-      await service.generate({ palette: 'color with spaces' });
+      await service.generate(options);
 
-      expect(mockPage.goto).toHaveBeenCalledWith(
-        expect.stringContaining('palette=color%20with%20spaces'),
-        expect.any(Object),
-      );
+      expect(generatorService.generate).toHaveBeenCalledWith(options);
     });
-  });
-
-  describe('PDF generation options', () => {
-    it('should generate PDF with correct dimensions', async () => {
-      mockPage.evaluate
-        .mockResolvedValueOnce({
-          linkTags: [],
-          styleTags: [],
-          resumeHTML: '<div id="resume">Content</div>',
-          cssVars: '',
-        })
-        .mockResolvedValueOnce(300); // Content height in mm
-
-      await service.generate();
-
-      expect(mockPage.pdf).toHaveBeenCalledWith(
-        expect.objectContaining({
-          printBackground: true,
-          width: '297mm',
-          preferCSSPageSize: false,
-        }),
-      );
-    });
-  });
 
-  describe('error handling', () => {
-    it('should take debug screenshot on navigation error', async () => {
-      mockPage.goto.mockRejectedValue(new Error('Network error'));
+    it('should handle errors from generator', async () => {
+      const error = new Error('PDF generation failed');
+      generatorService.generate.mockRejectedValueOnce(error);
 
-      await expect(service.generate()).rejects.toThrow('Network error');
-      expect(mockPage.screenshot).toHaveBeenCalled();
+      await expect(service.generate()).rejects.toThrow('PDF generation failed');
     });
   });
 });
diff --git a/src/export/services/resume-pdf.service.ts b/src/export/services/resume-pdf.service.ts
index 9b7d83d..58d0916 100644
--- a/src/export/services/resume-pdf.service.ts
+++ b/src/export/services/resume-pdf.service.ts
@@ -1,226 +1,20 @@
 /**
- * Resume PDF Service - Single Responsibility Pattern
- *
- * Single Responsibility:
- * - Generate resume PDFs with perfect layout
- * - Extract styles and render clean page
- * - Calculate exact dimensions to avoid page breaks
- *
- * Uncle Bob: "A class should have only one reason to change"
+ * Resume PDF Service (Facade)
+ * Delegates to specialized services for PDF generation
  */
 
-import { Injectable, Logger } from '@nestjs/common';
-import { ConfigService } from '@nestjs/config';
-import { Page } from 'puppeteer';
-import { BrowserManagerService } from './browser-manager.service';
-import {
-  VIEWPORT,
-  PDF,
-  TIMEOUT,
-  DEBUG_PATH,
-  DEFAULT,
-} from '../constants/ui.constants';
-
-interface ResumePDFOptions {
-  palette?: string;
-  lang?: string;
-  bannerColor?: string;
-  userId?: string;
-}
+import { Injectable } from '@nestjs/common';
+import { PdfGeneratorService } from './pdf-generator.service';
+import { ResumePDFOptions } from '../helpers';
 
 @Injectable()
 export class ResumePDFService {
-  private readonly logger = new Logger(ResumePDFService.name);
-
-  constructor(
-    private readonly browserManager: BrowserManagerService,
-    private readonly configService: ConfigService,
-  ) {}
+  constructor(private readonly generatorService: PdfGeneratorService) {}
 
+  /**
+   * Generate PDF from resume
+   */
   async generate(options: ResumePDFOptions = {}): Promise<Buffer> {
-    const {
-      palette = DEFAULT.PALETTE,
-      lang = DEFAULT.LANGUAGE,
-      bannerColor,
-      userId,
-    } = options;
-
-    const browser = await this.browserManager.getBrowser();
-    const page = await browser.newPage();
-
-    try {
-      await this.setupPage(page);
-      const url = this.buildResumeUrl({ palette, lang, bannerColor, userId });
-      await this.navigateToPage(page, url);
-      await this.waitForResumeReady(page);
-
-      const { linkTags, styleTags, resumeHTML, cssVars } =
-        await this.extractStyles(page);
-      await this.renderCleanPage(page, url, {
-        linkTags,
-        styleTags,
-        resumeHTML,
-        cssVars,
-      });
-
-      return await this.generatePDF(page);
-    } finally {
-      await page.close();
-    }
-  }
-
-  private async setupPage(page: Page): Promise<void> {
-    await page.setViewport({
-      width: VIEWPORT.RESUME.WIDTH,
-      height: VIEWPORT.RESUME.HEIGHT,
-      deviceScaleFactor: VIEWPORT.RESUME.SCALE_FACTOR,
-    });
-  }
-
-  private buildResumeUrl(options: ResumePDFOptions): string {
-    const { palette, lang, bannerColor, userId } = options;
-    const host =
-      this.configService.get<string>('FRONTEND_HOST') || DEFAULT.HOST;
-    const port =
-      this.configService.get<number>('FRONTEND_PORT') || DEFAULT.PORT;
-
-    let url = `http://${host}:${port}/protected/resume?export=1&palette=${encodeURIComponent(
-      palette!,
-    )}&lang=${encodeURIComponent(lang!)}`;
-
-    if (bannerColor) {
-      url += `&bannerColor=${encodeURIComponent(bannerColor)}`;
-    }
-    if (userId) {
-      url += `&user=${encodeURIComponent(userId)}`;
-    }
-
-    return url;
-  }
-
-  private async navigateToPage(page: Page, url: string): Promise<void> {
-    try {
-      await page.goto(url, {
-        waitUntil: 'domcontentloaded',
-        timeout: TIMEOUT.PAGE_LOAD,
-      });
-    } catch (err) {
-      await page.screenshot({ path: DEBUG_PATH.RESUME_GOTO_ERROR });
-      this.logger.error('[ResumePDF] Error during page.goto:', err);
-      throw err;
-    }
-  }
-
-  private async waitForResumeReady(page: Page): Promise<void> {
-    await page.waitForSelector('#resume', { timeout: TIMEOUT.SELECTOR_WAIT });
-    await page.waitForSelector('#resume[data-ready="1"]', {
-      timeout: TIMEOUT.SELECTOR_WAIT,
-    });
-  }
-
-  private async extractStyles(page: Page): Promise<{
-    linkTags: string[];
-    styleTags: string[];
-    resumeHTML: string;
-    cssVars: string;
-  }> {
-    return await page.evaluate(() => {
-      const linkTags = Array.from(
-        document.querySelectorAll('head link[rel="stylesheet"]'),
-      ).map((l) => (l as HTMLLinkElement).outerHTML);
-
-      const styleTags = Array.from(document.querySelectorAll('head style')).map(
-        (s) => (s as HTMLStyleElement).outerHTML,
-      );
-
-      const resumeEl = document.querySelector('#resume');
-
-      // Collect CSS variables from :root
-      const rootStyle = document.documentElement.style;
-      const varNames = Array.from(rootStyle).filter((n) => n.startsWith('--'));
-      const cssVars = varNames
-        .map((name) => `${name}: ${rootStyle.getPropertyValue(name)};`)
-        .join(' ');
-
-      return {
-        linkTags,
-        styleTags,
-        resumeHTML: resumeEl ? resumeEl.outerHTML : '',
-        cssVars,
-      };
-    });
-  }
-
-  private async renderCleanPage(
-    page: Page,
-    pageUrl: string,
-    styles: {
-      linkTags: string[];
-      styleTags: string[];
-      resumeHTML: string;
-      cssVars: string;
-    },
-  ): Promise<void> {
-    const origin = new URL(pageUrl).origin;
-    const { linkTags, styleTags, resumeHTML, cssVars } = styles;
-
-    await page.setContent(
-      `<!doctype html>
-      <html>
-        <head>
-          <base href="${origin}">
-          ${linkTags.join('\n')}
-          ${styleTags.join('\n')}
-          <style>
-            :root { ${cssVars} }
-            html, body { margin: 0 !important; padding: 0 !important; background: #fff !important; }
-            * { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
-            @page { margin: 0; }
-            [data-no-print] { display: none !important; visibility: hidden !important; }
-            #resume, #resume * { break-inside: avoid; page-break-inside: avoid; }
-            #resume .bg-\\[var\\(--accent\\)\\], #resume .bg-\\[var\\(--accent\\)\\] * { color: #fff !important; }
-            #resume a, #resume a:visited, #resume a:active { text-decoration: none !important; outline: none !important; box-shadow: none !important; }
-            #resume *:focus { outline: none !important; box-shadow: none !important; }
-            #resume [class*="ring-"], #resume [class*="focus:ring-"] { box-shadow: none !important; }
-            #resume [class*="border-b"] { border-right: 0 !important; }
-          </style>
-        </head>
-        <body>
-          ${resumeHTML}
-        </body>
-      </html>`,
-      { waitUntil: 'domcontentloaded' },
-    );
-
-    // Apply print styles and wait for fonts
-    await page.emulateMediaType('print');
-    await page.evaluateHandle('document.fonts.ready');
-    await new Promise((resolve) => setTimeout(resolve, TIMEOUT.FONT_READY));
-  }
-
-  private async generatePDF(page: Page): Promise<Buffer> {
-    // Calculate exact content height
-    const contentHeightMm = await this.calculateContentHeight(page);
-
-    return Buffer.from(
-      await page.pdf({
-        printBackground: true,
-        width: `${PDF.A3_WIDTH_MM}mm`,
-        height: `${contentHeightMm}mm`,
-        preferCSSPageSize: false,
-        margin: PDF.MARGIN,
-      }),
-    );
-  }
-
-  private async calculateContentHeight(page: Page): Promise<number> {
-    return await page.evaluate(() => {
-      const pxToMm = 0.264583; // 96 CSS px per inch
-      const el = document.querySelector('#resume');
-      const heightPx = el
-        ? Math.ceil(el.scrollHeight)
-        : Math.ceil(document.body.scrollHeight);
-      return Math.ceil(heightPx * pxToMm) + 2; // 2mm buffer
-    });
+    return this.generatorService.generate(options);
   }
 }
diff --git a/src/integrations/github/github.controller.ts b/src/integrations/github/github.controller.ts
index 91cd560..a8affa3 100644
--- a/src/integrations/github/github.controller.ts
+++ b/src/integrations/github/github.controller.ts
@@ -8,10 +8,10 @@ import {
   ApiBody,
 } from '@nestjs/swagger';
 import { GitHubService } from './github.service';
-import { JwtAuthGuard } from 'src/auth/guards/jwt-auth.guard';
-import { CurrentUser } from 'src/common/decorators/current-user.decorator';
-import { UserPayload } from 'src/auth/interfaces/auth-request.interface';
-import { Public } from 'src/auth/decorators/public.decorator';
+import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
+import { CurrentUser } from '../../common/decorators/current-user.decorator';
+import { UserPayload } from '../../auth/interfaces/auth-request.interface';
+import { Public } from '../../auth/decorators/public.decorator';
 
 @ApiTags('github')
 @Controller('integrations/github')
diff --git a/src/integrations/github/github.module.ts b/src/integrations/github/github.module.ts
index 4726467..d0a7a00 100644
--- a/src/integrations/github/github.module.ts
+++ b/src/integrations/github/github.module.ts
@@ -1,12 +1,26 @@
 import { Module } from '@nestjs/common';
 import { GitHubService } from './github.service';
 import { GitHubController } from './github.controller';
-import { PrismaModule } from 'src/prisma/prisma.module';
+import { PrismaModule } from '../../prisma/prisma.module';
+import {
+  GitHubApiService,
+  GitHubContributionService,
+  GitHubAchievementService,
+  GitHubDatabaseService,
+  GitHubSyncService,
+} from './services';
 
 @Module({
   imports: [PrismaModule],
   controllers: [GitHubController],
-  providers: [GitHubService],
+  providers: [
+    GitHubService,
+    GitHubApiService,
+    GitHubContributionService,
+    GitHubAchievementService,
+    GitHubDatabaseService,
+    GitHubSyncService,
+  ],
   exports: [GitHubService],
 })
 export class GitHubModule {}
diff --git a/src/integrations/github/github.service.spec.ts b/src/integrations/github/github.service.spec.ts
index e4b7805..c15e34f 100644
--- a/src/integrations/github/github.service.spec.ts
+++ b/src/integrations/github/github.service.spec.ts
@@ -1,54 +1,49 @@
 import { Test, TestingModule } from '@nestjs/testing';
-import { ConfigService } from '@nestjs/config';
 import { HttpException } from '@nestjs/common';
-import { PrismaService } from '../../prisma/prisma.service';
 import { GitHubService } from './github.service';
+import {
+  GitHubApiService,
+  GitHubSyncService,
+  GitHubDatabaseService,
+} from './services';
+
+const mockGitHubApiService = {
+  getUserProfile: jest.fn(),
+  getUserRepos: jest.fn(),
+  getRepoCommitCount: jest.fn(),
+  getRepoPullRequests: jest.fn(),
+};
 
-// Mock the global fetch
-const mockFetch = jest.fn();
-global.fetch = mockFetch;
-
-const mockPrismaService = {
-  resume: {
-    update: jest.fn(),
-    findUnique: jest.fn().mockResolvedValue({
-      id: 'resume-id',
-      userId: 'user-id',
-    }),
-  },
-  openSourceContribution: {
-    deleteMany: jest.fn(),
-    createMany: jest.fn(),
-  },
-  achievement: {
-    deleteMany: jest.fn(),
-    createMany: jest.fn(),
-  },
-  $transaction: jest.fn().mockImplementation(async (actions) => {
-    for (const action of actions) {
-      // In a real test, you might want to inspect the actions
-      // For now, we just mock that they succeed
-    }
-    return [];
-  }),
+const mockGitHubSyncService = {
+  syncUserGitHub: jest.fn(),
 };
 
-const mockConfigService = {
-  get: jest.fn().mockReturnValue('mock_github_token'),
+const mockGitHubDatabaseService = {
+  saveContributions: jest.fn(),
+  saveAchievements: jest.fn(),
 };
 
 describe('GitHubService', () => {
   let service: GitHubService;
 
   beforeEach(async () => {
-    mockFetch.mockClear();
     jest.clearAllMocks();
 
     const module: TestingModule = await Test.createTestingModule({
       providers: [
         GitHubService,
-        { provide: PrismaService, useValue: mockPrismaService },
-        { provide: ConfigService, useValue: mockConfigService },
+        {
+          provide: GitHubApiService,
+          useValue: mockGitHubApiService,
+        },
+        {
+          provide: GitHubSyncService,
+          useValue: mockGitHubSyncService,
+        },
+        {
+          provide: GitHubDatabaseService,
+          useValue: mockGitHubDatabaseService,
+        },
       ],
     }).compile();
 
@@ -60,27 +55,22 @@ describe('GitHubService', () => {
   });
 
   describe('getUserProfile', () => {
-    it('should fetch and return a user profile', async () => {
+    it('should delegate to GitHubApiService', async () => {
       const mockProfile = { login: 'testuser', name: 'Test User' };
-      mockFetch.mockResolvedValueOnce({
-        ok: true,
-        json: async () => mockProfile,
-      });
+      mockGitHubApiService.getUserProfile.mockResolvedValueOnce(mockProfile);
 
       const profile = await service.getUserProfile('testuser');
 
       expect(profile).toEqual(mockProfile);
-      expect(mockFetch).toHaveBeenCalledWith(
-        'https://api.github.com/users/testuser',
-        expect.any(Object),
+      expect(mockGitHubApiService.getUserProfile).toHaveBeenCalledWith(
+        'testuser',
       );
     });
 
-    it('should throw HttpException if user not found', async () => {
-      mockFetch.mockResolvedValueOnce({
-        ok: false,
-        status: 404,
-      });
+    it('should propagate errors from GitHubApiService', async () => {
+      mockGitHubApiService.getUserProfile.mockRejectedValueOnce(
+        new HttpException('Not found', 404),
+      );
 
       await expect(service.getUserProfile('nonexistent')).rejects.toThrow(
         HttpException,
@@ -89,58 +79,29 @@ describe('GitHubService', () => {
   });
 
   describe('syncUserGitHub', () => {
-    it('should orchestrate the full sync process', async () => {
-      // Arrange: Mock all the GitHub API responses
-      const mockProfile = {
-        login: 'testuser',
-        name: 'Test User',
-        public_repos: 5,
-      };
-      const mockRepos = [
-        {
-          name: 'repo1',
-          stargazers_count: 10,
-          owner: { login: 'testuser' },
-          created_at: new Date().toISOString(),
-          pushed_at: new Date().toISOString(),
-          html_url: 'url',
-          topics: [],
-        },
-        {
-          name: 'repo2',
-          stargazers_count: 150,
-          owner: { login: 'testuser' },
-          created_at: new Date().toISOString(),
-          pushed_at: new Date().toISOString(),
-          html_url: 'url',
-          topics: [],
+    it('should delegate to syncService', async () => {
+      const mockResult = {
+        success: true,
+        stats: {
+          totalStars: 160,
+          contributionsAdded: 2,
+          achievementsAdded: 1,
         },
-      ];
-      mockFetch
-        .mockResolvedValueOnce({ ok: true, json: async () => mockProfile }) // getUserProfile
-        .mockResolvedValueOnce({ ok: true, json: async () => mockRepos }) // getUserRepos
-        .mockResolvedValueOnce({ ok: true, json: async () => [{}] }) // getRepoCommitCount for repo1
-        .mockResolvedValueOnce({ ok: true, json: async () => [] }) // getRepoPullRequests for repo1
-        .mockResolvedValueOnce({ ok: true, json: async () => [{}] }) // getRepoCommitCount for repo2
-        .mockResolvedValueOnce({ ok: true, json: async () => [] }); // getRepoPullRequests for repo2
-
-      // Act
+      };
+      mockGitHubSyncService.syncUserGitHub.mockResolvedValue(mockResult);
+
       const result = await service.syncUserGitHub(
         'user-id',
         'testuser',
         'resume-id',
       );
 
-      // Assert
-      // Check the final result object
-      expect(result.success).toBe(true);
-      expect(result.stats.totalStars).toBe(160);
-      expect(result.stats.contributionsAdded).toBe(2);
-      expect(result.stats.achievementsAdded).toBe(1); // Only stars achievement
-
-      // Check that the database methods were called
-      expect(mockPrismaService.resume.update).toHaveBeenCalled();
-      expect(mockPrismaService.$transaction).toHaveBeenCalled();
+      expect(result).toEqual(mockResult);
+      expect(mockGitHubSyncService.syncUserGitHub).toHaveBeenCalledWith(
+        'user-id',
+        'testuser',
+        'resume-id',
+      );
     });
   });
 });
diff --git a/src/integrations/github/github.service.ts b/src/integrations/github/github.service.ts
index a1ddb5b..e74c684 100644
--- a/src/integrations/github/github.service.ts
+++ b/src/integrations/github/github.service.ts
@@ -1,386 +1,88 @@
-import { Injectable, HttpException, HttpStatus } from '@nestjs/common';
-import { ConfigService } from '@nestjs/config';
-import { Prisma } from '@prisma/client';
-import { PrismaService } from '../../prisma/prisma.service';
-
-// Using interfaces for clear data contracts with the GitHub API
-interface GitHubUser {
-  login: string;
-  name: string;
-  bio: string;
-  public_repos: number;
-  followers: number;
-  following: number;
-  created_at: string;
-}
-
-interface GitHubRepo {
-  id: number;
-  name: string;
-  full_name: string;
-  description: string;
-  html_url: string;
-  stargazers_count: number;
-  forks_count: number;
-  language: string;
-  topics: string[];
-  created_at: string;
-  updated_at: string;
-  pushed_at: string;
-  owner: {
-    login: string;
-  };
-}
+/**
+ * GitHub Service (Facade)
+ * Provides unified API for GitHub operations
+ * Delegates to specialized services for implementation
+ */
 
-// DTO for creating DB records, using Prisma's generated types
-type GitHubContributionInput = Prisma.OpenSourceContributionCreateManyInput;
-type GitHubAchievementInput = Prisma.AchievementCreateManyInput;
+import { Injectable, HttpException, HttpStatus } from '@nestjs/common';
+import { API_LIMITS } from '../../common/constants/app.constants';
+import {
+  GitHubApiService,
+  GitHubSyncService,
+  GitHubDatabaseService,
+} from './services';
 
 @Injectable()
 export class GitHubService {
-  private readonly apiUrl = 'https://api.github.com';
-  private readonly githubToken: string;
-
   constructor(
-    private readonly prisma: PrismaService,
-    private readonly configService: ConfigService,
-  ) {
-    this.githubToken = this.configService.get<string>('GITHUB_TOKEN') || '';
-  }
+    private readonly apiService: GitHubApiService,
+    private readonly syncService: GitHubSyncService,
+    private readonly databaseService: GitHubDatabaseService,
+  ) {}
 
-  private async fetchGitHub<T>(endpoint: string): Promise<T> {
-    const headers: Record<string, string> = {
-      Accept: 'application/vnd.github.v3+json',
-    };
-
-    if (this.githubToken) {
-      headers['Authorization'] = `Bearer ${this.githubToken}`;
-    }
+  // ==================== Public API Delegation ====================
 
-    const response = await fetch(`${this.apiUrl}${endpoint}`, { headers });
-
-    if (!response.ok) {
-      if (response.status === 404) {
-        throw new HttpException(
-          'GitHub resource not found',
-          HttpStatus.NOT_FOUND,
-        );
-      }
-      if (response.status === 403) {
-        throw new HttpException(
-          'GitHub API rate limit exceeded',
-          HttpStatus.FORBIDDEN,
-        );
-      }
-      throw new HttpException(
-        `Failed to fetch from GitHub: ${response.statusText}`,
-        HttpStatus.BAD_GATEWAY,
-      );
-    }
-
-    return response.json() as Promise<T>;
+  async getUserProfile(username: string) {
+    return this.apiService.getUserProfile(username);
   }
 
-  /**
-   * Fetch user's GitHub profile
-   */
-  async getUserProfile(username: string): Promise<GitHubUser> {
-    return this.fetchGitHub<GitHubUser>(`/users/${username}`);
+  async getUserRepos(username: string, options = {}) {
+    return this.apiService.getUserRepos(username, options);
   }
 
-  /**
-   * Fetch user's repositories
-   */
-  async getUserRepos(
-    username: string,
-    options: {
-      sort?: 'created' | 'updated' | 'pushed' | 'full_name';
-      per_page?: number;
-    } = {},
-  ): Promise<GitHubRepo[]> {
-    const sort = options.sort || 'updated';
-    const perPage = options.per_page || 100;
-    return this.fetchGitHub<GitHubRepo[]>(
-      `/users/${username}/repos?sort=${sort}&per_page=${perPage}`,
-    );
-  }
-
-  /**
-   * Calculate total stars across all repos
-   */
   async getTotalStars(username: string): Promise<number> {
-    const repos = await this.getUserRepos(username);
+    const repos = await this.apiService.getUserRepos(username);
     return repos.reduce((total, repo) => total + repo.stargazers_count, 0);
   }
 
-  /**
-   * Get commit count for a specific repository
-   */
-  async getRepoCommitCount(
-    owner: string,
-    repo: string,
-    username: string,
-  ): Promise<number> {
-    try {
-      // For now, we'll fetch up to 100 commits as an estimate
-      const allCommits = await this.fetchGitHub<unknown[]>(
-        `/repos/${owner}/${repo}/commits?author=${username}&per_page=100`,
-      );
-      return Array.isArray(allCommits) ? allCommits.length : 0;
-    } catch {
-      // If we can't access commits (private repo, etc), return 0
-      return 0;
-    }
-  }
+  // ==================== Sync Operations ====================
 
-  /**
-   * Get pull request count for a repository
-   */
-  async getRepoPullRequests(
-    owner: string,
-    repo: string,
-    username: string,
-  ): Promise<number> {
-    try {
-      const prs = await this.fetchGitHub<unknown[]>(
-        `/repos/${owner}/${repo}/pulls?creator=${username}&state=all&per_page=100`,
-      );
-      return Array.isArray(prs) ? prs.length : 0;
-    } catch {
-      return 0;
-    }
-  }
-
-  /**
-   * Get issues created by user in a repository
-   */
-  async getRepoIssues(
-    owner: string,
-    repo: string,
-    username: string,
-  ): Promise<number> {
-    try {
-      const issues = await this.fetchGitHub<unknown[]>(
-        `/repos/${owner}/${repo}/issues?creator=${username}&state=all&per_page=100`,
-      );
-      return Array.isArray(issues) ? issues.length : 0;
-    } catch {
-      return 0;
-    }
-  }
-
-  // ... (rest of the file is unchanged for now)
-  /**
-   * Sync user's GitHub data to database.
-   * This method orchestrates the fetching, processing, and storing of GitHub data.
-   */
   async syncUserGitHub(
     userId: string,
     githubUsername: string,
     resumeId: string,
   ) {
-    await this._verifyResumeOwnership(userId, resumeId);
-
-    try {
-      // Fetch GitHub profile
-      const profile = await this.getUserProfile(githubUsername);
-      const repos = await this.getUserRepos(githubUsername, {
-        sort: 'updated',
-        per_page: 100,
-      });
-      const totalStars = repos.reduce(
-        (sum, repo) => sum + repo.stargazers_count,
-        0,
-      );
-
-      await this._updateResumeWithGitHubStats(
-        resumeId,
-        githubUsername,
-        totalStars,
-      );
-
-      const contributions = await this._fetchAndProcessContributions(
-        resumeId,
-        githubUsername,
-        repos.slice(0, 20),
-      );
-
-      const achievements = this._generateAchievements(
-        resumeId,
-        githubUsername,
-        profile,
-        totalStars,
-      );
-
-      await this._reconcileDbEntries(
-        resumeId,
-        githubUsername,
-        contributions,
-        achievements,
-      );
-
-      return {
-        success: true,
-        profile: {
-          username: profile.login,
-          name: profile.name,
-          bio: profile.bio,
-          publicRepos: profile.public_repos,
-        },
-        stats: {
-          totalStars,
-          publicRepos: profile.public_repos,
-          contributionsAdded: contributions.length,
-          achievementsAdded: achievements.length,
-        },
-      };
-    } catch (error) {
-      if (error instanceof HttpException) throw error;
-      throw new HttpException(
-        'Failed to sync GitHub data',
-        HttpStatus.INTERNAL_SERVER_ERROR,
-      );
-    }
+    return this.syncService.syncUserGitHub(userId, githubUsername, resumeId);
   }
 
-  private async _updateResumeWithGitHubStats(
-    resumeId: string,
-    githubUsername: string,
-    totalStars: number,
-  ) {
-    return this.prisma.resume.update({
-      where: { id: resumeId },
-      data: {
-        github: `https://github.com/${githubUsername}`,
-        totalStars,
-      },
-    });
+  async autoSyncGitHubFromResume(userId: string, resumeId: string) {
+    return this.syncService.autoSyncGitHubFromResume(userId, resumeId);
   }
 
-  private async _fetchAndProcessContributions(
-    resumeId: string,
-    githubUsername: string,
-    repos: GitHubRepo[],
-  ): Promise<GitHubContributionInput[]> {
-    const contributions: GitHubContributionInput[] = [];
-    for (const repo of repos) {
-      if (repo.stargazers_count > 0 || repo.owner.login === githubUsername) {
-        const commits = await this.getRepoCommitCount(
-          repo.owner.login,
-          repo.name,
-          githubUsername,
-        );
-        const pullRequests = await this.getRepoPullRequests(
-          repo.owner.login,
-          repo.name,
-          githubUsername,
-        );
-
-        let role: 'maintainer' | 'core_contributor' | 'contributor';
-        if (repo.owner.login === githubUsername) role = 'maintainer';
-        else if (commits > 10 || pullRequests > 5) role = 'core_contributor';
-        else role = 'contributor';
-
-        contributions.push({
-          resumeId,
-          projectName: repo.name,
-          projectUrl: repo.html_url,
-          role,
-          description: repo.description || undefined,
-          technologies: repo.topics || (repo.language ? [repo.language] : []),
-          commits: commits || undefined,
-          prsCreated: pullRequests || undefined,
-          stars: repo.stargazers_count > 0 ? repo.stargazers_count : undefined,
-          startDate: new Date(repo.created_at),
-          isCurrent:
-            new Date(repo.pushed_at) >
-            new Date(Date.now() - 90 * 24 * 60 * 60 * 1000), // Active in last 90 days
-        });
-      }
-    }
-    return contributions;
-  }
+  async getSyncStatus(userId: string, resumeId: string) {
+    const resume = await this.databaseService.verifyResumeOwnership(
+      userId,
+      resumeId,
+      {
+        openSource: { where: { projectUrl: { contains: 'github.com' } } },
+        achievements: { where: { type: 'github_stars' } },
+      },
+    );
 
-  private _generateAchievements(
-    resumeId: string,
-    githubUsername: string,
-    profile: GitHubUser,
-    totalStars: number,
-  ): GitHubAchievementInput[] {
-    const achievements: GitHubAchievementInput[] = [];
-    if (totalStars >= 100) {
-      achievements.push({
-        resumeId,
-        type: 'github_stars',
-        title: `${totalStars}+ GitHub Stars`,
-        description: `Accumulated ${totalStars} stars across all repositories`,
-        verificationUrl: `https://github.com/${githubUsername}`,
-        achievedAt: new Date(),
-        value: totalStars,
-      });
-    }
-    if (profile.public_repos >= 20) {
-      achievements.push({
-        resumeId,
-        type: 'custom',
-        title: `${profile.public_repos} Public Repositories`,
-        description:
-          'Active open source contributor with multiple public projects',
-        verificationUrl: `https://github.com/${githubUsername}?tab=repositories`,
-        achievedAt: new Date(),
-        value: profile.public_repos,
-      });
-    }
-    return achievements;
-  }
+    const openSourceList =
+      'openSource' in resume ? (resume.openSource as unknown[]) : [];
+    const achievementsList =
+      'achievements' in resume ? (resume.achievements as unknown[]) : [];
+    const github = (resume as { github?: string | null }).github;
 
-  private async _reconcileDbEntries(
-    resumeId: string,
-    githubUsername: string,
-    contributions: GitHubContributionInput[],
-    achievements: GitHubAchievementInput[],
-  ) {
-    // Use a transaction to ensure atomicity
-    return this.prisma.$transaction([
-      // Delete existing GitHub-synced contributions
-      this.prisma.openSourceContribution.deleteMany({
-        where: {
-          resumeId,
-          projectUrl: { contains: 'github.com' },
-        },
-      }),
-      // Create new contributions if any
-      ...(contributions.length > 0
-        ? [
-            this.prisma.openSourceContribution.createMany({
-              data: contributions,
-            }),
-          ]
-        : []),
-      // Delete existing GitHub achievements
-      this.prisma.achievement.deleteMany({
-        where: {
-          resumeId,
-          OR: [
-            { type: 'github_stars' },
-            { verificationUrl: { contains: `github.com/${githubUsername}` } },
-          ],
-        },
-      }),
-      // Create new achievements if any
-      ...(achievements.length > 0
-        ? [this.prisma.achievement.createMany({ data: achievements })]
-        : []),
-    ]);
+    return {
+      hasSynced: openSourceList.length > 0 || achievementsList.length > 0,
+      lastSyncedAt: resume.updatedAt,
+      githubUsername: github ? this.extractUsername(github) : null,
+      stats: {
+        totalStars: (resume as { totalStars?: number }).totalStars ?? 0,
+        openSourceProjects: openSourceList.length,
+        achievements: achievementsList.length,
+      },
+    };
   }
 
-  /**
-   * Get GitHub activity summary without syncing to database
-   */
   async getGitHubSummary(username: string) {
     try {
-      const profile = await this.getUserProfile(username);
-      const repos = await this.getUserRepos(username, { per_page: 100 });
+      const profile = await this.apiService.getUserProfile(username);
+      const repos = await this.apiService.getUserRepos(username, {
+        per_page: 100,
+      });
       const totalStars = repos.reduce(
         (sum, repo) => sum + repo.stargazers_count,
         0,
@@ -388,7 +90,7 @@ export class GitHubService {
 
       const topRepos = repos
         .sort((a, b) => b.stargazers_count - a.stargazers_count)
-        .slice(0, 10)
+        .slice(0, API_LIMITS.MAX_CONTRIBUTIONS_TO_SHOW)
         .map((repo) => ({
           name: repo.name,
           description: repo.description,
@@ -407,9 +109,7 @@ export class GitHubService {
         topRepos,
       };
     } catch (error) {
-      if (error instanceof HttpException) {
-        throw error;
-      }
+      if (error instanceof HttpException) throw error;
       throw new HttpException(
         'Failed to fetch GitHub summary',
         HttpStatus.INTERNAL_SERVER_ERROR,
@@ -417,89 +117,11 @@ export class GitHubService {
     }
   }
 
-  /**
-   * Initiates a sync based on the GitHub URL already present in a resume.
-   */
-  async autoSyncGitHubFromResume(userId: string, resumeId: string) {
-    const resume = await this._verifyResumeOwnership(userId, resumeId);
-
-    if (!resume.github) {
-      throw new HttpException(
-        'No GitHub username found in resume',
-        HttpStatus.BAD_REQUEST,
-      );
-    }
-
-    const githubUsername = resume.github
+  private extractUsername(githubUrl: string): string {
+    return githubUrl
       .replace('https://github.com/', '')
       .replace('http://github.com/', '')
       .replace('github.com/', '')
       .split('/')[0];
-
-    return this.syncUserGitHub(userId, githubUsername, resumeId);
-  }
-
-  /**
-   * Retrieves the sync status and stats for a given resume.
-   */
-  async getSyncStatus(userId: string, resumeId: string) {
-    const resume = await this._verifyResumeOwnership(userId, resumeId, {
-      openSource: { where: { projectUrl: { contains: 'github.com' } } },
-      achievements: { where: { type: 'github_stars' } },
-    });
-
-    const openSourceList =
-      'openSource' in resume ? (resume.openSource as unknown[]) : [];
-    const achievementsList =
-      'achievements' in resume ? (resume.achievements as unknown[]) : [];
-    const updatedAt = resume.updatedAt;
-    const github = (resume as { github?: string | null }).github;
-
-    const githubUsername = github
-      ? github
-          .replace('https://github.com/', '')
-          .replace('http://github.com/', '')
-          .replace('github.com/', '')
-          .split('/')[0]
-      : null;
-
-    return {
-      hasSynced: openSourceList.length > 0 || achievementsList.length > 0,
-      lastSyncedAt: updatedAt,
-      githubUsername,
-      stats: {
-        totalStars: (resume as { totalStars?: number }).totalStars ?? 0,
-        openSourceProjects: openSourceList.length,
-        achievements: achievementsList.length,
-      },
-    };
-  }
-
-  /**
-   * Verifies that a resume exists and belongs to the specified user.
-   * Throws HttpException if checks fail.
-   * @returns The resume object if ownership is verified.
-   */
-  private async _verifyResumeOwnership(
-    userId: string,
-    resumeId: string,
-    include?: Prisma.ResumeInclude,
-  ) {
-    const resume = await this.prisma.resume.findUnique({
-      where: { id: resumeId },
-      include,
-    });
-
-    if (!resume) {
-      throw new HttpException('Resume not found', HttpStatus.NOT_FOUND);
-    }
-
-    if (resume.userId !== userId) {
-      throw new HttpException(
-        'You do not have permission to access this resume',
-        HttpStatus.FORBIDDEN,
-      );
-    }
-    return resume;
   }
 }
diff --git a/src/integrations/github/services/github-achievement.service.ts b/src/integrations/github/services/github-achievement.service.ts
new file mode 100644
index 0000000..921b65b
--- /dev/null
+++ b/src/integrations/github/services/github-achievement.service.ts
@@ -0,0 +1,77 @@
+/**
+ * GitHub Achievement Service
+ * Single Responsibility: Generate achievements based on GitHub stats
+ */
+
+import { Injectable } from '@nestjs/common';
+import { Prisma } from '@prisma/client';
+import { GitHubUser } from './github-api.service';
+
+type GitHubAchievementInput = Prisma.AchievementCreateManyInput;
+
+// Achievement thresholds
+const STAR_THRESHOLD = 100;
+const REPO_THRESHOLD = 20;
+
+@Injectable()
+export class GitHubAchievementService {
+  generateAchievements(
+    resumeId: string,
+    githubUsername: string,
+    profile: GitHubUser,
+    totalStars: number,
+  ): GitHubAchievementInput[] {
+    const achievements: GitHubAchievementInput[] = [];
+
+    if (totalStars >= STAR_THRESHOLD) {
+      achievements.push(
+        this.createStarsAchievement(resumeId, githubUsername, totalStars),
+      );
+    }
+
+    if (profile.public_repos >= REPO_THRESHOLD) {
+      achievements.push(
+        this.createReposAchievement(
+          resumeId,
+          githubUsername,
+          profile.public_repos,
+        ),
+      );
+    }
+
+    return achievements;
+  }
+
+  private createStarsAchievement(
+    resumeId: string,
+    githubUsername: string,
+    totalStars: number,
+  ): GitHubAchievementInput {
+    return {
+      resumeId,
+      type: 'github_stars',
+      title: `${totalStars}+ GitHub Stars`,
+      description: `Accumulated ${totalStars} stars across all repositories`,
+      verificationUrl: `https://github.com/${githubUsername}`,
+      achievedAt: new Date(),
+      value: totalStars,
+    };
+  }
+
+  private createReposAchievement(
+    resumeId: string,
+    githubUsername: string,
+    repoCount: number,
+  ): GitHubAchievementInput {
+    return {
+      resumeId,
+      type: 'custom',
+      title: `${repoCount} Public Repositories`,
+      description:
+        'Active open source contributor with multiple public projects',
+      verificationUrl: `https://github.com/${githubUsername}?tab=repositories`,
+      achievedAt: new Date(),
+      value: repoCount,
+    };
+  }
+}
diff --git a/src/integrations/github/services/github-api.service.ts b/src/integrations/github/services/github-api.service.ts
new file mode 100644
index 0000000..1eb1dcf
--- /dev/null
+++ b/src/integrations/github/services/github-api.service.ts
@@ -0,0 +1,122 @@
+/**
+ * GitHub API Service
+ * Single Responsibility: Raw API calls to GitHub's REST API
+ */
+
+import { Injectable, HttpException, HttpStatus } from '@nestjs/common';
+import { ConfigService } from '@nestjs/config';
+import {
+  GitHubUser,
+  GitHubRepo,
+  GitHubFetchOptions,
+} from '../types/github.types';
+
+// Re-export types for backward compatibility
+export { GitHubUser, GitHubRepo };
+
+@Injectable()
+export class GitHubApiService {
+  private readonly apiUrl = 'https://api.github.com';
+  private readonly githubToken: string;
+
+  constructor(private readonly configService: ConfigService) {
+    this.githubToken = this.configService.get<string>('GITHUB_TOKEN') ?? '';
+  }
+
+  async fetchGitHub<T>(endpoint: string): Promise<T> {
+    const headers: Record<string, string> = {
+      Accept: 'application/vnd.github.v3+json',
+    };
+
+    if (this.githubToken) {
+      headers['Authorization'] = `Bearer ${this.githubToken}`;
+    }
+
+    const response = await fetch(`${this.apiUrl}${endpoint}`, { headers });
+
+    if (!response.ok) {
+      this.handleApiError(response);
+    }
+
+    return response.json() as Promise<T>;
+  }
+
+  async getUserProfile(username: string): Promise<GitHubUser> {
+    return this.fetchGitHub<GitHubUser>(`/users/${username}`);
+  }
+
+  async getUserRepos(
+    username: string,
+    options: GitHubFetchOptions = {},
+  ): Promise<GitHubRepo[]> {
+    const sort = options.sort ?? 'updated';
+    const perPage = options.per_page ?? 100;
+    return this.fetchGitHub<GitHubRepo[]>(
+      `/users/${username}/repos?sort=${sort}&per_page=${perPage}`,
+    );
+  }
+
+  async getRepoCommitCount(
+    owner: string,
+    repo: string,
+    username: string,
+  ): Promise<number> {
+    try {
+      const commits = await this.fetchGitHub<unknown[]>(
+        `/repos/${owner}/${repo}/commits?author=${username}&per_page=100`,
+      );
+      return Array.isArray(commits) ? commits.length : 0;
+    } catch {
+      return 0;
+    }
+  }
+
+  async getRepoPullRequests(
+    owner: string,
+    repo: string,
+    username: string,
+  ): Promise<number> {
+    try {
+      const prs = await this.fetchGitHub<unknown[]>(
+        `/repos/${owner}/${repo}/pulls?creator=${username}&state=all&per_page=100`,
+      );
+      return Array.isArray(prs) ? prs.length : 0;
+    } catch {
+      return 0;
+    }
+  }
+
+  async getRepoIssues(
+    owner: string,
+    repo: string,
+    username: string,
+  ): Promise<number> {
+    try {
+      const issues = await this.fetchGitHub<unknown[]>(
+        `/repos/${owner}/${repo}/issues?creator=${username}&state=all&per_page=100`,
+      );
+      return Array.isArray(issues) ? issues.length : 0;
+    } catch {
+      return 0;
+    }
+  }
+
+  private handleApiError(response: Response): never {
+    if (response.status === 404) {
+      throw new HttpException(
+        'GitHub resource not found',
+        HttpStatus.NOT_FOUND,
+      );
+    }
+    if (response.status === 403) {
+      throw new HttpException(
+        'GitHub API rate limit exceeded',
+        HttpStatus.FORBIDDEN,
+      );
+    }
+    throw new HttpException(
+      `Failed to fetch from GitHub: ${response.statusText}`,
+      HttpStatus.BAD_GATEWAY,
+    );
+  }
+}
diff --git a/src/integrations/github/services/github-contribution.service.ts b/src/integrations/github/services/github-contribution.service.ts
new file mode 100644
index 0000000..6e8706c
--- /dev/null
+++ b/src/integrations/github/services/github-contribution.service.ts
@@ -0,0 +1,104 @@
+/**
+ * GitHub Contribution Service
+ * Single Responsibility: Process and format contribution data
+ */
+
+import { Injectable } from '@nestjs/common';
+import { Prisma } from '@prisma/client';
+import { GitHubApiService, GitHubRepo } from './github-api.service';
+import { TIME_MS } from '../../../common/constants/app.constants';
+
+type GitHubContributionInput = Prisma.OpenSourceContributionCreateManyInput;
+
+const ACTIVITY_THRESHOLD_DAYS = 90;
+
+@Injectable()
+export class GitHubContributionService {
+  constructor(private readonly apiService: GitHubApiService) {}
+
+  async processContributions(
+    resumeId: string,
+    githubUsername: string,
+    repos: GitHubRepo[],
+  ): Promise<GitHubContributionInput[]> {
+    const contributions: GitHubContributionInput[] = [];
+
+    for (const repo of repos) {
+      if (this.shouldIncludeRepo(repo, githubUsername)) {
+        const contribution = await this.buildContribution(
+          resumeId,
+          githubUsername,
+          repo,
+        );
+        contributions.push(contribution);
+      }
+    }
+
+    return contributions;
+  }
+
+  private shouldIncludeRepo(repo: GitHubRepo, username: string): boolean {
+    return repo.stargazers_count > 0 || repo.owner.login === username;
+  }
+
+  private async buildContribution(
+    resumeId: string,
+    githubUsername: string,
+    repo: GitHubRepo,
+  ): Promise<GitHubContributionInput> {
+    const commits = await this.apiService.getRepoCommitCount(
+      repo.owner.login,
+      repo.name,
+      githubUsername,
+    );
+    const pullRequests = await this.apiService.getRepoPullRequests(
+      repo.owner.login,
+      repo.name,
+      githubUsername,
+    );
+
+    const role = this.determineRole(
+      repo,
+      githubUsername,
+      commits,
+      pullRequests,
+    );
+    const isCurrent = this.isRecentlyActive(repo.pushed_at);
+
+    return {
+      resumeId,
+      projectName: repo.name,
+      projectUrl: repo.html_url,
+      role,
+      description: repo.description || undefined,
+      technologies:
+        repo.topics.length > 0
+          ? repo.topics
+          : repo.language
+            ? [repo.language]
+            : [],
+      commits: commits || undefined,
+      prsCreated: pullRequests || undefined,
+      stars: repo.stargazers_count > 0 ? repo.stargazers_count : undefined,
+      startDate: new Date(repo.created_at),
+      isCurrent,
+    };
+  }
+
+  private determineRole(
+    repo: GitHubRepo,
+    username: string,
+    commits: number,
+    pullRequests: number,
+  ): 'maintainer' | 'core_contributor' | 'contributor' {
+    if (repo.owner.login === username) return 'maintainer';
+    if (commits > 10 || pullRequests > 5) return 'core_contributor';
+    return 'contributor';
+  }
+
+  private isRecentlyActive(pushedAt: string): boolean {
+    const activityThreshold =
+      Date.now() - ACTIVITY_THRESHOLD_DAYS * TIME_MS.DAY;
+    return new Date(pushedAt) > new Date(activityThreshold);
+  }
+}
diff --git a/src/integrations/github/services/github-database.service.ts b/src/integrations/github/services/github-database.service.ts
new file mode 100644
index 0000000..a216e4d
--- /dev/null
+++ b/src/integrations/github/services/github-database.service.ts
@@ -0,0 +1,87 @@
+/**
+ * GitHub Database Service
+ * Single Responsibility: Database operations for GitHub sync
+ */
+
+import { Injectable, HttpException, HttpStatus } from '@nestjs/common';
+import { Prisma } from '@prisma/client';
+import { PrismaService } from '../../../prisma/prisma.service';
+import { ERROR_MESSAGES } from '../../../common/constants/app.constants';
+
+@Injectable()
+export class GitHubDatabaseService {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async verifyResumeOwnership(
+    userId: string,
+    resumeId: string,
+    include?: Prisma.ResumeInclude,
+  ) {
+    const resume = await this.prisma.resume.findUnique({
+      where: { id: resumeId },
+      include,
+    });
+
+    if (!resume) {
+      throw new HttpException(
+        ERROR_MESSAGES.RESUME_NOT_FOUND,
+        HttpStatus.NOT_FOUND,
+      );
+    }
+
+    if (resume.userId !== userId) {
+      throw new HttpException(
+        ERROR_MESSAGES.ACCESS_DENIED,
+        HttpStatus.FORBIDDEN,
+      );
+    }
+
+    return resume;
+  }
+
+  async updateResumeGitHubStats(
+    resumeId: string,
+    githubUsername: string,
+    totalStars: number,
+  ) {
+    return this.prisma.resume.update({
+      where: { id: resumeId },
+      data: {
+        github: `https://github.com/${githubUsername}`,
+        totalStars,
+      },
+    });
+  }
+
+  async reconcileDbEntries(
+    resumeId: string,
+    githubUsername: string,
+    contributions: Prisma.OpenSourceContributionCreateManyInput[],
+    achievements: Prisma.AchievementCreateManyInput[],
+  ) {
+    return this.prisma.$transaction([
+      this.prisma.openSourceContribution.deleteMany({
+        where: { resumeId, projectUrl: { contains: 'github.com' } },
+      }),
+      ...(contributions.length > 0
+        ? [
+            this.prisma.openSourceContribution.createMany({
+              data: contributions,
+            }),
+          ]
+        : []),
+      this.prisma.achievement.deleteMany({
+        where: {
+          resumeId,
+          OR: [
+            { type: 'github_stars' },
+            { verificationUrl: { contains: `github.com/${githubUsername}` } },
+          ],
+        },
+      }),
+      ...(achievements.length > 0
+        ? [this.prisma.achievement.createMany({ data: achievements })]
+        : []),
+    ]);
+  }
+}
diff --git a/src/integrations/github/services/github-sync.service.ts b/src/integrations/github/services/github-sync.service.ts
new file mode 100644
index 0000000..8708053
--- /dev/null
+++ b/src/integrations/github/services/github-sync.service.ts
@@ -0,0 +1,114 @@
+/**
+ * GitHub Sync Service
+ * Single Responsibility: Orchestrate GitHub sync operations
+ */
+
+import { Injectable, HttpException, HttpStatus } from '@nestjs/common';
+import { API_LIMITS } from '../../../common/constants/app.constants';
+import { GitHubApiService } from './github-api.service';
+import { GitHubContributionService } from './github-contribution.service';
+import { GitHubAchievementService } from './github-achievement.service';
+import { GitHubDatabaseService } from './github-database.service';
+
+@Injectable()
+export class GitHubSyncService {
+  constructor(
+    private readonly apiService: GitHubApiService,
+    private readonly contributionService: GitHubContributionService,
+    private readonly achievementService: GitHubAchievementService,
+    private readonly databaseService: GitHubDatabaseService,
+  ) {}
+
+  async syncUserGitHub(
+    userId: string,
+    githubUsername: string,
+    resumeId: string,
+  ) {
+    await this.databaseService.verifyResumeOwnership(userId, resumeId);
+
+    try {
+      const profile = await this.apiService.getUserProfile(githubUsername);
+      const repos = await this.apiService.getUserRepos(githubUsername, {
+        sort: 'updated',
+        per_page: 100,
+      });
+      const totalStars = repos.reduce(
+        (sum, repo) => sum + repo.stargazers_count,
+        0,
+      );
+
+      await this.databaseService.updateResumeGitHubStats(
+        resumeId,
+        githubUsername,
+        totalStars,
+      );
+
+      const contributions = await this.contributionService.processContributions(
+        resumeId,
+        githubUsername,
+        repos.slice(0, API_LIMITS.MAX_REPOS_TO_PROCESS),
+      );
+
+      const achievements = this.achievementService.generateAchievements(
+        resumeId,
+        githubUsername,
+        profile,
+        totalStars,
+      );
+
+      await this.databaseService.reconcileDbEntries(
+        resumeId,
+        githubUsername,
+        contributions,
+        achievements,
+      );
+
+      return {
+        success: true,
+        profile: {
+          username: profile.login,
+          name: profile.name,
+          bio: profile.bio,
+          publicRepos: profile.public_repos,
+        },
+        stats: {
+          totalStars,
+          publicRepos: profile.public_repos,
+          contributionsAdded: contributions.length,
+          achievementsAdded: achievements.length,
+        },
+      };
+    } catch (error) {
+      if (error instanceof HttpException) throw error;
+      throw new HttpException(
+        'Failed to sync GitHub data',
+        HttpStatus.INTERNAL_SERVER_ERROR,
+      );
+    }
+  }
+
+  async autoSyncGitHubFromResume(userId: string, resumeId: string) {
+    const resume = await this.databaseService.verifyResumeOwnership(
+      userId,
+      resumeId,
+    );
+
+    if (!resume.github) {
+      throw new HttpException(
+        'No GitHub username found in resume',
+        HttpStatus.BAD_REQUEST,
+      );
+    }
+
+    const githubUsername = this.extractUsername(resume.github);
+    return this.syncUserGitHub(userId, githubUsername, resumeId);
+  }
+
+  private extractUsername(githubUrl: string): string {
+    return githubUrl
+      .replace('https://github.com/', '')
+      .replace('http://github.com/', '')
+      .replace('github.com/', '')
+      .split('/')[0];
+  }
+}
diff --git a/src/integrations/github/services/index.ts b/src/integrations/github/services/index.ts
new file mode 100644
index 0000000..34c79b2
--- /dev/null
+++ b/src/integrations/github/services/index.ts
@@ -0,0 +1,9 @@
+/**
+ * GitHub Services Barrel Export
+ */
+
+export { GitHubApiService, GitHubUser, GitHubRepo } from './github-api.service';
+export { GitHubContributionService } from './github-contribution.service';
+export { GitHubAchievementService } from './github-achievement.service';
+export { GitHubDatabaseService } from './github-database.service';
+export { GitHubSyncService } from './github-sync.service';
diff --git a/src/integrations/github/types/github.types.ts b/src/integrations/github/types/github.types.ts
new file mode 100644
index 0000000..3299a85
--- /dev/null
+++ b/src/integrations/github/types/github.types.ts
@@ -0,0 +1,36 @@
+/**
+ * GitHub API Type Definitions
+ */
+
+export interface GitHubUser {
+  login: string;
+  name: string;
+  bio: string;
+  public_repos: number;
+  followers: number;
+  following: number;
+  created_at: string;
+}
+
+export interface GitHubRepo {
+  id: number;
+  name: string;
+  full_name: string;
+  description: string;
+  html_url: string;
+  stargazers_count: number;
+  forks_count: number;
+  language: string;
+  topics: string[];
+  created_at: string;
+  updated_at: string;
+  pushed_at: string;
+  owner: {
+    login: string;
+  };
+}
+
+export interface GitHubFetchOptions {
+  sort?: 'created' | 'updated' | 'pushed' | 'full_name';
+  per_page?: number;
+}
diff --git a/src/main.ts b/src/main.ts
index c75deb6..e1089a1 100644
--- a/src/main.ts
+++ b/src/main.ts
@@ -1,278 +1,63 @@
-import { NestFactory, Reflector } from '@nestjs/core';
-import { ValidationPipe } from '@nestjs/common';
-import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
-import { apiReference } from '@scalar/nestjs-api-reference';
-import helmet from 'helmet';
+import { NestFactory } from '@nestjs/core';
 import { AppModule } from './app.module';
-import { JwtAuthGuard } from './auth/guards/jwt-auth.guard';
 import { AppLoggerService } from './common/logger/logger.service';
-import { AllExceptionsFilter } from './common/filters/http-exception.filter';
-
+import {
+  configureSecurityHeaders,
+  configureCors,
+} from './common/config/security.config';
+import {
+  configureValidation,
+  configureExceptionHandling,
+  configureGlobalGuards,
+} from './common/config/validation.config';
+import {
+  configureSwagger,
+  isSwaggerEnabled,
+} from './common/config/swagger.config';
+
+/**
+ * Bootstrap the NestJS application
+ *
+ * Uncle Bob's SRP: This function only orchestrates startup.
+ * All configuration logic is delegated to specialized modules.
+ */
 async function bootstrap() {
-  const app = await NestFactory.create(AppModule, {
-    bufferLogs: true,
-  });
-
-  // Custom logger
+  const app = await NestFactory.create(AppModule, { bufferLogs: true });
   const logger = app.get(AppLoggerService);
-  app.useLogger(logger);
-
-  // Swagger documentation enabled check
-  const enableSwagger =
-    process.env.ENABLE_SWAGGER === 'true' ||
-    (process.env.ENABLE_SWAGGER !== 'false' &&
-      process.env.NODE_ENV !== 'production');
-
-  // Security - Helmet with relaxed CSP when Swagger is enabled
-  app.use(
-    helmet({
-      contentSecurityPolicy: enableSwagger
-        ? {
-            directives: {
-              defaultSrc: ["'self'"],
-              scriptSrc: [
-                "'self'",
-                "'unsafe-inline'",
-                "'unsafe-eval'",
-                'https://cdn.jsdelivr.net',
-              ],
-              styleSrc: ["'self'", "'unsafe-inline'", 'https:'],
-              fontSrc: ["'self'", 'https:', 'data:'],
-              imgSrc: ["'self'", 'data:', 'https:'],
-              connectSrc: ["'self'", 'https:'],
-              workerSrc: ["'self'", 'blob:'],
-            },
-          }
-        : undefined,
-    }),
-  );
-
-  // Enable CORS
-  app.enableCors({
-    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
-    credentials: true,
-    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
-    allowedHeaders: ['Content-Type', 'Authorization', 'Accept'],
-  });
-
-  // Global exception filter
-  app.useGlobalFilters(new AllExceptionsFilter(logger));
 
-  // Global validation pipe
-  app.useGlobalPipes(
-    new ValidationPipe({
-      whitelist: true,
-      forbidNonWhitelisted: false,
-      transform: true,
-      transformOptions: {
-        enableImplicitConversion: true,
-      },
-    }),
-  );
-
-  // Global JWT Auth Guard with Reflector for @Public() decorator
-  const reflector = app.get(Reflector);
-  app.useGlobalGuards(new JwtAuthGuard(reflector));
-
-  // Set global prefix
+  app.useLogger(logger);
   app.setGlobalPrefix('api');
 
-  // Swagger documentation (enabled via ENABLE_SWAGGER env var, defaults to true in non-production)
-  if (enableSwagger) {
-    const config = new DocumentBuilder()
-      .setTitle('ProFile API')
-      .setDescription(
-        `
-## ProFile - Resume & Portfolio Management API
+  const swaggerEnabled = isSwaggerEnabled();
 
-ProFile is a comprehensive platform for creating, managing, and exporting professional resumes and portfolios.
+  // Configure application (each function has single responsibility)
+  configureSecurityHeaders(app, swaggerEnabled);
+  configureCors(app);
+  configureExceptionHandling(app, logger);
+  configureValidation(app);
+  configureGlobalGuards(app);
 
-### Features
-- **Authentication**: JWT-based authentication with email verification and password reset
-- **Resume Management**: Full CRUD operations for resumes with multiple sections
-- **Rich Content Sections**: Education, Experience, Skills, Projects, Certifications, and more
-- **Export Options**: Generate PDF and DOCX documents from resumes
-- **File Upload**: Upload profile pictures and attachments via S3-compatible storage
-- **User Onboarding**: Guided onboarding flow for new users
-
-### Authentication
-All protected endpoints require a valid JWT token in the Authorization header:
-\`\`\`
-Authorization: Bearer <your-jwt-token>
-\`\`\`
-
-### Rate Limiting
-- Authentication endpoints: 5 requests per minute
-- General API: 100 requests per minute
-
-### Error Responses
-All errors follow a consistent format:
-\`\`\`json
-{
-  "statusCode": 400,
-  "message": "Error description",
-  "error": "Bad Request"
-}
-\`\`\`
-      `.trim(),
-      )
-      .setVersion('1.0.0')
-      .setContact(
-        'ProFile Team',
-        'https://github.com/your-org/profile',
-        'support@profile.app',
-      )
-      .setLicense('MIT', 'https://opensource.org/licenses/MIT')
-      .addServer(
-        `http://localhost:${process.env.PORT || 3001}`,
-        'Development Server',
-      )
-      .addBearerAuth(
-        {
-          type: 'http',
-          scheme: 'bearer',
-          bearerFormat: 'JWT',
-          name: 'Authorization',
-          description: 'Enter your JWT token obtained from /api/auth/login',
-          in: 'header',
-        },
-        'JWT-auth',
-      )
-      // Authentication & Authorization
-      .addTag(
-        'auth',
-        'Authentication endpoints - Login, Signup, Password Reset, Email Verification',
-      )
-      .addTag(
-        'users',
-        'User profile management - View and update user information',
-      )
-      .addTag(
-        'onboarding',
-        'User onboarding flow - Complete profile setup for new users',
-      )
-      // Resume Management
-      .addTag(
-        'resumes',
-        'Resume CRUD operations - Create, read, update, and delete resumes with all sections',
-      )
-      // File Management
-      .addTag(
-        'upload',
-        'File upload endpoints - Upload profile pictures and attachments',
-      )
-      .addTag('export', 'Export resumes - Generate PDF and DOCX documents')
-      // Integrations
-      .addTag(
-        'github',
-        'GitHub integration - Import projects and contributions',
-      )
-      .build();
-
-    const document = SwaggerModule.createDocument(app, config, {
-      operationIdFactory: (controllerKey: string, methodKey: string) =>
-        `${controllerKey}_${methodKey}`,
-    });
-
-    // Scalar API Reference with dark purple theme
-    app.use(
-      '/api/docs',
-      apiReference({
-        spec: {
-          content: document,
-        },
-        theme: 'purple',
-        darkMode: true,
-        metaData: {
-          title: 'ProFile API Documentation',
-        },
-        customCss: `
-          /* ProFile Dark Purple Theme */
-          :root {
-            --scalar-background-1: #1a1625 !important;
-            --scalar-background-2: #252033 !important;
-            --scalar-background-3: #3d2e5c !important;
-            --scalar-background-accent: #7c3aed !important;
-
-            --scalar-color-1: #e9d5ff !important;
-            --scalar-color-2: #c9b3ff !important;
-            --scalar-color-3: #a89dc4 !important;
-            --scalar-color-accent: #a78bfa !important;
-
-            --scalar-border-color: #4c3a6e !important;
-
-            --scalar-color-green: #8b5cf6 !important;
-            --scalar-color-blue: #a855f7 !important;
-            --scalar-color-orange: #c084fc !important;
-            --scalar-color-red: #ef4444 !important;
-
-            --scalar-button-1: #7c3aed !important;
-            --scalar-button-1-hover: #6d28d9 !important;
-            --scalar-button-1-color: #ffffff !important;
-          }
-
-          /* Sidebar */
-          .sidebar { background: #1a1625 !important; border-right: 1px solid #4c3a6e !important; }
-          .sidebar-search { background: #252033 !important; border: 1px solid #4c3a6e !important; }
-          .sidebar-search input { color: #e9d5ff !important; }
-          .sidebar-search input::placeholder { color: #8b7aa8 !important; }
-
-          /* Sidebar items */
-          [class*="sidebar"] a, [class*="sidebar"] button { color: #c9b3ff !important; }
-          [class*="sidebar"] a:hover, [class*="sidebar"] button:hover { background: #252033 !important; }
-
-          /* Method badges */
-          .scalar-api-reference [data-method="get"] {
-            background: #8b5cf6 !important;
-            color: #fff !important;
-          }
-          .scalar-api-reference [data-method="post"] {
-            background: #a855f7 !important;
-            color: #fff !important;
-          }
-          .scalar-api-reference [data-method="put"],
-          .scalar-api-reference [data-method="patch"] {
-            background: #c084fc !important;
-            color: #fff !important;
-          }
-          .scalar-api-reference [data-method="delete"] {
-            background: #ef4444 !important;
-            color: #fff !important;
-          }
-
-          /* Content area */
-          .scalar-api-reference { background: #1a1625 !important; }
-          .scalar-card { background: #252033 !important; border-color: #4c3a6e !important; }
-
-          /* Code blocks */
-          pre, code { background: #1e1a2e !important; }
-
-          /* Inputs */
-          input, textarea, select {
-            background: #252033 !important;
-            border-color: #4c3a6e !important;
-            color: #e9d5ff !important;
-          }
-
-          /* Scrollbar */
-          ::-webkit-scrollbar { width: 8px; height: 8px; }
-          ::-webkit-scrollbar-track { background: #1a1625; }
-          ::-webkit-scrollbar-thumb { background: #4c3a6e; border-radius: 4px; }
-          ::-webkit-scrollbar-thumb:hover { background: #6d28d9; }
-        `,
-      }),
-    );
+  if (swaggerEnabled) {
+    configureSwagger(app);
   }
 
-  const port = process.env.PORT || 3001;
+  const port = process.env.PORT ?? '3001';
   await app.listen(port);
 
+  logStartupInfo(logger, port, swaggerEnabled);
+}
+
+function logStartupInfo(
+  logger: AppLoggerService,
+  port: string | number,
+  swaggerEnabled: boolean,
+): void {
   logger.log(
     `Application running on: http://localhost:${port}/api`,
     'Bootstrap',
   );
   logger.log(`Health check: http://localhost:${port}/api/health`, 'Bootstrap');
-  if (process.env.NODE_ENV !== 'production') {
+  if (swaggerEnabled) {
     logger.log(`Swagger docs: http://localhost:${port}/api/docs`, 'Bootstrap');
   }
 }
diff --git a/src/mec-sync/constants/index.ts b/src/mec-sync/constants/index.ts
new file mode 100644
index 0000000..ac0dc32
--- /dev/null
+++ b/src/mec-sync/constants/index.ts
@@ -0,0 +1,5 @@
+/**
+ * MEC Constants barrel export
+ */
+
+export * from './mec.constants';
diff --git a/src/mec-sync/constants/mec.constants.ts b/src/mec-sync/constants/mec.constants.ts
new file mode 100644
index 0000000..56f4522
--- /dev/null
+++ b/src/mec-sync/constants/mec.constants.ts
@@ -0,0 +1,54 @@
+/**
+ * MEC Constants
+ * Single Responsibility: Configuration constants for MEC sync
+ */
+
+import * as path from 'path';
+
+/**
+ * MEC CSV source URL
+ */
+export const MEC_CSV_URL =
+  'https://dadosabertos.mec.gov.br/images/conteudo/Ind-ensino-superior/2022//PDA_Dados_Cursos_Graduacao_Brasil.csv';
+
+/**
+ * Local cache path for downloaded CSV
+ */
+export const LOCAL_CSV_PATH = path.join(
+  process.cwd(),
+  'data',
+  'mec-courses.csv',
+);
+
+/**
+ * Cache validity in days
+ */
+export const CACHE_VALIDITY_DAYS = 6;
+
+/**
+ * Database batch size for bulk inserts
+ */
+export const BATCH_SIZE = 500;
+
+/**
+ * Puppeteer timeouts (in milliseconds)
+ */
+export const PUPPETEER_CONFIG = {
+  NAVIGATION_TIMEOUT: 60000,
+  DOWNLOAD_TIMEOUT: 180000,
+  CHALLENGE_TIMEOUT: 45000,
+  HUMAN_DELAY: 2000,
+} as const;
+
+/**
+ * Puppeteer launch arguments
+ */
+export const PUPPETEER_ARGS = [
+  '--no-sandbox',
+  '--disable-setuid-sandbox',
+  '--disable-dev-shm-usage',
+  '--disable-gpu',
+  '--disable-web-security',
+  '--disable-features=VizDisplayCompositor',
+  '--window-size=1920,1080',
+] as const;
diff --git a/src/mec-sync/controllers/index.ts b/src/mec-sync/controllers/index.ts
new file mode 100644
index 0000000..03d1477
--- /dev/null
+++ b/src/mec-sync/controllers/index.ts
@@ -0,0 +1,8 @@
+/**
+ * MEC Controllers - Barrel Export
+ */
+
+export { MecSyncInternalController } from './mec-sync-internal.controller';
+export { MecInstitutionController } from './mec-institution.controller';
+export { MecCourseController } from './mec-course.controller';
+export { MecMetadataController } from './mec-metadata.controller';
diff --git a/src/mec-sync/controllers/mec-course.controller.ts b/src/mec-sync/controllers/mec-course.controller.ts
new file mode 100644
index 0000000..b4450d2
--- /dev/null
+++ b/src/mec-sync/controllers/mec-course.controller.ts
@@ -0,0 +1,41 @@
+/**
+ * MEC Course Controller
+ * Public API endpoints for MEC course queries
+ */
+
+import { Controller, Get, Query, Param, ParseIntPipe } from '@nestjs/common';
+import { ApiTags, ApiOperation, ApiQuery, ApiParam } from '@nestjs/swagger';
+import { Public } from '../../auth/decorators/public.decorator';
+import { CourseQueryService } from '../services/course-query.service';
+import { APP_CONSTANTS } from '../../common/constants/app.constants';
+
+@ApiTags('mec-courses')
+@Controller('mec/courses')
+export class MecCourseController {
+  constructor(private readonly courseQuery: CourseQueryService) {}
+
+  @Get('search')
+  @Public()
+  @ApiOperation({ summary: 'Search courses' })
+  @ApiQuery({ name: 'q', required: true })
+  @ApiQuery({ name: 'limit', required: false, type: Number })
+  async searchCourses(
+    @Query('q') query: string,
+    @Query('limit') limit?: string,
+  ) {
+    const parsedLimit = limit
+      ? parseInt(limit, 10)
+      : APP_CONSTANTS.DEFAULT_PAGE_SIZE;
+    return this.courseQuery.search(query, parsedLimit);
+  }
+
+  @Get(':codigoCurso')
+  @Public()
+  @ApiOperation({ summary: 'Get course by MEC code' })
+  @ApiParam({ name: 'codigoCurso', type: Number })
+  async getCourseByCode(
+    @Param('codigoCurso', ParseIntPipe) codigoCurso: number,
+  ) {
+    return this.courseQuery.getByCode(codigoCurso);
+  }
+}
diff --git a/src/mec-sync/controllers/mec-institution.controller.ts b/src/mec-sync/controllers/mec-institution.controller.ts
new file mode 100644
index 0000000..8b65550
--- /dev/null
+++ b/src/mec-sync/controllers/mec-institution.controller.ts
@@ -0,0 +1,65 @@
+/**
+ * MEC Institution Controller
+ * Public API endpoints for MEC institution queries
+ */
+
+import { Controller, Get, Query, Param, ParseIntPipe } from '@nestjs/common';
+import { ApiTags, ApiOperation, ApiQuery, ApiParam } from '@nestjs/swagger';
+import { Public } from '../../auth/decorators/public.decorator';
+import { InstitutionQueryService } from '../services/institution-query.service';
+import { CourseQueryService } from '../services/course-query.service';
+import { APP_CONSTANTS } from '../../common/constants/app.constants';
+
+@ApiTags('mec-institutions')
+@Controller('mec/institutions')
+export class MecInstitutionController {
+  constructor(
+    private readonly institutionQuery: InstitutionQueryService,
+    private readonly courseQuery: CourseQueryService,
+  ) {}
+
+  @Get()
+  @Public()
+  @ApiOperation({ summary: 'List institutions' })
+  @ApiQuery({ name: 'uf', required: false, description: 'Filter by state' })
+  async listInstitutions(@Query('uf') uf?: string) {
+    return uf
+      ? this.institutionQuery.listByState(uf)
+      : this.institutionQuery.listAll();
+  }
+
+  @Get('search')
+  @Public()
+  @ApiOperation({ summary: 'Search institutions' })
+  @ApiQuery({ name: 'q', required: true })
+  @ApiQuery({ name: 'limit', required: false, type: Number })
+  async searchInstitutions(
+    @Query('q') query: string,
+    @Query('limit') limit?: string,
+  ) {
+    const parsedLimit = limit
+      ? parseInt(limit, 10)
+      : APP_CONSTANTS.DEFAULT_PAGE_SIZE;
+    return this.institutionQuery.search(query, parsedLimit);
+  }
+
+  @Get(':codigoIes')
+  @Public()
+  @ApiOperation({ summary: 'Get institution by MEC code' })
+  @ApiParam({ name: 'codigoIes', type: Number })
+  async getInstitutionByCode(
+    @Param('codigoIes', ParseIntPipe) codigoIes: number,
+  ) {
+    return this.institutionQuery.getByCode(codigoIes);
+  }
+
+  @Get(':codigoIes/courses')
+  @Public()
+  @ApiOperation({ summary: 'Get courses by institution' })
+  @ApiParam({ name: 'codigoIes', type: Number })
+  async listCoursesByInstitution(
+    @Param('codigoIes', ParseIntPipe) codigoIes: number,
+  ) {
+    return this.courseQuery.listByInstitution(codigoIes);
+  }
+}
diff --git a/src/mec-sync/controllers/mec-metadata.controller.ts b/src/mec-sync/controllers/mec-metadata.controller.ts
new file mode 100644
index 0000000..017fccd
--- /dev/null
+++ b/src/mec-sync/controllers/mec-metadata.controller.ts
@@ -0,0 +1,42 @@
+/**
+ * MEC Metadata Controller
+ * Public API endpoints for MEC metadata (UFs, areas, stats)
+ */
+
+import { Controller, Get } from '@nestjs/common';
+import { ApiTags, ApiOperation } from '@nestjs/swagger';
+import { Public } from '../../auth/decorators/public.decorator';
+import { InstitutionQueryService } from '../services/institution-query.service';
+import { CourseQueryService } from '../services/course-query.service';
+import { MecStatsService } from '../services/mec-stats.service';
+
+@ApiTags('mec-metadata')
+@Controller('mec')
+export class MecMetadataController {
+  constructor(
+    private readonly institutionQuery: InstitutionQueryService,
+    private readonly courseQuery: CourseQueryService,
+    private readonly statsService: MecStatsService,
+  ) {}
+
+  @Get('ufs')
+  @Public()
+  @ApiOperation({ summary: 'List all states (UFs)' })
+  async listStates() {
+    return this.institutionQuery.getStateList();
+  }
+
+  @Get('areas')
+  @Public()
+  @ApiOperation({ summary: 'List knowledge areas' })
+  async listKnowledgeAreas() {
+    return this.courseQuery.getKnowledgeAreas();
+  }
+
+  @Get('stats')
+  @Public()
+  @ApiOperation({ summary: 'Get MEC statistics' })
+  async getStats() {
+    return this.statsService.getStats();
+  }
+}
diff --git a/src/mec-sync/controllers/mec-sync-internal.controller.ts b/src/mec-sync/controllers/mec-sync-internal.controller.ts
new file mode 100644
index 0000000..d8b8be4
--- /dev/null
+++ b/src/mec-sync/controllers/mec-sync-internal.controller.ts
@@ -0,0 +1,75 @@
+/**
+ * MEC Sync Internal Controller
+ * Internal API endpoints for MEC data synchronization (Admin only)
+ */
+
+import {
+  Controller,
+  Get,
+  Post,
+  Query,
+  UseGuards,
+  HttpCode,
+  HttpStatus,
+} from '@nestjs/common';
+import { ApiTags, ApiOperation, ApiQuery, ApiHeader } from '@nestjs/swagger';
+import { InternalAuthGuard } from '../guards/internal-auth.guard';
+import { Public } from '../../auth/decorators/public.decorator';
+import { MecSyncOrchestratorService } from '../services/mec-sync.service';
+import { APP_CONSTANTS } from '../../common/constants/app.constants';
+
+@ApiTags('mec-internal')
+@Controller('mec/internal')
+export class MecSyncInternalController {
+  constructor(private readonly syncOrchestrator: MecSyncOrchestratorService) {}
+
+  @Post('sync')
+  @Public()
+  @UseGuards(InternalAuthGuard)
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({ summary: 'Trigger MEC data synchronization' })
+  @ApiHeader({ name: 'x-internal-token', required: true })
+  async triggerSync() {
+    const result = await this.syncOrchestrator.sync('api');
+
+    return {
+      success: true,
+      message: 'Sync completed successfully',
+      data: {
+        institutionsInserted: result.institutionsInserted,
+        coursesInserted: result.coursesInserted,
+        totalRowsProcessed: result.totalRowsProcessed,
+        errorsCount: result.errors.length,
+      },
+    };
+  }
+
+  @Get('sync/status')
+  @Public()
+  @UseGuards(InternalAuthGuard)
+  @ApiOperation({ summary: 'Get sync status' })
+  @ApiHeader({ name: 'x-internal-token', required: true })
+  async getSyncStatus() {
+    const [isRunning, metadata, lastLog] = await Promise.all([
+      this.syncOrchestrator.isSyncRunning(),
+      this.syncOrchestrator.getSyncMetadata(),
+      this.syncOrchestrator.getLastSyncLog(),
+    ]);
+
+    return { isRunning, metadata, lastSync: lastLog };
+  }
+
+  @Get('sync/history')
+  @Public()
+  @UseGuards(InternalAuthGuard)
+  @ApiOperation({ summary: 'Get sync history' })
+  @ApiHeader({ name: 'x-internal-token', required: true })
+  @ApiQuery({ name: 'limit', required: false, type: Number })
+  async getSyncHistory(@Query('limit') limit?: string) {
+    const parsedLimit = limit
+      ? parseInt(limit, 10)
+      : APP_CONSTANTS.SEARCH_AUTOCOMPLETE_LIMIT;
+    const history = await this.syncOrchestrator.getSyncHistory(parsedLimit);
+    return { history };
+  }
+}
diff --git a/src/mec-sync/dto/course.dto.ts b/src/mec-sync/dto/course.dto.ts
new file mode 100644
index 0000000..4228609
--- /dev/null
+++ b/src/mec-sync/dto/course.dto.ts
@@ -0,0 +1,20 @@
+/**
+ * Course DTOs
+ * Single Responsibility: Data Transfer Objects for courses
+ */
+
+export interface CourseDto {
+  id: string;
+  codigoCurso: number;
+  nome: string;
+  grau: string | null;
+  modalidade: string | null;
+  areaConhecimento: string | null;
+  institution: InstitutionBasicDto;
+}
+
+export interface InstitutionBasicDto {
+  nome: string;
+  sigla: string | null;
+  uf: string;
+}
diff --git a/src/mec-sync/dto/index.ts b/src/mec-sync/dto/index.ts
new file mode 100644
index 0000000..5d06bc1
--- /dev/null
+++ b/src/mec-sync/dto/index.ts
@@ -0,0 +1,8 @@
+/**
+ * MEC DTOs barrel export
+ */
+
+export * from './institution.dto';
+export * from './course.dto';
+export * from './sync.dto';
+export * from './stats.dto';
diff --git a/src/mec-sync/dto/institution.dto.ts b/src/mec-sync/dto/institution.dto.ts
new file mode 100644
index 0000000..b0656ba
--- /dev/null
+++ b/src/mec-sync/dto/institution.dto.ts
@@ -0,0 +1,28 @@
+/**
+ * Institution DTOs
+ * Single Responsibility: Data Transfer Objects for institutions
+ */
+
+export interface InstitutionDto {
+  id: string;
+  codigoIes: number;
+  nome: string;
+  sigla: string | null;
+  uf: string;
+  municipio: string | null;
+  categoria: string | null;
+  organizacao: string | null;
+}
+
+export interface InstitutionWithCoursesDto extends InstitutionDto {
+  courses: CourseBasicDto[];
+}
+
+export interface CourseBasicDto {
+  id: string;
+  codigoCurso: number;
+  nome: string;
+  grau: string | null;
+  modalidade: string | null;
+  areaConhecimento: string | null;
+}
diff --git a/src/mec-sync/dto/stats.dto.ts b/src/mec-sync/dto/stats.dto.ts
new file mode 100644
index 0000000..88f1341
--- /dev/null
+++ b/src/mec-sync/dto/stats.dto.ts
@@ -0,0 +1,21 @@
+/**
+ * Stats DTOs
+ * Single Responsibility: Data Transfer Objects for statistics
+ */
+
+export interface MecStatsDto {
+  totalInstitutions: number;
+  totalCourses: number;
+  coursesByGrau: GrauCountDto[];
+  institutionsByUf: UfCountDto[];
+}
+
+export interface GrauCountDto {
+  grau: string;
+  count: number;
+}
+
+export interface UfCountDto {
+  uf: string;
+  count: number;
+}
diff --git a/src/mec-sync/dto/sync.dto.ts b/src/mec-sync/dto/sync.dto.ts
new file mode 100644
index 0000000..4efa4ba
--- /dev/null
+++ b/src/mec-sync/dto/sync.dto.ts
@@ -0,0 +1,38 @@
+/**
+ * Sync DTOs
+ * Single Responsibility: Data Transfer Objects for sync operations
+ */
+
+export interface SyncResultDto {
+  institutionsInserted: number;
+  institutionsUpdated: number;
+  coursesInserted: number;
+  coursesUpdated: number;
+  totalRowsProcessed: number;
+  errorsCount: number;
+}
+
+export interface SyncStatusDto {
+  isRunning: boolean;
+  metadata: SyncMetadataDto | null;
+  lastSync: SyncLogDto | null;
+}
+
+export interface SyncMetadataDto {
+  lastSyncAt: string;
+  lastSyncStatus: 'success' | 'failed' | 'partial';
+  lastSyncDuration: number;
+  totalInstitutions: number;
+  totalCourses: number;
+  triggeredBy: string;
+}
+
+export interface SyncLogDto {
+  id: string;
+  status: string;
+  createdAt: Date;
+  completedAt: Date | null;
+  institutionsInserted: number | null;
+  coursesInserted: number | null;
+  errorMessage: string | null;
+}
diff --git a/src/mec-sync/guards/internal-auth.guard.ts b/src/mec-sync/guards/internal-auth.guard.ts
index fc1e0a6..2af5711 100644
--- a/src/mec-sync/guards/internal-auth.guard.ts
+++ b/src/mec-sync/guards/internal-auth.guard.ts
@@ -12,6 +12,7 @@ import {
 } from '@nestjs/common';
 import { ConfigService } from '@nestjs/config';
 import { Request } from 'express';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
 
 const INTERNAL_TOKEN_HEADER = 'x-internal-token';
 
@@ -32,7 +33,9 @@ export class InternalAuthGuard implements CanActivate {
     }
 
     const request = context.switchToHttp().getRequest<Request>();
-    const providedToken = request.headers[INTERNAL_TOKEN_HEADER] as string | undefined;
+    const providedToken = request.headers[INTERNAL_TOKEN_HEADER] as
+      | string
+      | undefined;
 
     if (!providedToken) {
       throw new UnauthorizedException(
@@ -42,7 +45,7 @@ export class InternalAuthGuard implements CanActivate {
 
     // Use timing-safe comparison to prevent timing attacks
     if (!this.timingSafeEqual(providedToken, this.internalToken)) {
-      throw new UnauthorizedException('Invalid internal token');
+      throw new UnauthorizedException(ERROR_MESSAGES.INVALID_INTERNAL_TOKEN);
     }
 
     return true;
diff --git a/src/mec-sync/index.ts b/src/mec-sync/index.ts
index 5a98ab4..fd44869 100644
--- a/src/mec-sync/index.ts
+++ b/src/mec-sync/index.ts
@@ -1,9 +1,19 @@
 /**
- * MEC Sync Module Exports
+ * MEC Sync Module - Clean Architecture
+ *
+ * Structure:
+ * ├── constants/       # Configuration constants
+ * ├── dto/            # Data Transfer Objects
+ * ├── guards/         # Authentication guards
+ * ├── interfaces/     # TypeScript interfaces
+ * ├── mappers/        # Data transformation functions
+ * ├── parsers/        # CSV parsing utilities
+ * ├── repositories/   # Data access layer
+ * └── services/       # Business logic
  */
 
-export { MecSyncModule } from './mec-sync.module';
-export { MecSyncService } from './services/mec-sync.service';
-export { MecQueryService, InstitutionDto, CourseDto } from './services/mec-query.service';
-export { MecCsvParserService } from './services/mec-csv-parser.service';
-export * from './interfaces/mec-data.interface';
+export * from './mec-sync.module';
+export * from './dto';
+export * from './services/institution-query.service';
+export * from './services/course-query.service';
+export * from './services/mec-stats.service';
diff --git a/src/mec-sync/mappers/index.ts b/src/mec-sync/mappers/index.ts
new file mode 100644
index 0000000..db16779
--- /dev/null
+++ b/src/mec-sync/mappers/index.ts
@@ -0,0 +1,6 @@
+/**
+ * MEC Mappers barrel export
+ */
+
+export * from './mec-code.mapper';
+export * from './text.normalizer';
diff --git a/src/mec-sync/mappers/mec-code.mapper.ts b/src/mec-sync/mappers/mec-code.mapper.ts
new file mode 100644
index 0000000..ac5697e
--- /dev/null
+++ b/src/mec-sync/mappers/mec-code.mapper.ts
@@ -0,0 +1,77 @@
+/**
+ * MEC Code Mappers
+ * Single Responsibility: Map MEC numeric codes to human-readable labels
+ *
+ * These mappings come from MEC's official documentation.
+ * Each code represents a specific category in the Brazilian education system.
+ */
+
+/**
+ * Organization Type (Organização Acadêmica)
+ */
+const ORGANIZATION_MAP: Record<string, string> = {
+  '1': 'Universidade',
+  '2': 'Centro Universitário',
+  '3': 'Faculdade',
+  '4': 'Instituto Federal',
+  '5': 'Centro Federal',
+};
+
+/**
+ * Administrative Category (Categoria Administrativa)
+ */
+const CATEGORY_MAP: Record<string, string> = {
+  '1': 'Pública Federal',
+  '2': 'Pública Estadual',
+  '3': 'Pública Municipal',
+  '4': 'Privada com fins lucrativos',
+  '5': 'Privada sem fins lucrativos',
+  '6': 'Especial',
+};
+
+/**
+ * Academic Degree (Grau Acadêmico)
+ */
+const DEGREE_MAP: Record<string, string> = {
+  '1': 'Bacharelado',
+  '2': 'Licenciatura',
+  '3': 'Tecnológico',
+  '4': 'Bacharelado e Licenciatura',
+};
+
+/**
+ * Teaching Modality (Modalidade de Ensino)
+ */
+const MODALITY_MAP: Record<string, string> = {
+  '1': 'Presencial',
+  '2': 'EaD',
+};
+
+/**
+ * Course Status (Situação do Curso)
+ */
+const STATUS_MAP: Record<string, string> = {
+  '1': 'Em atividade',
+  '2': 'Extinto',
+  '3': 'Em extinção',
+};
+
+export function mapOrganization(code: string): string | null {
+  return ORGANIZATION_MAP[code] || code || null;
+}
+
+export function mapCategory(code: string): string | null {
+  return CATEGORY_MAP[code] || code || null;
+}
+
+export function mapDegree(code: string): string | null {
+  return DEGREE_MAP[code] || code || null;
+}
+
+export function mapModality(code: string): string | null {
+  return MODALITY_MAP[code] || code || null;
+}
+
+export function mapCourseStatus(code: string): string | null {
+  return STATUS_MAP[code] || code || null;
+}
diff --git a/src/mec-sync/mappers/text.normalizer.ts b/src/mec-sync/mappers/text.normalizer.ts
new file mode 100644
index 0000000..3751145
--- /dev/null
+++ b/src/mec-sync/mappers/text.normalizer.ts
@@ -0,0 +1,45 @@
+/**
+ * Text Normalizer
+ * Single Responsibility: Normalize text for database storage
+ */
+
+/**
+ * Small Portuguese prepositions that should remain lowercase
+ */
+const LOWERCASE_PREPOSITIONS = [
+  'de',
+  'da',
+  'do',
+  'das',
+  'dos',
+  'e',
+  'em',
+  'para',
+  'com',
+];
+
+/**
+ * Normalize text: trim, title case, remove extra spaces
+ * Handles Brazilian Portuguese conventions for proper nouns
+ */
+export function normalizeText(text: string | undefined): string {
+  if (!text) return '';
+
+  return text
+    .trim()
+    .replace(/\s+/g, ' ')
+    .split(' ')
+    .map((word) => {
+      const lower = word.toLowerCase();
+      if (LOWERCASE_PREPOSITIONS.includes(lower)) {
+        return lower;
+      }
+      return capitalize(word);
+    })
+    .join(' ');
+}
+
+function capitalize(word: string): string {
+  if (!word) return '';
+  return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
+}
diff --git a/src/mec-sync/mec-sync.controller.ts b/src/mec-sync/mec-sync.controller.ts
deleted file mode 100644
index 53b6daf..0000000
--- a/src/mec-sync/mec-sync.controller.ts
+++ /dev/null
@@ -1,190 +0,0 @@
-/**
- * MEC Sync Controller
- * Handles sync operations and data queries
- */
-
-import {
-  Controller,
-  Get,
-  Post,
-  Query,
-  Param,
-  UseGuards,
-  HttpCode,
-  HttpStatus,
-  ParseIntPipe,
-} from '@nestjs/common';
-import { ApiTags, ApiOperation, ApiQuery, ApiParam, ApiHeader } from '@nestjs/swagger';
-import { MecSyncService } from './services/mec-sync.service';
-import { MecQueryService } from './services/mec-query.service';
-import { InternalAuthGuard } from './guards/internal-auth.guard';
-import { Public } from '../auth/decorators/public.decorator';
-
-@ApiTags('mec')
-@Controller('mec')
-export class MecSyncController {
-  constructor(
-    private readonly syncService: MecSyncService,
-    private readonly queryService: MecQueryService,
-  ) {}
-
-  // ===== INTERNAL ENDPOINTS (Protected by secret token) =====
-
-  @Post('internal/sync')
-  @Public()
-  @UseGuards(InternalAuthGuard)
-  @HttpCode(HttpStatus.OK)
-  @ApiOperation({ summary: 'Trigger MEC data synchronization (internal)' })
-  @ApiHeader({
-    name: 'x-internal-token',
-    description: 'Internal API token for authentication',
-    required: true,
-  })
-  async triggerSync() {
-    const result = await this.syncService.sync('api');
-    return {
-      success: true,
-      message: 'Sync completed successfully',
-      data: {
-        institutionsInserted: result.institutionsInserted,
-        coursesInserted: result.coursesInserted,
-        totalRowsProcessed: result.totalRowsProcessed,
-        errorsCount: result.errors.length,
-      },
-    };
-  }
-
-  @Get('internal/sync/status')
-  @Public()
-  @UseGuards(InternalAuthGuard)
-  @ApiOperation({ summary: 'Get sync status (internal)' })
-  @ApiHeader({
-    name: 'x-internal-token',
-    description: 'Internal API token for authentication',
-    required: true,
-  })
-  async getSyncStatus() {
-    const [isRunning, metadata, lastLog] = await Promise.all([
-      this.syncService.isSyncRunning(),
-      this.syncService.getSyncMetadata(),
-      this.syncService.getLastSyncLog(),
-    ]);
-
-    return {
-      isRunning,
-      metadata,
-      lastSync: lastLog,
-    };
-  }
-
-  @Get('internal/sync/history')
-  @Public()
-  @UseGuards(InternalAuthGuard)
-  @ApiOperation({ summary: 'Get sync history (internal)' })
-  @ApiHeader({
-    name: 'x-internal-token',
-    description: 'Internal API token for authentication',
-    required: true,
-  })
-  @ApiQuery({ name: 'limit', required: false, type: Number })
-  async getSyncHistory(@Query('limit') limit?: string) {
-    const history = await this.syncService.getSyncHistory(
-      limit ? parseInt(limit, 10) : 10,
-    );
-    return { history };
-  }
-
-  // ===== PUBLIC QUERY ENDPOINTS (For frontend consumption) =====
-
-  @Get('institutions')
-  @Public()
-  @ApiOperation({ summary: 'List all institutions' })
-  @ApiQuery({ name: 'uf', required: false, description: 'Filter by state (UF)' })
-  async getInstitutions(@Query('uf') uf?: string) {
-    if (uf) {
-      return this.queryService.getInstitutionsByUf(uf);
-    }
-    return this.queryService.getAllInstitutions();
-  }
-
-  @Get('institutions/search')
-  @Public()
-  @ApiOperation({ summary: 'Search institutions by name or sigla' })
-  @ApiQuery({ name: 'q', required: true, description: 'Search query' })
-  @ApiQuery({ name: 'limit', required: false, type: Number })
-  async searchInstitutions(
-    @Query('q') query: string,
-    @Query('limit') limit?: string,
-  ) {
-    return this.queryService.searchInstitutions(
-      query,
-      limit ? parseInt(limit, 10) : 20,
-    );
-  }
-
-  @Get('institutions/:codigoIes')
-  @Public()
-  @ApiOperation({ summary: 'Get institution by MEC code' })
-  @ApiParam({ name: 'codigoIes', type: Number })
-  async getInstitutionByCode(
-    @Param('codigoIes', ParseIntPipe) codigoIes: number,
-  ) {
-    return this.queryService.getInstitutionByCode(codigoIes);
-  }
-
-  @Get('institutions/:codigoIes/courses')
-  @Public()
-  @ApiOperation({ summary: 'Get courses by institution' })
-  @ApiParam({ name: 'codigoIes', type: Number })
-  async getCoursesByInstitution(
-    @Param('codigoIes', ParseIntPipe) codigoIes: number,
-  ) {
-    return this.queryService.getCoursesByInstitution(codigoIes);
-  }
-
-  @Get('courses/search')
-  @Public()
-  @ApiOperation({ summary: 'Search courses by name' })
-  @ApiQuery({ name: 'q', required: true, description: 'Search query' })
-  @ApiQuery({ name: 'limit', required: false, type: Number })
-  async searchCourses(
-    @Query('q') query: string,
-    @Query('limit') limit?: string,
-  ) {
-    return this.queryService.searchCourses(
-      query,
-      limit ? parseInt(limit, 10) : 20,
-    );
-  }
-
-  @Get('courses/:codigoCurso')
-  @Public()
-  @ApiOperation({ summary: 'Get course by MEC code' })
-  @ApiParam({ name: 'codigoCurso', type: Number })
-  async getCourseByCode(
-    @Param('codigoCurso', ParseIntPipe) codigoCurso: number,
-  ) {
-    return this.queryService.getCourseByCode(codigoCurso);
-  }
-
-  @Get('ufs')
-  @Public()
-  @ApiOperation({ summary: 'Get list of states (UFs)' })
-  async getUfList() {
-    return this.queryService.getUfList();
-  }
-
-  @Get('areas')
-  @Public()
-  @ApiOperation({ summary: 'Get list of knowledge areas' })
-  async getAreasConhecimento() {
-    return this.queryService.getAreasConhecimento();
-  }
-
-  @Get('stats')
-  @Public()
-  @ApiOperation({ summary: 'Get MEC data statistics' })
-  async getStats() {
-    return this.queryService.getStats();
-  }
-}
diff --git a/src/mec-sync/mec-sync.module.ts b/src/mec-sync/mec-sync.module.ts
index 85f7720..44e2ebd 100644
--- a/src/mec-sync/mec-sync.module.ts
+++ b/src/mec-sync/mec-sync.module.ts
@@ -1,26 +1,76 @@
 /**
  * MEC Sync Module
- * Handles synchronization of Brazilian higher education data from MEC
+ * Clean Architecture: Controllers -> Services -> Repositories
  */
 
 import { Module } from '@nestjs/common';
-import { ConfigModule } from '@nestjs/config';
-import { MecSyncController } from './mec-sync.controller';
-import { MecSyncService } from './services/mec-sync.service';
-import { MecQueryService } from './services/mec-query.service';
-import { MecCsvParserService } from './services/mec-csv-parser.service';
-import { InternalAuthGuard } from './guards/internal-auth.guard';
+
+// Controllers
+import {
+  MecSyncInternalController,
+  MecInstitutionController,
+  MecCourseController,
+  MecMetadataController,
+} from './controllers';
+
+// Repositories
+import {
+  InstitutionRepository,
+  CourseRepository,
+  SyncLogRepository,
+} from './repositories';
+
+// Services
+import {
+  InstitutionQueryService,
+  CourseQueryService,
+  MecStatsService,
+  MecSyncOrchestratorService,
+  DataSyncService,
+  SyncHelperService,
+  MecCsvParserService,
+  CsvFileCacheService,
+  CsvDownloaderService,
+  CsvEncodingService,
+  CsvRowProcessorService,
+  CloudflareHandlerService,
+} from './services';
+
+// Shared modules
 import { PrismaModule } from '../prisma/prisma.module';
+import { CacheModule } from '../common/cache/cache.module';
+import { LoggerModule } from '../common/logger/logger.module';
 
 @Module({
-  imports: [ConfigModule, PrismaModule],
-  controllers: [MecSyncController],
+  imports: [PrismaModule, CacheModule, LoggerModule],
+  controllers: [
+    MecSyncInternalController,
+    MecInstitutionController,
+    MecCourseController,
+    MecMetadataController,
+  ],
   providers: [
-    MecSyncService,
-    MecQueryService,
+    // Repositories
+    InstitutionRepository,
+    CourseRepository,
+    SyncLogRepository,
+
+    // Query Services
+    InstitutionQueryService,
+    CourseQueryService,
+    MecStatsService,
+
+    // Sync Services
+    MecSyncOrchestratorService,
+    DataSyncService,
+    SyncHelperService,
     MecCsvParserService,
-    InternalAuthGuard,
+    CsvFileCacheService,
+    CsvDownloaderService,
+    CsvEncodingService,
+    CsvRowProcessorService,
+    CloudflareHandlerService,
   ],
-  exports: [MecSyncService, MecQueryService],
+  exports: [InstitutionQueryService, CourseQueryService, MecStatsService],
 })
 export class MecSyncModule {}
diff --git a/src/mec-sync/parsers/csv-line.parser.ts b/src/mec-sync/parsers/csv-line.parser.ts
new file mode 100644
index 0000000..cd970d2
--- /dev/null
+++ b/src/mec-sync/parsers/csv-line.parser.ts
@@ -0,0 +1,69 @@
+/**
+ * CSV Line Parser
+ * Single Responsibility: Parse individual CSV lines handling quoted fields
+ */
+
+/**
+ * Parse a single CSV line handling quoted fields
+ * MEC CSV uses comma as delimiter
+ */
+export function parseCsvLine(line: string): string[] {
+  const result: string[] = [];
+  let current = '';
+  let inQuotes = false;
+
+  for (let i = 0; i < line.length; i++) {
+    const char = line[i];
+
+    if (char === '"') {
+      if (inQuotes && line[i + 1] === '"') {
+        current += '"';
+        i++;
+      } else {
+        inQuotes = !inQuotes;
+      }
+    } else if (char === ',' && !inQuotes) {
+      result.push(current.trim());
+      current = '';
+    } else {
+      current += char;
+    }
+  }
+
+  result.push(current.trim());
+  return result;
+}
+
+/**
+ * Build a map of column names to indices
+ */
+export function buildColumnMap(header: string[]): Map<string, number> {
+  const map = new Map<string, number>();
+
+  header.forEach((col, index) => {
+    const normalized = col
+      .replace(/^\uFEFF/, '') // Remove BOM
+      .trim()
+      .toUpperCase();
+    map.set(normalized, index);
+  });
+
+  return map;
+}
+
+/**
+ * Get value from column map with fallback keys
+ */
+export function getColumnValue(
+  values: string[],
+  columnMap: Map<string, number>,
+  ...keys: string[]
+): string {
+  for (const key of keys) {
+    const index = columnMap.get(key);
+    if (index !== undefined && values[index]) {
+      return values[index];
+    }
+  }
+  return '';
+}
diff --git a/src/mec-sync/parsers/entity.normalizer.ts b/src/mec-sync/parsers/entity.normalizer.ts
new file mode 100644
index 0000000..e75689e
--- /dev/null
+++ b/src/mec-sync/parsers/entity.normalizer.ts
@@ -0,0 +1,65 @@
+/**
+ * Entity Normalizer
+ * Single Responsibility: Convert raw MEC CSV rows to normalized entities
+ */
+
+import {
+  MecCsvRow,
+  NormalizedInstitution,
+  NormalizedCourse,
+} from '../interfaces/mec-data.interface';
+import {
+  mapOrganization,
+  mapCategory,
+  mapDegree,
+  mapModality,
+  mapCourseStatus,
+} from '../mappers/mec-code.mapper';
+import { normalizeText } from '../mappers/text.normalizer';
+
+/**
+ * Normalize institution data from CSV row
+ */
+export function normalizeInstitution(
+  row: MecCsvRow,
+): NormalizedInstitution | null {
+  const codigoIes = parseInt(row.CO_IES, 10);
+
+  if (isNaN(codigoIes) || !row.NO_IES || !row.SG_UF_IES) {
+    return null;
+  }
+
+  return {
+    codigoIes,
+    nome: normalizeText(row.NO_IES),
+    sigla: normalizeText(row.SG_IES) || null,
+    organizacao: mapOrganization(row.TP_ORGANIZACAO),
+    categoria: mapCategory(row.TP_CATEGORIA),
+    uf: row.SG_UF_IES.toUpperCase(),
+    municipio: normalizeText(row.NO_MUNICIPIO_IES) || null,
+    codigoMunicipio: parseInt(row.CO_MUNICIPIO_IES, 10) || null,
+  };
+}
+
+/**
+ * Normalize course data from CSV row
+ */
+export function normalizeCourse(row: MecCsvRow): NormalizedCourse | null {
+  const codigoCurso = parseInt(row.CO_CURSO, 10);
+  const codigoIes = parseInt(row.CO_IES, 10);
+
+  if (isNaN(codigoCurso) || isNaN(codigoIes) || !row.NO_CURSO) {
+    return null;
+  }
+
+  return {
+    codigoCurso,
+    codigoIes,
+    nome: normalizeText(row.NO_CURSO),
+    grau: mapDegree(row.TP_GRAU),
+    modalidade: mapModality(row.TP_MODALIDADE),
+    areaConhecimento: normalizeText(row.NO_CINE_AREA_GERAL) || null,
+    cargaHoraria: parseInt(row.QT_CARGA_HORARIA, 10) || null,
+    situacao: mapCourseStatus(row.CO_SITUACAO),
+  };
+}
diff --git a/src/mec-sync/parsers/index.ts b/src/mec-sync/parsers/index.ts
new file mode 100644
index 0000000..133d21d
--- /dev/null
+++ b/src/mec-sync/parsers/index.ts
@@ -0,0 +1,7 @@
+/**
+ * MEC Parsers barrel export
+ */
+
+export * from './csv-line.parser';
+export * from './mec-row.mapper';
+export * from './entity.normalizer';
diff --git a/src/mec-sync/parsers/mec-row.mapper.ts b/src/mec-sync/parsers/mec-row.mapper.ts
new file mode 100644
index 0000000..ce40e61
--- /dev/null
+++ b/src/mec-sync/parsers/mec-row.mapper.ts
@@ -0,0 +1,89 @@
+/**
+ * MEC Row Mapper
+ * Single Responsibility: Map CSV values to MecCsvRow structure
+ */
+
+import { MecCsvRow } from '../interfaces/mec-data.interface';
+import { getColumnValue } from './csv-line.parser';
+
+/**
+ * Map array values to row object using column map
+ * Handles multiple column naming conventions from different MEC CSV versions
+ */
+export function mapToMecRow(
+  values: string[],
+  columnMap: Map<string, number>,
+): MecCsvRow {
+  return {
+    CO_IES: getColumnValue(values, columnMap, 'CODIGO_IES', 'CO_IES'),
+    NO_IES: getColumnValue(values, columnMap, 'NOME_IES', 'NO_IES'),
+    SG_IES: getColumnValue(values, columnMap, 'SG_IES'),
+    TP_ORGANIZACAO: getColumnValue(
+      values,
+      columnMap,
+      'ORGANIZACAO_ACADEMICA',
+      'TP_ORGANIZACAO_ACADEMICA',
+      'TP_ORGANIZACAO',
+    ),
+    TP_CATEGORIA: getColumnValue(
+      values,
+      columnMap,
+      'CATEGORIA_ADMINISTRATIVA',
+      'TP_CATEGORIA_ADMINISTRATIVA',
+      'TP_CATEGORIA',
+    ),
+    CO_MUNICIPIO_IES: getColumnValue(
+      values,
+      columnMap,
+      'CODIGO_MUNICIPIO',
+      'CO_MUNICIPIO_IES',
+      'CO_MUNICIPIO',
+    ),
+    NO_MUNICIPIO_IES: getColumnValue(
+      values,
+      columnMap,
+      'MUNICIPIO',
+      'NO_MUNICIPIO_IES',
+      'NO_MUNICIPIO',
+    ),
+    SG_UF_IES: getColumnValue(values, columnMap, 'UF', 'SG_UF_IES', 'SG_UF'),
+    CO_CURSO: getColumnValue(values, columnMap, 'CODIGO_CURSO', 'CO_CURSO'),
+    NO_CURSO: getColumnValue(values, columnMap, 'NOME_CURSO', 'NO_CURSO'),
+    TP_GRAU: getColumnValue(
+      values,
+      columnMap,
+      'GRAU',
+      'TP_GRAU_ACADEMICO',
+      'TP_GRAU',
+    ),
+    TP_MODALIDADE: getColumnValue(
+      values,
+      columnMap,
+      'MODALIDADE',
+      'TP_MODALIDADE_ENSINO',
+      'TP_MODALIDADE',
+    ),
+    NO_CINE_AREA_GERAL: getColumnValue(
+      values,
+      columnMap,
+      'AREA_OCDE_CINE',
+      'AREA_OCDE',
+      'NO_CINE_AREA_GERAL',
+      'NO_AREA',
+    ),
+    QT_CARGA_HORARIA: getColumnValue(
+      values,
+      columnMap,
+      'CARGA_HORARIA',
+      'QT_CARGA_HORARIA_TOTAL',
+      'QT_CARGA_HORARIA',
+    ),
+    CO_SITUACAO: getColumnValue(
+      values,
+      columnMap,
+      'SITUACAO_CURSO',
+      'CO_SITUACAO_CURSO',
+      'CO_SITUACAO',
+    ),
+  };
+}
diff --git a/src/mec-sync/repositories/course.repository.ts b/src/mec-sync/repositories/course.repository.ts
new file mode 100644
index 0000000..a0580ef
--- /dev/null
+++ b/src/mec-sync/repositories/course.repository.ts
@@ -0,0 +1,164 @@
+/**
+ * Course Repository
+ * Single Responsibility: Data access for MEC courses
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { CourseDto } from '../dto';
+import { NormalizedCourse } from '../interfaces/mec-data.interface';
+import { BATCH_SIZE } from '../constants';
+
+@Injectable()
+export class CourseRepository {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async findByInstitution(codigoIes: number): Promise<CourseDto[]> {
+    const courses = await this.prisma.mecCourse.findMany({
+      where: { codigoIes, isActive: true },
+      orderBy: { nome: 'asc' },
+      include: {
+        institution: {
+          select: { nome: true, sigla: true, uf: true },
+        },
+      },
+    });
+
+    return courses.map((course) => this.mapToDto(course));
+  }
+
+  async findByCode(codigoCurso: number): Promise<CourseDto | null> {
+    const course = await this.prisma.mecCourse.findUnique({
+      where: { codigoCurso },
+      include: {
+        institution: {
+          select: { nome: true, sigla: true, uf: true },
+        },
+      },
+    });
+
+    return course ? this.mapToDto(course) : null;
+  }
+
+  async search(query: string, limit: number): Promise<CourseDto[]> {
+    const courses = await this.prisma.$queryRaw<
+      Array<{
+        id: string;
+        codigoCurso: number;
+        nome: string;
+        grau: string | null;
+        modalidade: string | null;
+        areaConhecimento: string | null;
+        institution_nome: string;
+        institution_sigla: string | null;
+        institution_uf: string;
+      }>
+    >`
+      SELECT 
+        c.id, c."codigoCurso", c.nome, c.grau, c.modalidade, c."areaConhecimento",
+        i.nome as institution_nome, i.sigla as institution_sigla, i.uf as institution_uf
+      FROM "MecCourse" c
+      JOIN "MecInstitution" i ON c."codigoIes" = i."codigoIes"
+      WHERE c."isActive" = true
+        AND immutable_unaccent(lower(c.nome)) LIKE '%' || immutable_unaccent(lower(${query})) || '%'
+      ORDER BY c.nome ASC
+      LIMIT ${limit}
+    `;
+
+    return courses.map((c) => ({
+      id: c.id,
+      codigoCurso: c.codigoCurso,
+      nome: c.nome,
+      grau: c.grau,
+      modalidade: c.modalidade,
+      areaConhecimento: c.areaConhecimento,
+      institution: {
+        nome: c.institution_nome,
+        sigla: c.institution_sigla,
+        uf: c.institution_uf,
+      },
+    }));
+  }
+
+  async getDistinctAreas(): Promise<string[]> {
+    const areas = await this.prisma.mecCourse.findMany({
+      where: { isActive: true, areaConhecimento: { not: null } },
+      select: { areaConhecimento: true },
+      distinct: ['areaConhecimento'],
+      orderBy: { areaConhecimento: 'asc' },
+    });
+
+    return areas
+      .map((a) => a.areaConhecimento)
+      .filter((a): a is string => a !== null);
+  }
+
+  async countByDegree() {
+    return this.prisma.mecCourse.groupBy({
+      by: ['grau'],
+      where: { isActive: true },
+      _count: true,
+    });
+  }
+
+  async count(): Promise<number> {
+    return this.prisma.mecCourse.count({ where: { isActive: true } });
+  }
+
+  async getExistingCodes(): Promise<Set<number>> {
+    const existing = await this.prisma.mecCourse.findMany({
+      select: { codigoCurso: true },
+    });
+    return new Set(existing.map((c) => c.codigoCurso));
+  }
+
+  async bulkCreate(
+    courses: NormalizedCourse[],
+    validIesCodes: Set<number>,
+  ): Promise<number> {
+    const validCourses = courses.filter((c) => validIesCodes.has(c.codigoIes));
+    let inserted = 0;
+
+    for (let i = 0; i < validCourses.length; i += BATCH_SIZE) {
+      const batch = validCourses.slice(i, i + BATCH_SIZE);
+
+      await this.prisma.mecCourse.createMany({
+        data: batch.map((course) => ({
+          codigoCurso: course.codigoCurso,
+          codigoIes: course.codigoIes,
+          nome: course.nome,
+          grau: course.grau,
+          modalidade: course.modalidade,
+          areaConhecimento: course.areaConhecimento,
+          cargaHoraria: course.cargaHoraria,
+          situacao: course.situacao,
+        })),
+        skipDuplicates: true,
+      });
+
+      inserted += batch.length;
+    }
+
+    return inserted;
+  }
+
+  private mapToDto(course: {
+    id: string;
+    codigoCurso: number;
+    nome: string;
+    grau: string | null;
+    modalidade: string | null;
+    areaConhecimento: string | null;
+    institution: { nome: string; sigla: string | null; uf: string };
+  }): CourseDto {
+    return {
+      id: course.id,
+      codigoCurso: course.codigoCurso,
+      nome: course.nome,
+      grau: course.grau,
+      modalidade: course.modalidade,
+      areaConhecimento: course.areaConhecimento,
+      institution: course.institution,
+    };
+  }
+}
diff --git a/src/mec-sync/repositories/index.ts b/src/mec-sync/repositories/index.ts
new file mode 100644
index 0000000..04c715b
--- /dev/null
+++ b/src/mec-sync/repositories/index.ts
@@ -0,0 +1,7 @@
+/**
+ * MEC Repositories barrel export
+ */
+
+export * from './institution.repository';
+export * from './course.repository';
+export * from './sync-log.repository';
diff --git a/src/mec-sync/repositories/institution.repository.ts b/src/mec-sync/repositories/institution.repository.ts
new file mode 100644
index 0000000..cb9ca98
--- /dev/null
+++ b/src/mec-sync/repositories/institution.repository.ts
@@ -0,0 +1,133 @@
+/**
+ * Institution Repository
+ * Single Responsibility: Data access for MEC institutions
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { InstitutionDto } from '../dto';
+import { NormalizedInstitution } from '../interfaces/mec-data.interface';
+import { BATCH_SIZE } from '../constants';
+
+const INSTITUTION_SELECT = {
+  id: true,
+  codigoIes: true,
+  nome: true,
+  sigla: true,
+  uf: true,
+  municipio: true,
+  categoria: true,
+  organizacao: true,
+} as const;
+
+@Injectable()
+export class InstitutionRepository {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async findAll(): Promise<InstitutionDto[]> {
+    return this.prisma.mecInstitution.findMany({
+      where: { isActive: true },
+      orderBy: [{ uf: 'asc' }, { nome: 'asc' }],
+      select: INSTITUTION_SELECT,
+    });
+  }
+
+  async findByUf(uf: string): Promise<InstitutionDto[]> {
+    return this.prisma.mecInstitution.findMany({
+      where: { uf: uf.toUpperCase(), isActive: true },
+      orderBy: { nome: 'asc' },
+      select: INSTITUTION_SELECT,
+    });
+  }
+
+  async findByCode(codigoIes: number) {
+    return this.prisma.mecInstitution.findUnique({
+      where: { codigoIes },
+      include: {
+        courses: {
+          where: { isActive: true },
+          orderBy: { nome: 'asc' },
+          select: {
+            id: true,
+            codigoCurso: true,
+            nome: true,
+            grau: true,
+            modalidade: true,
+            areaConhecimento: true,
+          },
+        },
+      },
+    });
+  }
+
+  async search(query: string, limit: number): Promise<InstitutionDto[]> {
+    return this.prisma.$queryRaw<InstitutionDto[]>`
+      SELECT 
+        id, "codigoIes", nome, sigla, uf, municipio, categoria, organizacao
+      FROM "MecInstitution"
+      WHERE "isActive" = true
+        AND (
+          immutable_unaccent(lower(nome)) LIKE '%' || immutable_unaccent(lower(${query})) || '%'
+          OR (sigla IS NOT NULL AND immutable_unaccent(lower(sigla)) LIKE '%' || immutable_unaccent(lower(${query})) || '%')
+        )
+      ORDER BY uf ASC, nome ASC
+      LIMIT ${limit}
+    `;
+  }
+
+  async getDistinctUfs(): Promise<string[]> {
+    const ufs = await this.prisma.mecInstitution.findMany({
+      where: { isActive: true },
+      select: { uf: true },
+      distinct: ['uf'],
+      orderBy: { uf: 'asc' },
+    });
+    return ufs.map((u) => u.uf);
+  }
+
+  async countByUf() {
+    return this.prisma.mecInstitution.groupBy({
+      by: ['uf'],
+      where: { isActive: true },
+      _count: true,
+      orderBy: { uf: 'asc' },
+    });
+  }
+
+  async count(): Promise<number> {
+    return this.prisma.mecInstitution.count({ where: { isActive: true } });
+  }
+
+  async getExistingCodes(): Promise<Set<number>> {
+    const existing = await this.prisma.mecInstitution.findMany({
+      select: { codigoIes: true },
+    });
+    return new Set(existing.map((i) => i.codigoIes));
+  }
+
+  async bulkCreate(institutions: NormalizedInstitution[]): Promise<number> {
+    let inserted = 0;
+
+    for (let i = 0; i < institutions.length; i += BATCH_SIZE) {
+      const batch = institutions.slice(i, i + BATCH_SIZE);
+
+      await this.prisma.mecInstitution.createMany({
+        data: batch.map((inst) => ({
+          codigoIes: inst.codigoIes,
+          nome: inst.nome,
+          sigla: inst.sigla,
+          organizacao: inst.organizacao,
+          categoria: inst.categoria,
+          uf: inst.uf,
+          municipio: inst.municipio,
+          codigoMunicipio: inst.codigoMunicipio,
+        })),
+        skipDuplicates: true,
+      });
+
+      inserted += batch.length;
+    }
+
+    return inserted;
+  }
+}
diff --git a/src/mec-sync/repositories/sync-log.repository.ts b/src/mec-sync/repositories/sync-log.repository.ts
new file mode 100644
index 0000000..ebe351a
--- /dev/null
+++ b/src/mec-sync/repositories/sync-log.repository.ts
@@ -0,0 +1,81 @@
+/**
+ * Sync Log Repository
+ * Single Responsibility: Data access for sync logs
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { MecSyncStatus } from '@prisma/client';
+
+export interface CreateSyncLogParams {
+  triggeredBy: string;
+}
+
+export interface CompleteSyncLogParams {
+  institutionsInserted: number;
+  institutionsUpdated: number;
+  coursesInserted: number;
+  coursesUpdated: number;
+  totalRowsProcessed: number;
+  sourceFileSize: number;
+}
+
+export interface FailSyncLogParams {
+  errorMessage: string;
+  errorDetails?: Record<string, unknown>;
+}
+
+@Injectable()
+export class SyncLogRepository {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async create(params: CreateSyncLogParams) {
+    return this.prisma.mecSyncLog.create({
+      data: {
+        status: MecSyncStatus.RUNNING,
+        triggeredBy: params.triggeredBy,
+      },
+    });
+  }
+
+  async markSuccess(id: string, params: CompleteSyncLogParams) {
+    return this.prisma.mecSyncLog.update({
+      where: { id },
+      data: {
+        status: MecSyncStatus.SUCCESS,
+        completedAt: new Date(),
+        institutionsInserted: params.institutionsInserted,
+        institutionsUpdated: params.institutionsUpdated,
+        coursesInserted: params.coursesInserted,
+        coursesUpdated: params.coursesUpdated,
+        totalRowsProcessed: params.totalRowsProcessed,
+        sourceFileSize: params.sourceFileSize,
+      },
+    });
+  }
+
+  async markFailed(id: string, params: FailSyncLogParams) {
+    return this.prisma.mecSyncLog.update({
+      where: { id },
+      data: {
+        status: MecSyncStatus.FAILED,
+        completedAt: new Date(),
+        errorMessage: params.errorMessage,
+        errorDetails: params.errorDetails as object | undefined,
+      },
+    });
+  }
+
+  async findLast() {
+    return this.prisma.mecSyncLog.findFirst({
+      orderBy: { createdAt: 'desc' },
+    });
+  }
+
+  async findHistory(limit = 10) {
+    return this.prisma.mecSyncLog.findMany({
+      orderBy: { createdAt: 'desc' },
+      take: limit,
+    });
+  }
+}
diff --git a/src/mec-sync/services/cloudflare-handler.service.ts b/src/mec-sync/services/cloudflare-handler.service.ts
new file mode 100644
index 0000000..ab1e5b3
--- /dev/null
+++ b/src/mec-sync/services/cloudflare-handler.service.ts
@@ -0,0 +1,56 @@
+/**
+ * Cloudflare Handler Service
+ * Handles Cloudflare challenge detection and bypass
+ */
+
+import { Injectable } from '@nestjs/common';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { TIME_MS } from '../../common/constants/app.constants';
+import { PUPPETEER_CONFIG } from '../constants';
+import type { Page } from 'puppeteer';
+
+@Injectable()
+export class CloudflareHandlerService {
+  private readonly context = 'CloudflareHandler';
+
+  constructor(private readonly logger: AppLoggerService) {}
+
+  async waitForChallengeIfNeeded(page: Page): Promise<void> {
+    const content = await page.content();
+
+    if (!this.isCloudflareChallenge(content)) {
+      return;
+    }
+
+    this.logger.log('Cloudflare challenge detected, waiting...', this.context);
+
+    await page.waitForFunction(
+      () => {
+        const body = document.body.innerHTML || '';
+        return (
+          !body.includes('Just a moment') &&
+          !body.includes('Checking your browser') &&
+          !body.includes('Verifying') &&
+          !body.includes('cf-spinner')
+        );
+      },
+      { timeout: PUPPETEER_CONFIG.CHALLENGE_TIMEOUT },
+    );
+
+    this.logger.log('Cloudflare challenge passed!', this.context);
+    await this.delay(TIME_MS.SECOND);
+  }
+
+  isCloudflareChallenge(content: string): boolean {
+    return (
+      content.includes('Just a moment') ||
+      content.includes('Checking your browser') ||
+      content.includes('cf-spinner') ||
+      content.includes('Verifying you are human')
+    );
+  }
+
+  private delay(ms: number): Promise<void> {
+    return new Promise((resolve) => setTimeout(resolve, ms));
+  }
+}
diff --git a/src/mec-sync/services/course-query.service.ts b/src/mec-sync/services/course-query.service.ts
new file mode 100644
index 0000000..9852571
--- /dev/null
+++ b/src/mec-sync/services/course-query.service.ts
@@ -0,0 +1,78 @@
+/**
+ * Course Query Service (Refactored)
+ * Single Responsibility: Query operations for courses
+ */
+
+import { Injectable } from '@nestjs/common';
+import * as crypto from 'crypto';
+import { CacheService } from '../../common/cache/cache.service';
+import { CourseRepository } from '../repositories';
+import { CourseDto } from '../dto';
+import {
+  MEC_CACHE_KEYS,
+  MEC_CACHE_TTL,
+} from '../interfaces/mec-data.interface';
+import {
+  APP_CONSTANTS,
+  API_LIMITS,
+} from '../../common/constants/app.constants';
+
+@Injectable()
+export class CourseQueryService {
+  constructor(
+    private readonly repository: CourseRepository,
+    private readonly cache: CacheService,
+  ) {}
+
+  async listByInstitution(codigoIes: number): Promise<CourseDto[]> {
+    const cacheKey = `${MEC_CACHE_KEYS.COURSES_BY_IES}${codigoIes}`;
+
+    const cached = await this.cache.get<CourseDto[]>(cacheKey);
+    if (cached) return cached;
+
+    const courses = await this.repository.findByInstitution(codigoIes);
+
+    await this.cache.set(cacheKey, courses, MEC_CACHE_TTL.COURSES_BY_IES);
+
+    return courses;
+  }
+
+  async getByCode(codigoCurso: number): Promise<CourseDto | null> {
+    return this.repository.findByCode(codigoCurso);
+  }
+
+  async search(
+    query: string,
+    limit: number = APP_CONSTANTS.DEFAULT_PAGE_SIZE,
+  ): Promise<CourseDto[]> {
+    const normalizedQuery = query.toLowerCase().trim();
+
+    if (normalizedQuery.length < 2) {
+      return [];
+    }
+
+    const cacheKey = this.buildSearchCacheKey(normalizedQuery);
+
+    const cached = await this.cache.get<CourseDto[]>(cacheKey);
+    if (cached) return cached;
+
+    const courses = await this.repository.search(normalizedQuery, limit);
+
+    await this.cache.set(cacheKey, courses, MEC_CACHE_TTL.COURSES_SEARCH);
+
+    return courses;
+  }
+
+  async getKnowledgeAreas(): Promise<string[]> {
+    return this.repository.getDistinctAreas();
+  }
+
+  private buildSearchCacheKey(query: string): string {
+    const hash = crypto
+      .createHash('md5')
+      .update(query)
+      .digest('hex')
+      .slice(0, API_LIMITS.MAX_SUGGESTIONS);
+    return `${MEC_CACHE_KEYS.COURSES_SEARCH}${hash}`;
+  }
+}
diff --git a/src/mec-sync/services/csv-downloader.service.ts b/src/mec-sync/services/csv-downloader.service.ts
new file mode 100644
index 0000000..4b76982
--- /dev/null
+++ b/src/mec-sync/services/csv-downloader.service.ts
@@ -0,0 +1,133 @@
+/**
+ * CSV Downloader Service
+ * Single Responsibility: Download CSV file using Puppeteer with Cloudflare bypass
+ */
+
+import { Injectable } from '@nestjs/common';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import {
+  CRYPTO_CONSTANTS,
+  API_LIMITS,
+} from '../../common/constants/app.constants';
+import { CloudflareHandlerService } from './cloudflare-handler.service';
+import type { Browser, Page } from 'puppeteer';
+import { MEC_CSV_URL, PUPPETEER_CONFIG, PUPPETEER_ARGS } from '../constants';
+
+/* eslint-disable @typescript-eslint/no-require-imports, @typescript-eslint/no-unsafe-assignment */
+const puppeteerExtra: {
+  use: (plugin: unknown) => void;
+  launch: (options: Record<string, unknown>) => Promise<Browser>;
+} = require('puppeteer-extra');
+const StealthPlugin: () => unknown = require('puppeteer-extra-plugin-stealth');
+/* eslint-enable @typescript-eslint/no-require-imports, @typescript-eslint/no-unsafe-assignment */
+
+puppeteerExtra.use(StealthPlugin());
+
+@Injectable()
+export class CsvDownloaderService {
+  private readonly context = 'CsvDownloader';
+
+  constructor(
+    private readonly logger: AppLoggerService,
+    private readonly cloudflareHandler: CloudflareHandlerService,
+  ) {}
+
+  /**
+   * Download CSV file from MEC using Puppeteer
+   */
+  async download(url: string = MEC_CSV_URL): Promise<Buffer> {
+    this.logger.log('Launching Puppeteer with stealth mode...', this.context);
+
+    const browser = await this.launchBrowser();
+
+    try {
+      const page = await this.createPage(browser);
+      await this.navigateToMainSite(page);
+      return await this.downloadFile(page, url);
+    } finally {
+      await browser.close();
+    }
+  }
+
+  private async launchBrowser(): Promise<Browser> {
+    return puppeteerExtra.launch({
+      headless: true,
+      args: [...PUPPETEER_ARGS],
+    });
+  }
+
+  private async createPage(browser: Browser): Promise<Page> {
+    const page = await browser.newPage();
+
+    await page.setExtraHTTPHeaders({
+      'Accept-Language': 'pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7',
+      Accept:
+        'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
+    });
+
+    await page.setViewport({ width: 1920, height: 1080 });
+
+    return page;
+  }
+
+  private async navigateToMainSite(page: Page): Promise<void> {
+    const mainSiteUrl = 'https://dadosabertos.mec.gov.br';
+
+    this.logger.log(`Navigating to main site: ${mainSiteUrl}`, this.context);
+
+    await page.goto(mainSiteUrl, {
+      waitUntil: 'networkidle2',
+      timeout: PUPPETEER_CONFIG.NAVIGATION_TIMEOUT,
+    });
+
+    await this.delay(PUPPETEER_CONFIG.HUMAN_DELAY);
+    await this.cloudflareHandler.waitForChallengeIfNeeded(page);
+  }
+
+  private async downloadFile(page: Page, url: string): Promise<Buffer> {
+    this.logger.log(`Requesting CSV file: ${url}`, this.context);
+
+    const response = await page.goto(url, {
+      waitUntil: 'networkidle0',
+      timeout: PUPPETEER_CONFIG.DOWNLOAD_TIMEOUT,
+    });
+
+    if (!response) {
+      throw new Error('No response received');
+    }
+
+    await this.cloudflareHandler.waitForChallengeIfNeeded(page);
+
+    const buffer = Buffer.from(await response.buffer());
+    this.validateCsvContent(buffer);
+
+    this.logger.log(
+      `Downloaded ${this.formatFileSize(buffer.length)}`,
+      this.context,
+    );
+
+    return buffer;
+  }
+
+  private validateCsvContent(buffer: Buffer): void {
+    const start = buffer
+      .slice(0, API_LIMITS.MAX_PREVIEW_CHARS)
+      .toString('utf-8')
+      .toLowerCase();
+    const isHtml = start.includes('<!doctype') || start.includes('<html');
+
+    if (isHtml) {
+      throw new Error(
+        'Received HTML instead of CSV - Cloudflare may still be blocking',
+      );
+    }
+  }
+
+  private formatFileSize(bytes: number): string {
+    return `${(bytes / CRYPTO_CONSTANTS.BYTES_PER_MB).toFixed(2)} MB`;
+  }
+
+  private delay(ms: number): Promise<void> {
+    return new Promise((resolve) => setTimeout(resolve, ms));
+  }
+}
diff --git a/src/mec-sync/services/csv-encoding.service.ts b/src/mec-sync/services/csv-encoding.service.ts
new file mode 100644
index 0000000..f928dd9
--- /dev/null
+++ b/src/mec-sync/services/csv-encoding.service.ts
@@ -0,0 +1,45 @@
+/**
+ * CSV Encoding Detector
+ * Single Responsibility: Detect and convert CSV file encoding
+ */
+
+import { Injectable } from '@nestjs/common';
+import { AppLoggerService } from '../../common/logger/logger.service';
+
+/* eslint-disable @typescript-eslint/no-require-imports, @typescript-eslint/no-unsafe-assignment */
+const iconv: {
+  decode: (buffer: Buffer, encoding: string) => string;
+} = require('iconv-lite');
+/* eslint-enable @typescript-eslint/no-require-imports, @typescript-eslint/no-unsafe-assignment */
+
+@Injectable()
+export class CsvEncodingService {
+  private readonly context = 'CsvEncoding';
+
+  constructor(private readonly logger: AppLoggerService) {}
+
+  /**
+   * Detect encoding and convert buffer to UTF-8 string
+   */
+  decode(buffer: Buffer): string {
+    if (this.isValidUtf8(buffer)) {
+      this.logger.log('CSV detected as UTF-8', this.context);
+      return buffer.toString('utf8');
+    }
+
+    this.logger.log(
+      'CSV detected as Latin-1, converting to UTF-8',
+      this.context,
+    );
+    return iconv.decode(buffer, 'latin1');
+  }
+
+  private isValidUtf8(buffer: Buffer): boolean {
+    try {
+      const content = buffer.toString('utf8');
+      return !content.includes('\uFFFD'); // No replacement characters
+    } catch {
+      return false;
+    }
+  }
+}
diff --git a/src/mec-sync/services/csv-file-cache.service.ts b/src/mec-sync/services/csv-file-cache.service.ts
new file mode 100644
index 0000000..d30b95e
--- /dev/null
+++ b/src/mec-sync/services/csv-file-cache.service.ts
@@ -0,0 +1,74 @@
+/**
+ * CSV File Cache Service
+ * Single Responsibility: Manage local CSV file caching
+ */
+
+import { Injectable } from '@nestjs/common';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { TIME_MS } from '../../common/constants/app.constants';
+import * as fs from 'fs';
+import * as path from 'path';
+import { LOCAL_CSV_PATH, CACHE_VALIDITY_DAYS } from '../constants';
+
+@Injectable()
+export class CsvFileCacheService {
+  private readonly logger: AppLoggerService;
+  private readonly context = 'CsvFileCache';
+
+  constructor(logger: AppLoggerService) {
+    this.logger = logger;
+  }
+
+  /**
+   * Check if cached file exists and is still valid
+   */
+  isValid(): boolean {
+    if (!fs.existsSync(LOCAL_CSV_PATH)) {
+      return false;
+    }
+
+    const stats = fs.statSync(LOCAL_CSV_PATH);
+    const validityMs = CACHE_VALIDITY_DAYS * TIME_MS.DAY;
+    const expirationTime = Date.now() - validityMs;
+
+    return stats.mtimeMs > expirationTime;
+  }
+
+  /**
+   * Read cached CSV file
+   */
+  read(): Buffer {
+    this.logger.log(`Reading cached CSV: ${LOCAL_CSV_PATH}`, this.context);
+    return fs.readFileSync(LOCAL_CSV_PATH);
+  }
+
+  /**
+   * Write buffer to cache
+   */
+  write(buffer: Buffer): void {
+    try {
+      this.ensureDirectoryExists();
+      fs.writeFileSync(LOCAL_CSV_PATH, buffer);
+      this.logger.log(`Cached CSV to: ${LOCAL_CSV_PATH}`, this.context);
+    } catch (error) {
+      this.logger.warn(
+        `Failed to cache CSV: ${error instanceof Error ? error.message : 'Unknown'}`,
+        this.context,
+      );
+    }
+  }
+
+  /**
+   * Check if cache file exists (even if expired)
+   */
+  exists(): boolean {
+    return fs.existsSync(LOCAL_CSV_PATH);
+  }
+
+  private ensureDirectoryExists(): void {
+    const dir = path.dirname(LOCAL_CSV_PATH);
+    if (!fs.existsSync(dir)) {
+      fs.mkdirSync(dir, { recursive: true });
+    }
+  }
+}
diff --git a/src/mec-sync/services/csv-row-processor.service.ts b/src/mec-sync/services/csv-row-processor.service.ts
new file mode 100644
index 0000000..04ffca6
--- /dev/null
+++ b/src/mec-sync/services/csv-row-processor.service.ts
@@ -0,0 +1,100 @@
+/**
+ * CSV Row Processor Service
+ * Handles row-by-row processing of MEC CSV data
+ */
+
+import { Injectable } from '@nestjs/common';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import {
+  NormalizedInstitution,
+  NormalizedCourse,
+  SyncError,
+} from '../interfaces/mec-data.interface';
+import { parseCsvLine } from '../parsers/csv-line.parser';
+import { mapToMecRow } from '../parsers/mec-row.mapper';
+import {
+  normalizeInstitution,
+  normalizeCourse,
+} from '../parsers/entity.normalizer';
+
+export interface RowProcessingResult {
+  institutions: Map<number, NormalizedInstitution>;
+  courses: NormalizedCourse[];
+  errors: SyncError[];
+}
+
+@Injectable()
+export class CsvRowProcessorService {
+  private readonly context = 'CsvRowProcessor';
+
+  constructor(private readonly logger: AppLoggerService) {}
+
+  processDataRows(
+    lines: string[],
+    columnMap: Map<string, number>,
+  ): RowProcessingResult {
+    const institutions = new Map<number, NormalizedInstitution>();
+    const courses: NormalizedCourse[] = [];
+    const errors: SyncError[] = [];
+
+    for (let i = 1; i < lines.length; i++) {
+      this.processRow(lines[i], i, columnMap, institutions, courses, errors);
+    }
+
+    this.logParseResult(institutions.size, courses.length, errors.length);
+
+    return { institutions, courses, errors };
+  }
+
+  private processRow(
+    line: string,
+    rowIndex: number,
+    columnMap: Map<string, number>,
+    institutions: Map<number, NormalizedInstitution>,
+    courses: NormalizedCourse[],
+    errors: SyncError[],
+  ): void {
+    try {
+      const values = parseCsvLine(line);
+      const row = mapToMecRow(values, columnMap);
+
+      const institution = normalizeInstitution(row);
+      if (institution && !institutions.has(institution.codigoIes)) {
+        institutions.set(institution.codigoIes, institution);
+      }
+
+      const course = normalizeCourse(row);
+      if (course) {
+        courses.push(course);
+      }
+    } catch (error) {
+      this.recordError(errors, rowIndex, error);
+    }
+  }
+
+  private recordError(
+    errors: SyncError[],
+    rowIndex: number,
+    error: unknown,
+  ): void {
+    errors.push({
+      row: rowIndex + 1,
+      message: error instanceof Error ? error.message : 'Unknown error',
+    });
+
+    if (errors.length % 1000 === 0) {
+      this.logger.warn(`${errors.length} parse errors so far...`, this.context);
+    }
+  }
+
+  private logParseResult(
+    institutionCount: number,
+    courseCount: number,
+    errorCount: number,
+  ): void {
+    this.logger.log(
+      `Parsed: ${institutionCount} institutions, ${courseCount} courses, ${errorCount} errors`,
+      this.context,
+    );
+  }
+}
diff --git a/src/mec-sync/services/data-sync.service.ts b/src/mec-sync/services/data-sync.service.ts
new file mode 100644
index 0000000..64a122f
--- /dev/null
+++ b/src/mec-sync/services/data-sync.service.ts
@@ -0,0 +1,90 @@
+/**
+ * MEC Data Sync Service
+ * Handles institution and course synchronization logic
+ */
+
+import { Injectable } from '@nestjs/common';
+import { CacheService } from '../../common/cache/cache.service';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { InstitutionRepository, CourseRepository } from '../repositories';
+import { MEC_CACHE_KEYS } from '../interfaces/mec-data.interface';
+import { ParseResult } from './mec-csv-parser.service';
+
+@Injectable()
+export class DataSyncService {
+  private readonly context = 'MecSync';
+
+  constructor(
+    private readonly cache: CacheService,
+    private readonly logger: AppLoggerService,
+    private readonly institutionRepo: InstitutionRepository,
+    private readonly courseRepo: CourseRepository,
+  ) {}
+
+  async syncInstitutions(
+    parseResult: ParseResult,
+  ): Promise<{ inserted: number; updated: number }> {
+    const institutions = Array.from(parseResult.institutions.values());
+    this.logger.log(
+      `Syncing ${institutions.length} institutions...`,
+      this.context,
+    );
+
+    const existingCodes = await this.institutionRepo.getExistingCodes();
+    const newInstitutions = institutions.filter(
+      (i) => !existingCodes.has(i.codigoIes),
+    );
+
+    if (newInstitutions.length === 0) {
+      this.logger.log('No new institutions to insert', this.context);
+      return { inserted: 0, updated: 0 };
+    }
+
+    const inserted = await this.institutionRepo.bulkCreate(newInstitutions);
+    this.logger.log(`Inserted ${inserted} new institutions`, this.context);
+
+    return { inserted, updated: 0 };
+  }
+
+  async syncCourses(
+    parseResult: ParseResult,
+  ): Promise<{ inserted: number; updated: number }> {
+    this.logger.log(
+      `Syncing ${parseResult.courses.length} courses...`,
+      this.context,
+    );
+
+    const existingCodes = await this.courseRepo.getExistingCodes();
+    const validIesCodes = await this.institutionRepo.getExistingCodes();
+
+    const newCourses = parseResult.courses.filter(
+      (c) => !existingCodes.has(c.codigoCurso),
+    );
+
+    if (newCourses.length === 0) {
+      this.logger.log('No new courses to insert', this.context);
+      return { inserted: 0, updated: 0 };
+    }
+
+    const inserted = await this.courseRepo.bulkCreate(
+      newCourses,
+      validIesCodes,
+    );
+    this.logger.log(`Inserted ${inserted} new courses`, this.context);
+
+    return { inserted, updated: 0 };
+  }
+
+  async invalidateCaches(): Promise<void> {
+    this.logger.log('Invalidating MEC caches...', this.context);
+
+    await Promise.all([
+      this.cache.delete(MEC_CACHE_KEYS.INSTITUTIONS_LIST),
+      this.cache.deletePattern(`${MEC_CACHE_KEYS.INSTITUTIONS_BY_UF}*`),
+      this.cache.deletePattern(`${MEC_CACHE_KEYS.COURSES_BY_IES}*`),
+      this.cache.deletePattern(`${MEC_CACHE_KEYS.COURSES_SEARCH}*`),
+    ]);
+
+    this.logger.log('MEC caches invalidated', this.context);
+  }
+}
diff --git a/src/mec-sync/services/index.ts b/src/mec-sync/services/index.ts
new file mode 100644
index 0000000..da99736
--- /dev/null
+++ b/src/mec-sync/services/index.ts
@@ -0,0 +1,30 @@
+/**
+ * MEC-Sync Services - Barrel Export
+ */
+
+// Query Services
+export { InstitutionQueryService } from './institution-query.service';
+export { CourseQueryService } from './course-query.service';
+export { MecStatsService } from './mec-stats.service';
+
+// Sync Services
+export { MecSyncOrchestratorService } from './mec-sync.service';
+export { DataSyncService } from './data-sync.service';
+export {
+  SyncHelperService,
+  type SyncSuccessStats,
+} from './sync-helper.service';
+
+// CSV Services
+export {
+  MecCsvParserService,
+  type ParseResult,
+} from './mec-csv-parser.service';
+export { CsvFileCacheService } from './csv-file-cache.service';
+export { CsvDownloaderService } from './csv-downloader.service';
+export { CsvEncodingService } from './csv-encoding.service';
+export {
+  CsvRowProcessorService,
+  type RowProcessingResult,
+} from './csv-row-processor.service';
+export { CloudflareHandlerService } from './cloudflare-handler.service';
diff --git a/src/mec-sync/services/institution-query.service.ts b/src/mec-sync/services/institution-query.service.ts
new file mode 100644
index 0000000..9df6f94
--- /dev/null
+++ b/src/mec-sync/services/institution-query.service.ts
@@ -0,0 +1,97 @@
+/**
+ * Institution Query Service (Refactored)
+ * Single Responsibility: Query operations for institutions
+ */
+
+import { Injectable } from '@nestjs/common';
+import { CacheService } from '../../common/cache/cache.service';
+import { InstitutionRepository } from '../repositories';
+import {
+  InstitutionDto,
+  InstitutionWithCoursesDto,
+  CourseBasicDto,
+} from '../dto';
+import {
+  MEC_CACHE_KEYS,
+  MEC_CACHE_TTL,
+} from '../interfaces/mec-data.interface';
+import { APP_CONSTANTS } from '../../common/constants/app.constants';
+
+@Injectable()
+export class InstitutionQueryService {
+  constructor(
+    private readonly repository: InstitutionRepository,
+    private readonly cache: CacheService,
+  ) {}
+
+  async listAll(): Promise<InstitutionDto[]> {
+    const cached = await this.cache.get<InstitutionDto[]>(
+      MEC_CACHE_KEYS.INSTITUTIONS_LIST,
+    );
+    if (cached) return cached;
+
+    const institutions = await this.repository.findAll();
+
+    await this.cache.set(
+      MEC_CACHE_KEYS.INSTITUTIONS_LIST,
+      institutions,
+      MEC_CACHE_TTL.INSTITUTIONS_LIST,
+    );
+
+    return institutions;
+  }
+
+  async listByState(uf: string): Promise<InstitutionDto[]> {
+    const normalizedUf = uf.toUpperCase();
+    const cacheKey = `${MEC_CACHE_KEYS.INSTITUTIONS_BY_UF}${normalizedUf}`;
+
+    const cached = await this.cache.get<InstitutionDto[]>(cacheKey);
+    if (cached) return cached;
+
+    const institutions = await this.repository.findByUf(normalizedUf);
+
+    await this.cache.set(
+      cacheKey,
+      institutions,
+      MEC_CACHE_TTL.INSTITUTIONS_BY_UF,
+    );
+
+    return institutions;
+  }
+
+  async getByCode(
+    codigoIes: number,
+  ): Promise<InstitutionWithCoursesDto | null> {
+    const institution = await this.repository.findByCode(codigoIes);
+    if (!institution) return null;
+
+    return {
+      id: institution.id,
+      codigoIes: institution.codigoIes,
+      nome: institution.nome,
+      sigla: institution.sigla,
+      uf: institution.uf,
+      municipio: institution.municipio,
+      categoria: institution.categoria,
+      organizacao: institution.organizacao,
+      courses: institution.courses as CourseBasicDto[],
+    };
+  }
+
+  async search(
+    query: string,
+    limit: number = APP_CONSTANTS.DEFAULT_PAGE_SIZE,
+  ): Promise<InstitutionDto[]> {
+    const normalizedQuery = query.toLowerCase().trim();
+
+    if (normalizedQuery.length < 2) {
+      return [];
+    }
+
+    return this.repository.search(normalizedQuery, limit);
+  }
+
+  async getStateList(): Promise<string[]> {
+    return this.repository.getDistinctUfs();
+  }
+}
diff --git a/src/mec-sync/services/mec-csv-parser.service.ts b/src/mec-sync/services/mec-csv-parser.service.ts
index a2c26a2..d7029f8 100644
--- a/src/mec-sync/services/mec-csv-parser.service.ts
+++ b/src/mec-sync/services/mec-csv-parser.service.ts
@@ -1,43 +1,23 @@
 /**
- * MEC CSV Parser Service
- * Handles downloading and parsing the MEC courses dataset
- * Uses Puppeteer with Stealth plugin to bypass Cloudflare protection
+ * CSV Parser Service
+ * Orchestrates the CSV parsing pipeline
  */
 
 import { Injectable } from '@nestjs/common';
 import { AppLoggerService } from '../../common/logger/logger.service';
+import { CsvFileCacheService } from './csv-file-cache.service';
+import { CsvDownloaderService } from './csv-downloader.service';
+import { CsvEncodingService } from './csv-encoding.service';
+import { CsvRowProcessorService } from './csv-row-processor.service';
 import {
-  MecCsvRow,
   NormalizedInstitution,
   NormalizedCourse,
   SyncError,
 } from '../interfaces/mec-data.interface';
-import * as fs from 'fs';
-import * as path from 'path';
-import type { Browser, Page, HTTPResponse } from 'puppeteer';
+import { MEC_CSV_URL } from '../constants';
+import { parseCsvLine, buildColumnMap } from '../parsers/csv-line.parser';
 
-// Dynamic imports for packages without proper types
-/* eslint-disable @typescript-eslint/no-require-imports, @typescript-eslint/no-unsafe-assignment */
-const iconv: {
-  decode: (buffer: Buffer, encoding: string) => string;
-} = require('iconv-lite');
-const puppeteerExtra: {
-  use: (plugin: unknown) => void;
-  launch: (options: Record<string, unknown>) => Promise<Browser>;
-} = require('puppeteer-extra');
-const StealthPlugin: () => unknown = require('puppeteer-extra-plugin-stealth');
-/* eslint-enable @typescript-eslint/no-require-imports, @typescript-eslint/no-unsafe-assignment */
-
-// Enable stealth mode to bypass Cloudflare detection
-puppeteerExtra.use(StealthPlugin());
-
-const MEC_CSV_URL =
-  'https://dadosabertos.mec.gov.br/images/conteudo/Ind-ensino-superior/2022//PDA_Dados_Cursos_Graduacao_Brasil.csv';
-
-// Local cache path for downloaded CSV
-const LOCAL_CSV_PATH = path.join(process.cwd(), 'data', 'mec-courses.csv');
-
-interface ParseResult {
+export interface ParseResult {
   institutions: Map<number, NormalizedInstitution>;
   courses: NormalizedCourse[];
   errors: SyncError[];
@@ -47,356 +27,66 @@ interface ParseResult {
 
 @Injectable()
 export class MecCsvParserService {
-  constructor(private readonly logger: AppLoggerService) {}
+  private readonly context = 'MecCsvParser';
+
+  constructor(
+    private readonly logger: AppLoggerService,
+    private readonly fileCache: CsvFileCacheService,
+    private readonly downloader: CsvDownloaderService,
+    private readonly encoding: CsvEncodingService,
+    private readonly rowProcessor: CsvRowProcessorService,
+  ) {}
 
   /**
    * Download and parse the MEC CSV file
-   * Uses Puppeteer to bypass Cloudflare protection
-   * Caches the file locally for faster subsequent syncs
    */
   async downloadAndParse(url: string = MEC_CSV_URL): Promise<ParseResult> {
-    let csvBuffer: Buffer;
-
-    // Check if we have a recent local cache (less than 1 day old)
-    const useCache = this.shouldUseCache();
-
-    if (useCache) {
-      this.logger.log(
-        `Using cached CSV file: ${LOCAL_CSV_PATH}`,
-        'MecCsvParser',
-      );
-      csvBuffer = fs.readFileSync(LOCAL_CSV_PATH);
-    } else {
-      try {
-        this.logger.log(
-          `Downloading CSV via Puppeteer (bypasses Cloudflare): ${url}`,
-          'MecCsvParser',
-        );
-        csvBuffer = await this.downloadWithPuppeteer(url);
-        this.logger.log(
-          `Downloaded ${(csvBuffer.length / 1024 / 1024).toFixed(2)} MB`,
-          'MecCsvParser',
-        );
-
-        // Cache the file locally
-        this.cacheFile(csvBuffer);
-      } catch (error) {
-        this.logger.warn(
-          `Puppeteer download failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
-          'MecCsvParser',
-        );
-
-        // Try local fallback if exists
-        if (fs.existsSync(LOCAL_CSV_PATH)) {
-          this.logger.log(
-            `Falling back to local CSV: ${LOCAL_CSV_PATH}`,
-            'MecCsvParser',
-          );
-          csvBuffer = fs.readFileSync(LOCAL_CSV_PATH);
-        } else {
-          throw new Error(
-            `MEC CSV download failed. Error: ${error instanceof Error ? error.message : 'Unknown'}. ` +
-              `No local cache available at ${LOCAL_CSV_PATH}.`,
-          );
-        }
-      }
-    }
-
-    // Try to detect encoding - if it's already valid UTF-8, use it directly
-    // Otherwise, try Latin-1 decoding (older MEC CSVs used Latin-1)
-    let csvContent: string;
-    try {
-      // Check if buffer is valid UTF-8
-      const utf8Content = csvBuffer.toString('utf8');
-      // If no replacement characters, it's valid UTF-8
-      if (!utf8Content.includes('\uFFFD')) {
-        csvContent = utf8Content;
-        this.logger.log('CSV detected as UTF-8', 'MecCsvParser');
-      } else {
-        csvContent = iconv.decode(csvBuffer, 'latin1');
-        this.logger.log(
-          'CSV detected as Latin-1, converted to UTF-8',
-          'MecCsvParser',
-        );
-      }
-    } catch {
-      // Fallback to Latin-1
-      csvContent = iconv.decode(csvBuffer, 'latin1');
-      this.logger.log('CSV encoding fallback to Latin-1', 'MecCsvParser');
-    }
-
-    return this.parseCsv(csvContent, csvBuffer.length);
+    const buffer = await this.getFileBuffer(url);
+    const content = this.encoding.decode(buffer);
+    return this.parse(content, buffer.length);
   }
 
-  /**
-   * Check if we should use cached file
-   * Returns true if cache exists and is less than 6 days old
-   */
-  private shouldUseCache(): boolean {
-    if (!fs.existsSync(LOCAL_CSV_PATH)) {
-      return false;
+  private async getFileBuffer(url: string): Promise<Buffer> {
+    if (this.fileCache.isValid()) {
+      return this.fileCache.read();
     }
 
-    const stats = fs.statSync(LOCAL_CSV_PATH);
-    const sixDaysAgo = Date.now() - 6 * 24 * 60 * 60 * 1000;
-
-    return stats.mtimeMs > sixDaysAgo;
-  }
-
-  /**
-   * Cache the downloaded CSV file
-   */
-  private cacheFile(buffer: Buffer): void {
     try {
-      const dir = path.dirname(LOCAL_CSV_PATH);
-      if (!fs.existsSync(dir)) {
-        fs.mkdirSync(dir, { recursive: true });
-      }
-      fs.writeFileSync(LOCAL_CSV_PATH, buffer);
-      this.logger.log(`Cached CSV to: ${LOCAL_CSV_PATH}`, 'MecCsvParser');
+      const buffer = await this.downloader.download(url);
+      this.fileCache.write(buffer);
+      return buffer;
     } catch (error) {
-      this.logger.warn(
-        `Failed to cache CSV: ${error instanceof Error ? error.message : 'Unknown'}`,
-        'MecCsvParser',
-      );
+      return this.handleDownloadError(error);
     }
   }
 
-  /**
-   * Download file using Puppeteer with Stealth plugin to bypass Cloudflare
-   * This simulates a real browser and passes JS challenges automatically
-   */
-  private async downloadWithPuppeteer(url: string): Promise<Buffer> {
-    this.logger.log('Launching Puppeteer with stealth mode...', 'MecCsvParser');
-
-    const browser: Browser = await puppeteerExtra.launch({
-      headless: true,
-      args: [
-        '--no-sandbox',
-        '--disable-setuid-sandbox',
-        '--disable-dev-shm-usage',
-        '--disable-gpu',
-        '--disable-web-security',
-        '--disable-features=VizDisplayCompositor',
-        '--window-size=1920,1080',
-      ],
-    });
-
-    try {
-      const page: Page = await browser.newPage();
-
-      // Set extra HTTP headers to look more like a real browser
-      await page.setExtraHTTPHeaders({
-        'Accept-Language': 'pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7',
-        Accept:
-          'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
-      });
-
-      // Set viewport to look like a real desktop browser
-      await page.setViewport({ width: 1920, height: 1080 });
-
-      this.logger.log(`Navigating to: ${url}`, 'MecCsvParser');
-
-      // First, go to the main site to get cookies
-      const mainSiteUrl = 'https://dadosabertos.mec.gov.br';
-      await page.goto(mainSiteUrl, {
-        waitUntil: 'networkidle2',
-        timeout: 60000,
-      });
-
-      // Wait a bit to simulate human behavior
-      await this.delay(2000);
-
-      // Check if we hit a Cloudflare challenge
-      let content = await page.content();
-      if (this.isCloudflareChallenge(content)) {
-        this.logger.log(
-          'Cloudflare challenge detected, waiting for it to complete...',
-          'MecCsvParser',
-        );
-
-        // Wait for the challenge to resolve (Cloudflare typically redirects after solving)
-        await page.waitForFunction(
-          () => {
-            const body = document.body?.innerHTML || '';
-            return (
-              !body.includes('Just a moment') &&
-              !body.includes('Checking your browser') &&
-              !body.includes('Verifying') &&
-              !body.includes('cf-spinner')
-            );
-          },
-          { timeout: 45000 },
-        );
-
-        this.logger.log('Cloudflare challenge passed!', 'MecCsvParser');
-        await this.delay(1000);
-      }
-
-      // Now navigate to the actual CSV file
-      this.logger.log('Requesting CSV file...', 'MecCsvParser');
-      const response: HTTPResponse | null = await page.goto(url, {
-        waitUntil: 'networkidle0',
-        timeout: 180000, // 3 minutes for large file
-      });
-
-      if (!response) {
-        throw new Error('No response received');
-      }
+  private handleDownloadError(error: unknown): Buffer {
+    const message = error instanceof Error ? error.message : 'Unknown error';
+    this.logger.warn(`Download failed: ${message}`, this.context);
 
-      // Check again for Cloudflare
-      content = await page.content();
-      if (this.isCloudflareChallenge(content)) {
-        this.logger.log(
-          'Second Cloudflare challenge, waiting...',
-          'MecCsvParser',
-        );
-
-        await page.waitForFunction(
-          () => {
-            const body = document.body?.innerHTML || '';
-            return (
-              !body.includes('Just a moment') &&
-              !body.includes('Checking your browser')
-            );
-          },
-          { timeout: 45000 },
-        );
-
-        // Retry the download
-        const retryResponse: HTTPResponse | null = await page.goto(url, {
-          waitUntil: 'networkidle0',
-          timeout: 180000,
-        });
-
-        if (!retryResponse) {
-          throw new Error('No response after Cloudflare retry');
-        }
-
-        const buffer = Buffer.from(await retryResponse.buffer());
-
-        // Validate it's actually CSV, not HTML
-        if (this.isHtmlContent(buffer)) {
-          throw new Error(
-            'Received HTML instead of CSV - Cloudflare may still be blocking',
-          );
-        }
-
-        return buffer;
-      }
-
-      const csvBuffer = Buffer.from(await response.buffer());
-
-      // Validate it's actually CSV
-      if (this.isHtmlContent(csvBuffer)) {
-        throw new Error(
-          'Received HTML instead of CSV - Cloudflare may still be blocking',
-        );
-      }
-
-      this.logger.log(
-        `Successfully downloaded ${(csvBuffer.length / 1024 / 1024).toFixed(2)} MB`,
-        'MecCsvParser',
-      );
-
-      return csvBuffer;
-    } finally {
-      await browser.close();
+    if (this.fileCache.exists()) {
+      this.logger.log('Falling back to cached file', this.context);
+      return this.fileCache.read();
     }
-  }
-
-  /**
-   * Check if content is a Cloudflare challenge page
-   */
-  private isCloudflareChallenge(content: string): boolean {
-    return (
-      content.includes('Just a moment') ||
-      content.includes('Checking your browser') ||
-      content.includes('cf-spinner') ||
-      content.includes('Verifying you are human')
-    );
-  }
-
-  /**
-   * Check if buffer contains HTML (not CSV)
-   */
-  private isHtmlContent(buffer: Buffer): boolean {
-    const start = buffer.slice(0, 100).toString('utf-8').toLowerCase();
-    return start.includes('<!doctype') || start.includes('<html');
-  }
 
-  /**
-   * Delay helper
-   */
-  private delay(ms: number): Promise<void> {
-    return new Promise((resolve) => setTimeout(resolve, ms));
+    throw new Error(`MEC CSV download failed: ${message}. No cache available.`);
   }
 
-  /**
-   * Parse CSV content and extract institutions/courses
-   */
-  private parseCsv(content: string, fileSize: number): ParseResult {
-    // Normalize line endings (CRLF -> LF) and split
-    const lines = content
-      .replace(/\r\n/g, '\n')
-      .replace(/\r/g, '\n')
-      .split('\n')
-      .filter((line) => line.trim());
-    const errors: SyncError[] = [];
-
-    if (lines.length < 2) {
-      throw new Error('CSV file is empty or has no data rows');
-    }
+  private parse(content: string, fileSize: number): ParseResult {
+    const lines = this.splitIntoLines(content);
+    this.validateMinimumLines(lines);
 
-    // Parse header to get column indices
-    const header = this.parseCsvLine(lines[0]);
-    const columnMap = this.buildColumnMap(header);
+    const header = parseCsvLine(lines[0]);
+    const columnMap = buildColumnMap(header);
 
     this.logger.log(
-      `CSV has ${lines.length - 1} data rows, columns: ${header.length}`,
-      'MecCsvParser',
+      `CSV: ${lines.length - 1} rows, ${header.length} columns`,
+      this.context,
     );
 
-    // Use Maps to deduplicate institutions
-    const institutions = new Map<number, NormalizedInstitution>();
-    const courses: NormalizedCourse[] = [];
-
-    // Process data rows
-    for (let i = 1; i < lines.length; i++) {
-      try {
-        const values = this.parseCsvLine(lines[i]);
-        const row = this.mapToRow(values, columnMap);
-
-        // Extract institution (deduplicated by codigoIes)
-        const institution = this.normalizeInstitution(row);
-        if (institution && !institutions.has(institution.codigoIes)) {
-          institutions.set(institution.codigoIes, institution);
-        }
-
-        // Extract course
-        const course = this.normalizeCourse(row);
-        if (course) {
-          courses.push(course);
-        }
-      } catch (error) {
-        errors.push({
-          row: i + 1,
-          message: error instanceof Error ? error.message : 'Unknown error',
-        });
-
-        // Log every 1000th error to avoid spam
-        if (errors.length % 1000 === 0) {
-          this.logger.warn(
-            `${errors.length} parse errors so far...`,
-            'MecCsvParser',
-          );
-        }
-      }
-    }
-
-    this.logger.log(
-      `Parsed: ${institutions.size} institutions, ${courses.length} courses, ${errors.length} errors`,
-      'MecCsvParser',
+    const { institutions, courses, errors } = this.rowProcessor.processDataRows(
+      lines,
+      columnMap,
     );
 
     return {
@@ -408,248 +98,17 @@ export class MecCsvParserService {
     };
   }
 
-  /**
-   * Parse a single CSV line handling quoted fields
-   */
-  private parseCsvLine(line: string): string[] {
-    const result: string[] = [];
-    let current = '';
-    let inQuotes = false;
-
-    // MEC CSV uses semicolon as delimiter
-    for (let i = 0; i < line.length; i++) {
-      const char = line[i];
-
-      if (char === '"') {
-        if (inQuotes && line[i + 1] === '"') {
-          current += '"';
-          i++;
-        } else {
-          inQuotes = !inQuotes;
-        }
-      } else if (char === ',' && !inQuotes) {
-        result.push(current.trim());
-        current = '';
-      } else {
-        current += char;
-      }
-    }
-
-    result.push(current.trim());
-    return result;
-  }
-
-  /**
-   * Build a map of column names to indices
-   */
-  private buildColumnMap(header: string[]): Map<string, number> {
-    const map = new Map<string, number>();
-    header.forEach((col, index) => {
-      // Normalize column names (remove BOM, trim, uppercase)
-      const normalized = col
-        .replace(/^\uFEFF/, '')
-        .trim()
-        .toUpperCase();
-      map.set(normalized, index);
-    });
-    return map;
-  }
-
-  /**
-   * Map array values to row object using column map
-   * Column names from MEC CSV 2022:
-   * CODIGO_IES, NOME_IES, CATEGORIA_ADMINISTRATIVA, ORGANIZACAO_ACADEMICA,
-   * CODIGO_CURSO, NOME_CURSO, GRAU, AREA_OCDE, MODALIDADE, SITUACAO_CURSO,
-   * QT_VAGAS_AUTORIZADAS, CARGA_HORARIA, CODIGO_AREA_OCDE_CINE, AREA_OCDE_CINE,
-   * CODIGO_MUNICIPIO, MUNICIPIO, UF, REGIAO
-   */
-  private mapToRow(
-    values: string[],
-    columnMap: Map<string, number>,
-  ): MecCsvRow {
-    const getValue = (key: string): string => {
-      const index = columnMap.get(key);
-      return index !== undefined ? values[index] || '' : '';
-    };
-
-    return {
-      CO_IES: getValue('CODIGO_IES') || getValue('CO_IES'),
-      NO_IES: getValue('NOME_IES') || getValue('NO_IES'),
-      SG_IES: getValue('SG_IES') || '', // Not in 2022 CSV
-      TP_ORGANIZACAO:
-        getValue('ORGANIZACAO_ACADEMICA') ||
-        getValue('TP_ORGANIZACAO_ACADEMICA') ||
-        getValue('TP_ORGANIZACAO'),
-      TP_CATEGORIA:
-        getValue('CATEGORIA_ADMINISTRATIVA') ||
-        getValue('TP_CATEGORIA_ADMINISTRATIVA') ||
-        getValue('TP_CATEGORIA'),
-      CO_MUNICIPIO_IES:
-        getValue('CODIGO_MUNICIPIO') ||
-        getValue('CO_MUNICIPIO_IES') ||
-        getValue('CO_MUNICIPIO'),
-      NO_MUNICIPIO_IES:
-        getValue('MUNICIPIO') ||
-        getValue('NO_MUNICIPIO_IES') ||
-        getValue('NO_MUNICIPIO'),
-      SG_UF_IES: getValue('UF') || getValue('SG_UF_IES') || getValue('SG_UF'),
-      CO_CURSO: getValue('CODIGO_CURSO') || getValue('CO_CURSO'),
-      NO_CURSO: getValue('NOME_CURSO') || getValue('NO_CURSO'),
-      TP_GRAU:
-        getValue('GRAU') ||
-        getValue('TP_GRAU_ACADEMICO') ||
-        getValue('TP_GRAU'),
-      TP_MODALIDADE:
-        getValue('MODALIDADE') ||
-        getValue('TP_MODALIDADE_ENSINO') ||
-        getValue('TP_MODALIDADE'),
-      NO_CINE_AREA_GERAL:
-        getValue('AREA_OCDE_CINE') ||
-        getValue('AREA_OCDE') ||
-        getValue('NO_CINE_AREA_GERAL') ||
-        getValue('NO_AREA'),
-      QT_CARGA_HORARIA:
-        getValue('CARGA_HORARIA') ||
-        getValue('QT_CARGA_HORARIA_TOTAL') ||
-        getValue('QT_CARGA_HORARIA'),
-      CO_SITUACAO:
-        getValue('SITUACAO_CURSO') ||
-        getValue('CO_SITUACAO_CURSO') ||
-        getValue('CO_SITUACAO'),
-    };
-  }
-
-  /**
-   * Normalize institution data from CSV row
-   */
-  private normalizeInstitution(row: MecCsvRow): NormalizedInstitution | null {
-    const codigoIes = parseInt(row.CO_IES, 10);
-
-    if (isNaN(codigoIes) || !row.NO_IES || !row.SG_UF_IES) {
-      return null;
-    }
-
-    return {
-      codigoIes,
-      nome: this.normalizeText(row.NO_IES),
-      sigla: this.normalizeText(row.SG_IES) || null,
-      organizacao: this.mapOrganizacao(row.TP_ORGANIZACAO),
-      categoria: this.mapCategoria(row.TP_CATEGORIA),
-      uf: row.SG_UF_IES.toUpperCase(),
-      municipio: this.normalizeText(row.NO_MUNICIPIO_IES) || null,
-      codigoMunicipio: parseInt(row.CO_MUNICIPIO_IES, 10) || null,
-    };
+  private splitIntoLines(content: string): string[] {
+    return content
+      .replace(/\r\n/g, '\n')
+      .replace(/\r/g, '\n')
+      .split('\n')
+      .filter((line) => line.trim());
   }
 
-  /**
-   * Normalize course data from CSV row
-   */
-  private normalizeCourse(row: MecCsvRow): NormalizedCourse | null {
-    const codigoCurso = parseInt(row.CO_CURSO, 10);
-    const codigoIes = parseInt(row.CO_IES, 10);
-
-    if (isNaN(codigoCurso) || isNaN(codigoIes) || !row.NO_CURSO) {
-      return null;
+  private validateMinimumLines(lines: string[]): void {
+    if (lines.length < 2) {
+      throw new Error('CSV file is empty or has no data rows');
     }
-
-    return {
-      codigoCurso,
-      codigoIes,
-      nome: this.normalizeText(row.NO_CURSO),
-      grau: this.mapGrau(row.TP_GRAU),
-      modalidade: this.mapModalidade(row.TP_MODALIDADE),
-      areaConhecimento: this.normalizeText(row.NO_CINE_AREA_GERAL) || null,
-      cargaHoraria: parseInt(row.QT_CARGA_HORARIA, 10) || null,
-      situacao: this.mapSituacao(row.CO_SITUACAO),
-    };
-  }
-
-  /**
-   * Normalize text: trim, title case, remove extra spaces
-   */
-  private normalizeText(text: string | undefined): string {
-    if (!text) return '';
-    return text
-      .trim()
-      .replace(/\s+/g, ' ')
-      .split(' ')
-      .map((word) => {
-        // Keep small prepositions lowercase
-        const lower = word.toLowerCase();
-        if (
-          ['de', 'da', 'do', 'das', 'dos', 'e', 'em', 'para', 'com'].includes(
-            lower,
-          )
-        ) {
-          return lower;
-        }
-        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
-      })
-      .join(' ');
-  }
-
-  /**
-   * Map organization type code to readable label
-   */
-  private mapOrganizacao(code: string): string | null {
-    const map: Record<string, string> = {
-      '1': 'Universidade',
-      '2': 'Centro Universitário',
-      '3': 'Faculdade',
-      '4': 'Instituto Federal',
-      '5': 'Centro Federal',
-    };
-    return map[code] || code || null;
-  }
-
-  /**
-   * Map administrative category code to readable label
-   */
-  private mapCategoria(code: string): string | null {
-    const map: Record<string, string> = {
-      '1': 'Pública Federal',
-      '2': 'Pública Estadual',
-      '3': 'Pública Municipal',
-      '4': 'Privada com fins lucrativos',
-      '5': 'Privada sem fins lucrativos',
-      '6': 'Especial',
-    };
-    return map[code] || code || null;
-  }
-
-  /**
-   * Map academic degree code to readable label
-   */
-  private mapGrau(code: string): string | null {
-    const map: Record<string, string> = {
-      '1': 'Bacharelado',
-      '2': 'Licenciatura',
-      '3': 'Tecnológico',
-      '4': 'Bacharelado e Licenciatura',
-    };
-    return map[code] || code || null;
-  }
-
-  /**
-   * Map teaching modality code to readable label
-   */
-  private mapModalidade(code: string): string | null {
-    const map: Record<string, string> = {
-      '1': 'Presencial',
-      '2': 'EaD',
-    };
-    return map[code] || code || null;
-  }
-
-  /**
-   * Map course status code to readable label
-   */
-  private mapSituacao(code: string): string | null {
-    const map: Record<string, string> = {
-      '1': 'Em atividade',
-      '2': 'Extinto',
-      '3': 'Em extinção',
-    };
-    return map[code] || code || null;
   }
 }
diff --git a/src/mec-sync/services/mec-query.service.ts b/src/mec-sync/services/mec-query.service.ts
deleted file mode 100644
index 0625537..0000000
--- a/src/mec-sync/services/mec-query.service.ts
+++ /dev/null
@@ -1,438 +0,0 @@
-/**
- * MEC Query Service
- * Provides cached queries for institutions and courses
- * Optimized for frontend consumption (/onboarding, /protected/settings)
- */
-
-import { Injectable } from '@nestjs/common';
-import { PrismaService } from '../../prisma/prisma.service';
-import { CacheService } from '../../common/cache/cache.service';
-import { AppLoggerService } from '../../common/logger/logger.service';
-import {
-  MEC_CACHE_KEYS,
-  MEC_CACHE_TTL,
-} from '../interfaces/mec-data.interface';
-import { MecInstitution, MecCourse } from '@prisma/client';
-import * as crypto from 'crypto';
-
-// Simplified DTOs for frontend consumption
-export interface InstitutionDto {
-  id: string;
-  codigoIes: number;
-  nome: string;
-  sigla: string | null;
-  uf: string;
-  municipio: string | null;
-  categoria: string | null;
-  organizacao: string | null;
-}
-
-export interface CourseDto {
-  id: string;
-  codigoCurso: number;
-  nome: string;
-  grau: string | null;
-  modalidade: string | null;
-  areaConhecimento: string | null;
-  institution: {
-    nome: string;
-    sigla: string | null;
-    uf: string;
-  };
-}
-
-export interface InstitutionWithCoursesDto extends InstitutionDto {
-  courses: Omit<CourseDto, 'institution'>[];
-}
-
-@Injectable()
-export class MecQueryService {
-  constructor(
-    private readonly prisma: PrismaService,
-    private readonly cache: CacheService,
-    private readonly logger: AppLoggerService,
-  ) {}
-
-  /**
-   * Get all institutions (cached)
-   * Used for institution dropdown in onboarding/settings
-   */
-  async getAllInstitutions(): Promise<InstitutionDto[]> {
-    const cacheKey = MEC_CACHE_KEYS.INSTITUTIONS_LIST;
-
-    // Try cache first
-    const cached = await this.cache.get<InstitutionDto[]>(cacheKey);
-    if (cached) {
-      return cached;
-    }
-
-    // Query database
-    const institutions = await this.prisma.mecInstitution.findMany({
-      where: { isActive: true },
-      orderBy: [{ uf: 'asc' }, { nome: 'asc' }],
-      select: {
-        id: true,
-        codigoIes: true,
-        nome: true,
-        sigla: true,
-        uf: true,
-        municipio: true,
-        categoria: true,
-        organizacao: true,
-      },
-    });
-
-    // Cache result
-    await this.cache.set(
-      cacheKey,
-      institutions,
-      MEC_CACHE_TTL.INSTITUTIONS_LIST,
-    );
-
-    return institutions;
-  }
-
-  /**
-   * Get institutions by state (cached)
-   */
-  async getInstitutionsByUf(uf: string): Promise<InstitutionDto[]> {
-    const normalizedUf = uf.toUpperCase();
-    const cacheKey = `${MEC_CACHE_KEYS.INSTITUTIONS_BY_UF}${normalizedUf}`;
-
-    // Try cache first
-    const cached = await this.cache.get<InstitutionDto[]>(cacheKey);
-    if (cached) {
-      return cached;
-    }
-
-    // Query database
-    const institutions = await this.prisma.mecInstitution.findMany({
-      where: {
-        uf: normalizedUf,
-        isActive: true,
-      },
-      orderBy: { nome: 'asc' },
-      select: {
-        id: true,
-        codigoIes: true,
-        nome: true,
-        sigla: true,
-        uf: true,
-        municipio: true,
-        categoria: true,
-        organizacao: true,
-      },
-    });
-
-    // Cache result
-    await this.cache.set(
-      cacheKey,
-      institutions,
-      MEC_CACHE_TTL.INSTITUTIONS_BY_UF,
-    );
-
-    return institutions;
-  }
-
-  /**
-   * Get courses by institution (cached)
-   */
-  async getCoursesByInstitution(codigoIes: number): Promise<CourseDto[]> {
-    const cacheKey = `${MEC_CACHE_KEYS.COURSES_BY_IES}${codigoIes}`;
-
-    // Try cache first
-    const cached = await this.cache.get<CourseDto[]>(cacheKey);
-    if (cached) {
-      return cached;
-    }
-
-    // Query database
-    const courses = await this.prisma.mecCourse.findMany({
-      where: {
-        codigoIes,
-        isActive: true,
-      },
-      orderBy: { nome: 'asc' },
-      include: {
-        institution: {
-          select: {
-            nome: true,
-            sigla: true,
-            uf: true,
-          },
-        },
-      },
-    });
-
-    const result: CourseDto[] = courses.map((c) => ({
-      id: c.id,
-      codigoCurso: c.codigoCurso,
-      nome: c.nome,
-      grau: c.grau,
-      modalidade: c.modalidade,
-      areaConhecimento: c.areaConhecimento,
-      institution: c.institution,
-    }));
-
-    // Cache result
-    await this.cache.set(cacheKey, result, MEC_CACHE_TTL.COURSES_BY_IES);
-
-    return result;
-  }
-
-  /**
-   * Search courses by name (accent-insensitive, cached with short TTL)
-   * Used for course autocomplete in onboarding/settings
-   */
-  async searchCourses(query: string, limit = 20): Promise<CourseDto[]> {
-    const normalizedQuery = query.toLowerCase().trim();
-
-    if (normalizedQuery.length < 2) {
-      return [];
-    }
-
-    // Generate cache key from query hash
-    const queryHash = crypto
-      .createHash('md5')
-      .update(normalizedQuery)
-      .digest('hex')
-      .slice(0, 8);
-    const cacheKey = `${MEC_CACHE_KEYS.COURSES_SEARCH}${queryHash}`;
-
-    // Try cache first
-    const cached = await this.cache.get<CourseDto[]>(cacheKey);
-    if (cached) {
-      return cached;
-    }
-
-    // Query database with accent-insensitive search using unaccent
-    const courses = await this.prisma.$queryRaw<
-      Array<{
-        id: string;
-        codigoCurso: number;
-        nome: string;
-        grau: string | null;
-        modalidade: string | null;
-        areaConhecimento: string | null;
-        institution_nome: string;
-        institution_sigla: string | null;
-        institution_uf: string;
-      }>
-    >`
-      SELECT 
-        c.id,
-        c."codigoCurso",
-        c.nome,
-        c.grau,
-        c.modalidade,
-        c."areaConhecimento",
-        i.nome as institution_nome,
-        i.sigla as institution_sigla,
-        i.uf as institution_uf
-      FROM "MecCourse" c
-      JOIN "MecInstitution" i ON c."codigoIes" = i."codigoIes"
-      WHERE c."isActive" = true
-        AND immutable_unaccent(lower(c.nome)) LIKE '%' || immutable_unaccent(lower(${normalizedQuery})) || '%'
-      ORDER BY c.nome ASC
-      LIMIT ${limit}
-    `;
-
-    const result: CourseDto[] = courses.map((c) => ({
-      id: c.id,
-      codigoCurso: c.codigoCurso,
-      nome: c.nome,
-      grau: c.grau,
-      modalidade: c.modalidade,
-      areaConhecimento: c.areaConhecimento,
-      institution: {
-        nome: c.institution_nome,
-        sigla: c.institution_sigla,
-        uf: c.institution_uf,
-      },
-    }));
-
-    // Cache with short TTL
-    await this.cache.set(cacheKey, result, MEC_CACHE_TTL.COURSES_SEARCH);
-
-    return result;
-  }
-
-  /**
-   * Search institutions by name or sigla (accent-insensitive)
-   * Uses PostgreSQL unaccent extension for proper Brazilian Portuguese search
-   */
-  async searchInstitutions(
-    query: string,
-    limit = 20,
-  ): Promise<InstitutionDto[]> {
-    const normalizedQuery = query.toLowerCase().trim();
-
-    if (normalizedQuery.length < 2) {
-      return [];
-    }
-
-    // Use raw SQL with unaccent for accent-insensitive search
-    const institutions = await this.prisma.$queryRaw<InstitutionDto[]>`
-      SELECT 
-        id,
-        "codigoIes",
-        nome,
-        sigla,
-        uf,
-        municipio,
-        categoria,
-        organizacao
-      FROM "MecInstitution"
-      WHERE "isActive" = true
-        AND (
-          immutable_unaccent(lower(nome)) LIKE '%' || immutable_unaccent(lower(${normalizedQuery})) || '%'
-          OR (sigla IS NOT NULL AND immutable_unaccent(lower(sigla)) LIKE '%' || immutable_unaccent(lower(${normalizedQuery})) || '%')
-        )
-      ORDER BY uf ASC, nome ASC
-      LIMIT ${limit}
-    `;
-
-    return institutions;
-  }
-
-  /**
-   * Get institution by MEC code
-   */
-  async getInstitutionByCode(
-    codigoIes: number,
-  ): Promise<InstitutionWithCoursesDto | null> {
-    const institution = await this.prisma.mecInstitution.findUnique({
-      where: { codigoIes },
-      include: {
-        courses: {
-          where: { isActive: true },
-          orderBy: { nome: 'asc' },
-          select: {
-            id: true,
-            codigoCurso: true,
-            nome: true,
-            grau: true,
-            modalidade: true,
-            areaConhecimento: true,
-          },
-        },
-      },
-    });
-
-    if (!institution) {
-      return null;
-    }
-
-    return {
-      id: institution.id,
-      codigoIes: institution.codigoIes,
-      nome: institution.nome,
-      sigla: institution.sigla,
-      uf: institution.uf,
-      municipio: institution.municipio,
-      categoria: institution.categoria,
-      organizacao: institution.organizacao,
-      courses: institution.courses,
-    };
-  }
-
-  /**
-   * Get course by MEC code
-   */
-  async getCourseByCode(codigoCurso: number): Promise<CourseDto | null> {
-    const course = await this.prisma.mecCourse.findUnique({
-      where: { codigoCurso },
-      include: {
-        institution: {
-          select: {
-            nome: true,
-            sigla: true,
-            uf: true,
-          },
-        },
-      },
-    });
-
-    if (!course) {
-      return null;
-    }
-
-    return {
-      id: course.id,
-      codigoCurso: course.codigoCurso,
-      nome: course.nome,
-      grau: course.grau,
-      modalidade: course.modalidade,
-      areaConhecimento: course.areaConhecimento,
-      institution: course.institution,
-    };
-  }
-
-  /**
-   * Get statistics for dashboard
-   */
-  async getStats() {
-    const [institutionsCount, coursesCount, coursesByGrau, institutionsByUf] =
-      await Promise.all([
-        this.prisma.mecInstitution.count({ where: { isActive: true } }),
-        this.prisma.mecCourse.count({ where: { isActive: true } }),
-        this.prisma.mecCourse.groupBy({
-          by: ['grau'],
-          where: { isActive: true },
-          _count: true,
-        }),
-        this.prisma.mecInstitution.groupBy({
-          by: ['uf'],
-          where: { isActive: true },
-          _count: true,
-          orderBy: { uf: 'asc' },
-        }),
-      ]);
-
-    return {
-      totalInstitutions: institutionsCount,
-      totalCourses: coursesCount,
-      coursesByGrau: coursesByGrau.map((g) => ({
-        grau: g.grau || 'Não informado',
-        count: g._count,
-      })),
-      institutionsByUf: institutionsByUf.map((u) => ({
-        uf: u.uf,
-        count: u._count,
-      })),
-    };
-  }
-
-  /**
-   * Get list of unique states (UFs)
-   */
-  async getUfList(): Promise<string[]> {
-    const ufs = await this.prisma.mecInstitution.findMany({
-      where: { isActive: true },
-      select: { uf: true },
-      distinct: ['uf'],
-      orderBy: { uf: 'asc' },
-    });
-
-    return ufs.map((u) => u.uf);
-  }
-
-  /**
-   * Get list of unique areas of knowledge
-   */
-  async getAreasConhecimento(): Promise<string[]> {
-    const areas = await this.prisma.mecCourse.findMany({
-      where: {
-        isActive: true,
-        areaConhecimento: { not: null },
-      },
-      select: { areaConhecimento: true },
-      distinct: ['areaConhecimento'],
-      orderBy: { areaConhecimento: 'asc' },
-    });
-
-    return areas
-      .map((a) => a.areaConhecimento)
-      .filter((a): a is string => a !== null);
-  }
-}
diff --git a/src/mec-sync/services/mec-stats.service.ts b/src/mec-sync/services/mec-stats.service.ts
new file mode 100644
index 0000000..c9ede23
--- /dev/null
+++ b/src/mec-sync/services/mec-stats.service.ts
@@ -0,0 +1,39 @@
+/**
+ * MEC Stats Service
+ * Single Responsibility: Statistics and aggregations
+ */
+
+import { Injectable } from '@nestjs/common';
+import { InstitutionRepository, CourseRepository } from '../repositories';
+import { MecStatsDto } from '../dto';
+
+@Injectable()
+export class MecStatsService {
+  constructor(
+    private readonly institutionRepo: InstitutionRepository,
+    private readonly courseRepo: CourseRepository,
+  ) {}
+
+  async getStats(): Promise<MecStatsDto> {
+    const [totalInstitutions, totalCourses, coursesByDegree, institutionsByUf] =
+      await Promise.all([
+        this.institutionRepo.count(),
+        this.courseRepo.count(),
+        this.courseRepo.countByDegree(),
+        this.institutionRepo.countByUf(),
+      ]);
+
+    return {
+      totalInstitutions,
+      totalCourses,
+      coursesByGrau: coursesByDegree.map((g) => ({
+        grau: g.grau ?? 'Não informado',
+        count: g._count,
+      })),
+      institutionsByUf: institutionsByUf.map((u) => ({
+        uf: u.uf,
+        count: u._count,
+      })),
+    };
+  }
+}
diff --git a/src/mec-sync/services/mec-sync.service.ts b/src/mec-sync/services/mec-sync.service.ts
index 235ce4f..9910781 100644
--- a/src/mec-sync/services/mec-sync.service.ts
+++ b/src/mec-sync/services/mec-sync.service.ts
@@ -1,317 +1,127 @@
 /**
- * MEC Sync Service
- * Orchestrates the synchronization process with idempotency guarantees
+ * MEC Sync Orchestrator Service
+ * Single Responsibility: Orchestrate the synchronization workflow
+ * Delegates data operations to specialized services
  */
 
 import { Injectable } from '@nestjs/common';
-import { PrismaService } from '../../prisma/prisma.service';
 import { CacheService } from '../../common/cache/cache.service';
 import { AppLoggerService } from '../../common/logger/logger.service';
-import { MecCsvParserService } from './mec-csv-parser.service';
+import { MecCsvParserService, ParseResult } from './mec-csv-parser.service';
+import { DataSyncService } from './data-sync.service';
+import { SyncHelperService } from './sync-helper.service';
+import { SyncLogRepository } from '../repositories';
 import {
-  NormalizedInstitution,
-  NormalizedCourse,
   SyncResult,
   SyncMetadata,
   MEC_CACHE_KEYS,
   MEC_CACHE_TTL,
 } from '../interfaces/mec-data.interface';
-import { MecSyncStatus } from '@prisma/client';
-
-const BATCH_SIZE = 500; // Records per batch insert
+import { APP_CONSTANTS } from '../../common/constants/app.constants';
 
 @Injectable()
-export class MecSyncService {
+export class MecSyncOrchestratorService {
+  private readonly context = 'MecSync';
+
   constructor(
-    private readonly prisma: PrismaService,
     private readonly cache: CacheService,
     private readonly logger: AppLoggerService,
     private readonly csvParser: MecCsvParserService,
+    private readonly dataSync: DataSyncService,
+    private readonly syncHelper: SyncHelperService,
+    private readonly syncLogRepo: SyncLogRepository,
   ) {}
 
-  /**
-   * Execute full synchronization process
-   */
   async sync(triggeredBy: string = 'manual'): Promise<SyncResult> {
     const startTime = Date.now();
+    await this.acquireLock();
 
-    // Try to acquire distributed lock
-    const lockAcquired = await this.cache.acquireLock(
-      MEC_CACHE_KEYS.SYNC_LOCK,
-      MEC_CACHE_TTL.SYNC_LOCK,
-    );
-
-    if (!lockAcquired) {
-      throw new Error('Sync already in progress. Please wait for the current sync to complete.');
-    }
-
-    // Create sync log entry
-    const syncLog = await this.prisma.mecSyncLog.create({
-      data: {
-        status: MecSyncStatus.RUNNING,
-        triggeredBy,
-      },
-    });
+    const syncLog = await this.syncLogRepo.create({ triggeredBy });
 
     try {
-      this.logger.log(`Starting MEC sync (id: ${syncLog.id})`, 'MecSync');
+      this.logger.log(`Starting MEC sync (id: ${syncLog.id})`, this.context);
 
-      // Step 1: Download and parse CSV
       const parseResult = await this.csvParser.downloadAndParse();
+      const syncResult = await this.performSync(parseResult);
 
-      // Step 2: Sync institutions (idempotent)
-      const institutionResult = await this.syncInstitutions(
-        Array.from(parseResult.institutions.values()),
-      );
-
-      // Step 3: Sync courses (idempotent)
-      const courseResult = await this.syncCourses(parseResult.courses);
-
-      // Step 4: Invalidate caches
-      await this.invalidateCaches();
-
-      // Step 5: Update sync metadata in Redis
-      const duration = Date.now() - startTime;
-      await this.updateSyncMetadata({
-        lastSyncAt: new Date().toISOString(),
-        lastSyncStatus: 'success',
-        lastSyncDuration: duration,
-        totalInstitutions: parseResult.institutions.size,
-        totalCourses: parseResult.courses.length,
-        triggeredBy,
-      });
-
-      // Step 6: Update sync log
-      await this.prisma.mecSyncLog.update({
-        where: { id: syncLog.id },
-        data: {
-          status: MecSyncStatus.SUCCESS,
-          completedAt: new Date(),
-          institutionsInserted: institutionResult.inserted,
-          institutionsUpdated: institutionResult.updated,
-          coursesInserted: courseResult.inserted,
-          coursesUpdated: courseResult.updated,
+      await this.syncHelper.finalizeSyncSuccess(
+        syncLog.id,
+        {
+          ...syncResult,
           totalRowsProcessed: parseResult.totalRows,
           sourceFileSize: parseResult.fileSize,
+          institutionCount: parseResult.institutions.size,
+          courseCount: parseResult.courses.length,
         },
-      });
-
-      const result: SyncResult = {
-        institutionsInserted: institutionResult.inserted,
-        institutionsUpdated: institutionResult.updated,
-        coursesInserted: courseResult.inserted,
-        coursesUpdated: courseResult.updated,
-        totalRowsProcessed: parseResult.totalRows,
-        errors: parseResult.errors,
-      };
+        startTime,
+        triggeredBy,
+      );
 
-      this.logger.log(
-        `MEC sync completed in ${(duration / 1000).toFixed(2)}s: ` +
-          `${result.institutionsInserted} new institutions, ${result.coursesInserted} new courses`,
-        'MecSync',
+      this.syncHelper.logSyncCompletion(
+        syncResult.institutionsInserted,
+        syncResult.coursesInserted,
+        startTime,
       );
 
-      return result;
+      return syncResult;
     } catch (error) {
-      // Update sync log with error
-      await this.prisma.mecSyncLog.update({
-        where: { id: syncLog.id },
-        data: {
-          status: MecSyncStatus.FAILED,
-          completedAt: new Date(),
-          errorMessage: error instanceof Error ? error.message : 'Unknown error',
-          errorDetails: error instanceof Error ? { stack: error.stack || '' } : undefined,
-        },
-      });
-
-      // Update metadata with failure
-      await this.updateSyncMetadata({
-        lastSyncAt: new Date().toISOString(),
-        lastSyncStatus: 'failed',
-        lastSyncDuration: Date.now() - startTime,
-        totalInstitutions: 0,
-        totalCourses: 0,
+      await this.syncHelper.handleSyncError(
+        syncLog.id,
+        error,
+        startTime,
         triggeredBy,
-      });
-
-      this.logger.error(
-        'MEC sync failed',
-        error instanceof Error ? error.stack : undefined,
-        'MecSync',
       );
-
       throw error;
     } finally {
-      // Always release the lock
       await this.cache.releaseLock(MEC_CACHE_KEYS.SYNC_LOCK);
     }
   }
 
-  /**
-   * Sync institutions with idempotent inserts
-   */
-  private async syncInstitutions(
-    institutions: NormalizedInstitution[],
-  ): Promise<{ inserted: number; updated: number }> {
-    this.logger.log(`Syncing ${institutions.length} institutions...`, 'MecSync');
-
-    // Get existing institution codes
-    const existingCodes = await this.prisma.mecInstitution.findMany({
-      select: { codigoIes: true },
-    });
-    const existingSet = new Set(existingCodes.map((i) => i.codigoIes));
-
-    // Filter only new institutions
-    const newInstitutions = institutions.filter((i) => !existingSet.has(i.codigoIes));
-
-    if (newInstitutions.length === 0) {
-      this.logger.log('No new institutions to insert', 'MecSync');
-      return { inserted: 0, updated: 0 };
-    }
-
-    // Batch insert new institutions
-    let inserted = 0;
-    for (let i = 0; i < newInstitutions.length; i += BATCH_SIZE) {
-      const batch = newInstitutions.slice(i, i + BATCH_SIZE);
-
-      await this.prisma.mecInstitution.createMany({
-        data: batch.map((inst) => ({
-          codigoIes: inst.codigoIes,
-          nome: inst.nome,
-          sigla: inst.sigla,
-          organizacao: inst.organizacao,
-          categoria: inst.categoria,
-          uf: inst.uf,
-          municipio: inst.municipio,
-          codigoMunicipio: inst.codigoMunicipio,
-        })),
-        skipDuplicates: true, // Extra safety for race conditions
-      });
-
-      inserted += batch.length;
-
-      if (i % (BATCH_SIZE * 10) === 0 && i > 0) {
-        this.logger.log(`Inserted ${inserted}/${newInstitutions.length} institutions`, 'MecSync');
-      }
-    }
-
-    this.logger.log(`Inserted ${inserted} new institutions`, 'MecSync');
-    return { inserted, updated: 0 };
-  }
-
-  /**
-   * Sync courses with idempotent inserts
-   */
-  private async syncCourses(
-    courses: NormalizedCourse[],
-  ): Promise<{ inserted: number; updated: number }> {
-    this.logger.log(`Syncing ${courses.length} courses...`, 'MecSync');
-
-    // Get existing course codes
-    const existingCodes = await this.prisma.mecCourse.findMany({
-      select: { codigoCurso: true },
-    });
-    const existingSet = new Set(existingCodes.map((c) => c.codigoCurso));
-
-    // Get valid institution codes (courses must reference existing institutions)
-    const validIesCodes = await this.prisma.mecInstitution.findMany({
-      select: { codigoIes: true },
-    });
-    const validIesSet = new Set(validIesCodes.map((i) => i.codigoIes));
-
-    // Filter only new courses with valid institution references
-    const newCourses = courses.filter(
-      (c) => !existingSet.has(c.codigoCurso) && validIesSet.has(c.codigoIes),
+  private async acquireLock(): Promise<void> {
+    const lockAcquired = await this.cache.acquireLock(
+      MEC_CACHE_KEYS.SYNC_LOCK,
+      MEC_CACHE_TTL.SYNC_LOCK,
     );
 
-    if (newCourses.length === 0) {
-      this.logger.log('No new courses to insert', 'MecSync');
-      return { inserted: 0, updated: 0 };
-    }
-
-    // Batch insert new courses
-    let inserted = 0;
-    for (let i = 0; i < newCourses.length; i += BATCH_SIZE) {
-      const batch = newCourses.slice(i, i + BATCH_SIZE);
-
-      await this.prisma.mecCourse.createMany({
-        data: batch.map((course) => ({
-          codigoCurso: course.codigoCurso,
-          codigoIes: course.codigoIes,
-          nome: course.nome,
-          grau: course.grau,
-          modalidade: course.modalidade,
-          areaConhecimento: course.areaConhecimento,
-          cargaHoraria: course.cargaHoraria,
-          situacao: course.situacao,
-        })),
-        skipDuplicates: true, // Extra safety for race conditions
-      });
-
-      inserted += batch.length;
-
-      if (i % (BATCH_SIZE * 10) === 0 && i > 0) {
-        this.logger.log(`Inserted ${inserted}/${newCourses.length} courses`, 'MecSync');
-      }
+    if (!lockAcquired) {
+      throw new Error(
+        'Sync already in progress. Please wait for the current sync to complete.',
+      );
     }
-
-    this.logger.log(`Inserted ${inserted} new courses`, 'MecSync');
-    return { inserted, updated: 0 };
   }
 
-  /**
-   * Invalidate all MEC-related caches after sync
-   */
-  private async invalidateCaches(): Promise<void> {
-    this.logger.log('Invalidating MEC caches...', 'MecSync');
-
-    await Promise.all([
-      this.cache.delete(MEC_CACHE_KEYS.INSTITUTIONS_LIST),
-      this.cache.deletePattern(`${MEC_CACHE_KEYS.INSTITUTIONS_BY_UF}*`),
-      this.cache.deletePattern(`${MEC_CACHE_KEYS.COURSES_BY_IES}*`),
-      this.cache.deletePattern(`${MEC_CACHE_KEYS.COURSES_SEARCH}*`),
-    ]);
+  private async performSync(parseResult: ParseResult): Promise<SyncResult> {
+    const institutionResult = await this.dataSync.syncInstitutions(parseResult);
+    const courseResult = await this.dataSync.syncCourses(parseResult);
 
-    this.logger.log('MEC caches invalidated', 'MecSync');
-  }
+    await this.dataSync.invalidateCaches();
 
-  /**
-   * Update sync metadata in Redis
-   */
-  private async updateSyncMetadata(metadata: SyncMetadata): Promise<void> {
-    await this.cache.set(MEC_CACHE_KEYS.SYNC_METADATA, metadata, MEC_CACHE_TTL.METADATA);
+    return {
+      institutionsInserted: institutionResult.inserted,
+      institutionsUpdated: institutionResult.updated,
+      coursesInserted: courseResult.inserted,
+      coursesUpdated: courseResult.updated,
+      totalRowsProcessed: parseResult.totalRows,
+      errors: parseResult.errors,
+    };
   }
 
-  /**
-   * Get sync metadata from Redis
-   */
+  // Status methods
   async getSyncMetadata(): Promise<SyncMetadata | null> {
     return this.cache.get<SyncMetadata>(MEC_CACHE_KEYS.SYNC_METADATA);
   }
 
-  /**
-   * Check if sync is currently running
-   */
   async isSyncRunning(): Promise<boolean> {
     return this.cache.isLocked(MEC_CACHE_KEYS.SYNC_LOCK);
   }
 
-  /**
-   * Get last sync log from database
-   */
   async getLastSyncLog() {
-    return this.prisma.mecSyncLog.findFirst({
-      orderBy: { createdAt: 'desc' },
-    });
+    return this.syncLogRepo.findLast();
   }
 
-  /**
-   * Get sync history
-   */
-  async getSyncHistory(limit = 10) {
-    return this.prisma.mecSyncLog.findMany({
-      orderBy: { createdAt: 'desc' },
-      take: limit,
-    });
+  async getSyncHistory(
+    limit: number = APP_CONSTANTS.SEARCH_AUTOCOMPLETE_LIMIT,
+  ) {
+    return this.syncLogRepo.findHistory(limit);
   }
 }
diff --git a/src/mec-sync/services/sync-helper.service.ts b/src/mec-sync/services/sync-helper.service.ts
new file mode 100644
index 0000000..01ef233
--- /dev/null
+++ b/src/mec-sync/services/sync-helper.service.ts
@@ -0,0 +1,113 @@
+/**
+ * MEC Sync Helper Service
+ * Handles sync finalization, error handling, and metadata updates
+ */
+
+import { Injectable } from '@nestjs/common';
+import { CacheService } from '../../common/cache/cache.service';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { SyncLogRepository } from '../repositories';
+import {
+  SyncMetadata,
+  MEC_CACHE_KEYS,
+  MEC_CACHE_TTL,
+} from '../interfaces/mec-data.interface';
+
+@Injectable()
+export class SyncHelperService {
+  private readonly context = 'MecSync';
+
+  constructor(
+    private readonly cache: CacheService,
+    private readonly logger: AppLoggerService,
+    private readonly syncLogRepo: SyncLogRepository,
+  ) {}
+
+  async finalizeSyncSuccess(
+    syncLogId: string,
+    stats: SyncSuccessStats,
+    startTime: number,
+    triggeredBy: string,
+  ): Promise<void> {
+    const duration = Date.now() - startTime;
+
+    await this.syncLogRepo.markSuccess(syncLogId, {
+      institutionsInserted: stats.institutionsInserted,
+      institutionsUpdated: stats.institutionsUpdated,
+      coursesInserted: stats.coursesInserted,
+      coursesUpdated: stats.coursesUpdated,
+      totalRowsProcessed: stats.totalRowsProcessed,
+      sourceFileSize: stats.sourceFileSize,
+    });
+
+    await this.updateSyncMetadata({
+      lastSyncAt: new Date().toISOString(),
+      lastSyncStatus: 'success',
+      lastSyncDuration: duration,
+      totalInstitutions: stats.institutionCount,
+      totalCourses: stats.courseCount,
+      triggeredBy,
+    });
+  }
+
+  async handleSyncError(
+    syncLogId: string,
+    error: unknown,
+    startTime: number,
+    triggeredBy: string,
+  ): Promise<void> {
+    const errorMessage = this.extractErrorMessage(error);
+    const errorStack = error instanceof Error ? error.stack : undefined;
+
+    await this.syncLogRepo.markFailed(syncLogId, {
+      errorMessage,
+      errorDetails: errorStack ? { stack: errorStack } : undefined,
+    });
+
+    await this.updateSyncMetadata({
+      lastSyncAt: new Date().toISOString(),
+      lastSyncStatus: 'failed',
+      lastSyncDuration: Date.now() - startTime,
+      totalInstitutions: 0,
+      totalCourses: 0,
+      triggeredBy,
+    });
+
+    this.logger.error('MEC sync failed', errorStack, this.context);
+  }
+
+  async updateSyncMetadata(metadata: SyncMetadata): Promise<void> {
+    await this.cache.set(
+      MEC_CACHE_KEYS.SYNC_METADATA,
+      metadata,
+      MEC_CACHE_TTL.METADATA,
+    );
+  }
+
+  logSyncCompletion(
+    institutionsInserted: number,
+    coursesInserted: number,
+    startTime: number,
+  ): void {
+    const duration = ((Date.now() - startTime) / 1000).toFixed(2);
+    this.logger.log(
+      `MEC sync completed in ${duration}s: ${institutionsInserted} new institutions, ${coursesInserted} new courses`,
+      this.context,
+    );
+  }
+
+  private extractErrorMessage(error: unknown): string {
+    return error instanceof Error ? error.message : 'Unknown error';
+  }
+}
+
+export interface SyncSuccessStats {
+  institutionsInserted: number;
+  institutionsUpdated: number;
+  coursesInserted: number;
+  coursesUpdated: number;
+  totalRowsProcessed: number;
+  sourceFileSize: number;
+  institutionCount: number;
+  courseCount: number;
+}
diff --git a/src/onboarding/dto/additional-profile.dto.ts b/src/onboarding/dto/additional-profile.dto.ts
new file mode 100644
index 0000000..f9fc7cb
--- /dev/null
+++ b/src/onboarding/dto/additional-profile.dto.ts
@@ -0,0 +1,50 @@
+/**
+ * Additional Profile DTOs
+ * DTOs for languages, projects, certifications, awards, and interests
+ */
+
+import { IsString, MinLength, MaxLength } from 'class-validator';
+import { ApiProperty } from '@nestjs/swagger';
+
+export class LanguageDto {
+  @ApiProperty({ example: 'English' })
+  @IsString()
+  @MinLength(1)
+  @MaxLength(50)
+  name: string;
+
+  @ApiProperty({ example: 'Fluent' })
+  @IsString()
+  level: string;
+}
+
+export class ProjectDto {
+  name: string;
+  description?: string;
+  url?: string;
+  startDate?: string;
+  endDate?: string;
+  isCurrent: boolean;
+  technologies?: string[];
+}
+
+export class CertificationDto {
+  name: string;
+  issuer: string;
+  issueDate: string;
+  expiryDate?: string;
+  credentialId?: string;
+  credentialUrl?: string;
+}
+
+export class AwardDto {
+  title: string;
+  issuer: string;
+  date: string;
+  description?: string;
+}
+
+export class InterestDto {
+  name: string;
+  description?: string;
+}
diff --git a/src/onboarding/dto/education.dto.ts b/src/onboarding/dto/education.dto.ts
new file mode 100644
index 0000000..e592ed8
--- /dev/null
+++ b/src/onboarding/dto/education.dto.ts
@@ -0,0 +1,63 @@
+/**
+ * Education DTOs
+ * DTOs for education step
+ */
+
+import {
+  IsString,
+  IsOptional,
+  IsBoolean,
+  IsDateString,
+  IsArray,
+  ValidateNested,
+  MinLength,
+  MaxLength,
+} from 'class-validator';
+import { Type } from 'class-transformer';
+import { ApiProperty } from '@nestjs/swagger';
+
+export class EducationDto {
+  @ApiProperty({ example: 'MIT' })
+  @IsString()
+  @MinLength(1)
+  @MaxLength(200)
+  institution: string;
+
+  @ApiProperty({ example: "Bachelor's" })
+  @IsString()
+  @MinLength(1)
+  @MaxLength(100)
+  degree: string;
+
+  @ApiProperty({ example: 'Computer Science' })
+  @IsString()
+  @MinLength(1)
+  @MaxLength(100)
+  field: string;
+
+  @ApiProperty({ example: '2015-09-01' })
+  @IsDateString()
+  startDate: string;
+
+  @ApiProperty({ example: '2019-05-31', required: false })
+  @IsOptional()
+  @IsDateString()
+  endDate?: string;
+
+  @ApiProperty({ example: false })
+  @IsBoolean()
+  isCurrent: boolean;
+}
+
+export class EducationStepDto {
+  @ApiProperty({ type: [EducationDto], required: false })
+  @IsOptional()
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => EducationDto)
+  education?: EducationDto[];
+
+  @ApiProperty({ example: false })
+  @IsBoolean()
+  noEducation: boolean;
+}
diff --git a/src/onboarding/dto/experience.dto.ts b/src/onboarding/dto/experience.dto.ts
new file mode 100644
index 0000000..b30b011
--- /dev/null
+++ b/src/onboarding/dto/experience.dto.ts
@@ -0,0 +1,71 @@
+/**
+ * Experience DTOs
+ * DTOs for work experience step
+ */
+
+import {
+  IsString,
+  IsOptional,
+  IsBoolean,
+  IsDateString,
+  IsArray,
+  ValidateNested,
+  MinLength,
+  MaxLength,
+} from 'class-validator';
+import { Type } from 'class-transformer';
+import { ApiProperty } from '@nestjs/swagger';
+
+export class ExperienceDto {
+  @ApiProperty({ example: 'Google' })
+  @IsString()
+  @MinLength(1)
+  @MaxLength(100)
+  company: string;
+
+  @ApiProperty({ example: 'Senior Engineer' })
+  @IsString()
+  @MinLength(1)
+  @MaxLength(100)
+  position: string;
+
+  @ApiProperty({ example: '2020-01-15' })
+  @IsDateString()
+  startDate: string;
+
+  @ApiProperty({ example: '2023-12-31', required: false })
+  @IsOptional()
+  @IsDateString()
+  endDate?: string;
+
+  @ApiProperty({ example: true })
+  @IsBoolean()
+  isCurrent: boolean;
+
+  @ApiProperty({
+    example: 'Developed scalable microservices...',
+    required: false,
+  })
+  @IsOptional()
+  @IsString()
+  @MaxLength(2000)
+  description?: string;
+
+  @ApiProperty({ example: 'Mountain View, CA', required: false })
+  @IsOptional()
+  @IsString()
+  location?: string;
+}
+
+export class ExperiencesStepDto {
+  @ApiProperty({ type: [ExperienceDto], required: false })
+  @IsOptional()
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => ExperienceDto)
+  experiences?: ExperienceDto[];
+
+  @ApiProperty({ example: false })
+  @IsBoolean()
+  noExperience: boolean;
+}
diff --git a/src/onboarding/dto/onboarding-progress.dto.ts b/src/onboarding/dto/onboarding-progress.dto.ts
new file mode 100644
index 0000000..e990662
--- /dev/null
+++ b/src/onboarding/dto/onboarding-progress.dto.ts
@@ -0,0 +1,97 @@
+/**
+ * Onboarding Progress DTO
+ * DTO for saving partial onboarding progress
+ */
+
+import {
+  IsString,
+  IsOptional,
+  IsBoolean,
+  IsArray,
+  IsObject,
+  MinLength,
+  MaxLength,
+} from 'class-validator';
+import { ApiProperty } from '@nestjs/swagger';
+import type {
+  PartialPersonalInfo,
+  PartialProfessionalProfile,
+  PartialExperience,
+  PartialEducation,
+  PartialSkill,
+  PartialLanguage,
+  PartialTemplateSelection,
+} from './progress-data.types';
+
+export class OnboardingProgressDto {
+  @ApiProperty({
+    example: 'personal-info',
+    enum: [
+      'welcome',
+      'personal-info',
+      'username',
+      'professional-profile',
+      'experience',
+      'education',
+      'skills',
+      'languages',
+      'template',
+      'review',
+      'complete',
+    ],
+  })
+  @IsString()
+  currentStep: string;
+
+  @ApiProperty({ example: ['welcome', 'personal-info'] })
+  @IsArray()
+  @IsString({ each: true })
+  completedSteps: string[];
+
+  @ApiProperty({ example: 'johndoe', required: false })
+  @IsOptional()
+  @IsString()
+  @MinLength(3)
+  @MaxLength(30)
+  username?: string;
+
+  @IsOptional()
+  @IsObject()
+  personalInfo?: PartialPersonalInfo;
+
+  @IsOptional()
+  @IsObject()
+  professionalProfile?: PartialProfessionalProfile;
+
+  @IsOptional()
+  @IsArray()
+  experiences?: PartialExperience[];
+
+  @IsOptional()
+  @IsBoolean()
+  noExperience?: boolean;
+
+  @IsOptional()
+  @IsArray()
+  education?: PartialEducation[];
+
+  @IsOptional()
+  @IsBoolean()
+  noEducation?: boolean;
+
+  @IsOptional()
+  @IsArray()
+  skills?: PartialSkill[];
+
+  @IsOptional()
+  @IsBoolean()
+  noSkills?: boolean;
+
+  @IsOptional()
+  @IsArray()
+  languages?: PartialLanguage[];
+
+  @IsOptional()
+  @IsObject()
+  templateSelection?: PartialTemplateSelection;
+}
diff --git a/src/onboarding/dto/onboarding.dto.ts b/src/onboarding/dto/onboarding.dto.ts
index 6d95912..3904506 100644
--- a/src/onboarding/dto/onboarding.dto.ts
+++ b/src/onboarding/dto/onboarding.dto.ts
@@ -1,269 +1,56 @@
+/**
+ * Main Onboarding DTO
+ * Complete DTO for onboarding submission
+ */
+
 import {
   IsObject,
   ValidateNested,
   IsOptional,
   IsArray,
   IsString,
-  IsEmail,
   MinLength,
   MaxLength,
-  IsBoolean,
-  IsNumber,
-  Min,
-  Max,
-  IsUrl,
-  IsDateString,
 } from 'class-validator';
 import { Type } from 'class-transformer';
 import { ApiProperty } from '@nestjs/swagger';
 
-class PersonalInfoDto {
-  @ApiProperty({ example: 'John Doe' })
-  @IsString()
-  @MinLength(2)
-  @MaxLength(100)
-  fullName: string;
-
-  @ApiProperty({ example: 'john@example.com' })
-  @IsEmail()
-  email: string;
-
-  @ApiProperty({ example: '+1234567890', required: false })
-  @IsOptional()
-  @IsString()
-  phone?: string;
-
-  @ApiProperty({ example: 'São Paulo, BR', required: false })
-  @IsOptional()
-  @IsString()
-  location?: string;
-}
-
-class ProfessionalProfileDto {
-  @ApiProperty({ example: 'Senior Software Engineer' })
-  @IsString()
-  @MinLength(2)
-  @MaxLength(100)
-  jobTitle: string;
-
-  @ApiProperty({ example: 'Experienced full-stack developer with 5+ years...' })
-  @IsString()
-  @MinLength(10)
-  @MaxLength(2000)
-  summary: string;
-
-  @ApiProperty({ example: 'https://linkedin.com/in/johndoe', required: false })
-  @IsOptional()
-  @IsUrl()
-  linkedin?: string;
-
-  @ApiProperty({ example: 'https://github.com/johndoe', required: false })
-  @IsOptional()
-  @IsUrl()
-  github?: string;
-
-  @ApiProperty({ example: 'https://johndoe.dev', required: false })
-  @IsOptional()
-  @IsUrl()
-  website?: string;
-}
-
-class ExperienceDto {
-  @ApiProperty({ example: 'Google' })
-  @IsString()
-  @MinLength(1)
-  @MaxLength(100)
-  company: string;
-
-  @ApiProperty({ example: 'Senior Engineer' })
-  @IsString()
-  @MinLength(1)
-  @MaxLength(100)
-  position: string;
-
-  @ApiProperty({ example: '2020-01-15' })
-  @IsDateString()
-  startDate: string;
-
-  @ApiProperty({ example: '2023-12-31', required: false })
-  @IsOptional()
-  @IsDateString()
-  endDate?: string;
-
-  @ApiProperty({ example: true })
-  @IsBoolean()
-  isCurrent: boolean;
-
-  @ApiProperty({
-    example: 'Developed scalable microservices...',
-    required: false,
-  })
-  @IsOptional()
-  @IsString()
-  @MaxLength(2000)
-  description?: string;
-
-  @ApiProperty({ example: 'Mountain View, CA', required: false })
-  @IsOptional()
-  @IsString()
-  location?: string;
-}
-
-class ExperiencesStepDto {
-  @ApiProperty({ type: [ExperienceDto], required: false })
-  @IsOptional()
-  @IsArray()
-  @ValidateNested({ each: true })
-  @Type(() => ExperienceDto)
-  experiences?: ExperienceDto[];
-
-  @ApiProperty({ example: false })
-  @IsBoolean()
-  noExperience: boolean;
-}
-
-class EducationDto {
-  @ApiProperty({ example: 'MIT' })
-  @IsString()
-  @MinLength(1)
-  @MaxLength(200)
-  institution: string;
-
-  @ApiProperty({ example: "Bachelor's" })
-  @IsString()
-  @MinLength(1)
-  @MaxLength(100)
-  degree: string;
-
-  @ApiProperty({ example: 'Computer Science' })
-  @IsString()
-  @MinLength(1)
-  @MaxLength(100)
-  field: string;
-
-  @ApiProperty({ example: '2015-09-01' })
-  @IsDateString()
-  startDate: string;
-
-  @ApiProperty({ example: '2019-05-31', required: false })
-  @IsOptional()
-  @IsDateString()
-  endDate?: string;
-
-  @ApiProperty({ example: false })
-  @IsBoolean()
-  isCurrent: boolean;
-}
-
-class EducationStepDto {
-  @ApiProperty({ type: [EducationDto], required: false })
-  @IsOptional()
-  @IsArray()
-  @ValidateNested({ each: true })
-  @Type(() => EducationDto)
-  education?: EducationDto[];
-
-  @ApiProperty({ example: false })
-  @IsBoolean()
-  noEducation: boolean;
-}
-
-class SkillDto {
-  @ApiProperty({ example: 'JavaScript' })
-  @IsString()
-  @MinLength(1)
-  @MaxLength(50)
-  name: string;
-
-  @ApiProperty({ example: 'Programming Languages' })
-  @IsString()
-  @MinLength(1)
-  @MaxLength(50)
-  category: string;
-
-  @ApiProperty({ example: 4, minimum: 1, maximum: 5, required: false })
-  @IsOptional()
-  @IsNumber()
-  @Min(1)
-  @Max(5)
-  level?: number;
-}
-
-class SkillsStepDto {
-  @ApiProperty({ type: [SkillDto], required: false })
-  @IsOptional()
-  @IsArray()
-  @ValidateNested({ each: true })
-  @Type(() => SkillDto)
-  skills?: SkillDto[];
-
-  @ApiProperty({ example: false })
-  @IsBoolean()
-  noSkills: boolean;
-}
-
-class LanguageDto {
-  @ApiProperty({ example: 'English' })
-  @IsString()
-  @MinLength(1)
-  @MaxLength(50)
-  name: string;
-
-  @ApiProperty({ example: 'Fluent' })
-  @IsString()
-  level: string;
-}
-
-class ProjectDto {
-  name: string;
-  description?: string;
-  url?: string;
-  startDate?: string;
-  endDate?: string;
-  isCurrent: boolean;
-  technologies?: string[];
-}
-
-class CertificationDto {
-  name: string;
-  issuer: string;
-  issueDate: string;
-  expiryDate?: string;
-  credentialId?: string;
-  credentialUrl?: string;
-}
-
-class AwardDto {
-  title: string;
-  issuer: string;
-  date: string;
-  description?: string;
-}
-
-class InterestDto {
-  name: string;
-  description?: string;
-}
-
-class TemplateSelectionDto {
-  @ApiProperty({
-    example: 'professional',
-    enum: ['professional', 'creative', 'minimal', 'modern'],
-  })
-  @IsString()
-  template: string;
+import { PersonalInfoDto } from './personal-info.dto';
+import { ProfessionalProfileDto } from './professional-profile.dto';
+import { ExperiencesStepDto } from './experience.dto';
+import { EducationStepDto } from './education.dto';
+import { SkillsStepDto } from './skills.dto';
+import {
+  LanguageDto,
+  ProjectDto,
+  CertificationDto,
+  AwardDto,
+  InterestDto,
+} from './additional-profile.dto';
+import { TemplateSelectionDto } from './template-selection.dto';
+
+// Re-export all DTOs for backward compatibility
+export { PersonalInfoDto } from './personal-info.dto';
+export { ProfessionalProfileDto } from './professional-profile.dto';
+export { ExperienceDto, ExperiencesStepDto } from './experience.dto';
+export { EducationDto, EducationStepDto } from './education.dto';
+export { SkillDto, SkillsStepDto } from './skills.dto';
+export {
+  LanguageDto,
+  ProjectDto,
+  CertificationDto,
+  AwardDto,
+  InterestDto,
+} from './additional-profile.dto';
+export { TemplateSelectionDto } from './template-selection.dto';
+export { OnboardingProgressDto } from './onboarding-progress.dto';
 
+export class OnboardingDto {
   @ApiProperty({
-    example: 'ocean',
-    enum: ['ocean', 'sunset', 'forest', 'lavender', 'rose', 'monochrome'],
+    example: 'johndoe',
+    description: 'Unique username for profile URL',
   })
   @IsString()
-  palette: string;
-}
-
-export class OnboardingDto {
-  @ApiProperty({ example: 'johndoe', description: 'Unique username for profile URL' })
-  @IsString()
   @MinLength(3)
   @MaxLength(30)
   username: string;
@@ -330,127 +117,3 @@ export class OnboardingDto {
   @Type(() => TemplateSelectionDto)
   templateSelection: TemplateSelectionDto;
 }
-
-// DTO for saving onboarding progress (partial data)
-export class OnboardingProgressDto {
-  @ApiProperty({
-    example: 'personal-info',
-    enum: [
-      'welcome',
-      'personal-info',
-      'username',
-      'professional-profile',
-      'experience',
-      'education',
-      'skills',
-      'languages',
-      'template',
-      'review',
-      'complete',
-    ],
-  })
-  @IsString()
-  currentStep: string;
-
-  @ApiProperty({ example: ['welcome', 'personal-info'] })
-  @IsArray()
-  @IsString({ each: true })
-  completedSteps: string[];
-
-  @ApiProperty({ example: 'johndoe', required: false })
-  @IsOptional()
-  @IsString()
-  @MinLength(3)
-  @MaxLength(30)
-  username?: string;
-
-  @ApiProperty({ required: false })
-  @IsOptional()
-  @IsObject()
-  personalInfo?: {
-    fullName?: string;
-    email?: string;
-    phone?: string;
-    location?: string;
-  };
-
-  @ApiProperty({ required: false })
-  @IsOptional()
-  @IsObject()
-  professionalProfile?: {
-    jobTitle?: string;
-    summary?: string;
-    linkedin?: string;
-    github?: string;
-    website?: string;
-  };
-
-  @ApiProperty({ required: false })
-  @IsOptional()
-  @IsArray()
-  experiences?: Array<{
-    id?: string;
-    company?: string;
-    position?: string;
-    startDate?: string;
-    endDate?: string;
-    isCurrent?: boolean;
-    description?: string;
-    location?: string;
-  }>;
-
-  @ApiProperty({ example: false })
-  @IsOptional()
-  @IsBoolean()
-  noExperience?: boolean;
-
-  @ApiProperty({ required: false })
-  @IsOptional()
-  @IsArray()
-  education?: Array<{
-    id?: string;
-    institution?: string;
-    degree?: string;
-    field?: string;
-    startDate?: string;
-    endDate?: string;
-    isCurrent?: boolean;
-  }>;
-
-  @ApiProperty({ example: false })
-  @IsOptional()
-  @IsBoolean()
-  noEducation?: boolean;
-
-  @ApiProperty({ required: false })
-  @IsOptional()
-  @IsArray()
-  skills?: Array<{
-    id?: string;
-    name?: string;
-    category?: string;
-    level?: number;
-  }>;
-
-  @ApiProperty({ example: false })
-  @IsOptional()
-  @IsBoolean()
-  noSkills?: boolean;
-
-  @ApiProperty({ required: false })
-  @IsOptional()
-  @IsArray()
-  languages?: Array<{
-    id?: string;
-    name?: string;
-    level?: string;
-  }>;
-
-  @ApiProperty({ required: false })
-  @IsOptional()
-  @IsObject()
-  templateSelection?: {
-    template?: string;
-    palette?: string;
-  };
-}
diff --git a/src/onboarding/dto/personal-info.dto.ts b/src/onboarding/dto/personal-info.dto.ts
new file mode 100644
index 0000000..9455ce4
--- /dev/null
+++ b/src/onboarding/dto/personal-info.dto.ts
@@ -0,0 +1,35 @@
+/**
+ * Personal Info DTOs
+ * DTOs for personal information step
+ */
+
+import {
+  IsString,
+  IsEmail,
+  IsOptional,
+  MinLength,
+  MaxLength,
+} from 'class-validator';
+import { ApiProperty } from '@nestjs/swagger';
+
+export class PersonalInfoDto {
+  @ApiProperty({ example: 'John Doe' })
+  @IsString()
+  @MinLength(2)
+  @MaxLength(100)
+  fullName: string;
+
+  @ApiProperty({ example: 'john@example.com' })
+  @IsEmail()
+  email: string;
+
+  @ApiProperty({ example: '+1234567890', required: false })
+  @IsOptional()
+  @IsString()
+  phone?: string;
+
+  @ApiProperty({ example: 'São Paulo, BR', required: false })
+  @IsOptional()
+  @IsString()
+  location?: string;
+}
diff --git a/src/onboarding/dto/professional-profile.dto.ts b/src/onboarding/dto/professional-profile.dto.ts
new file mode 100644
index 0000000..5cd98e1
--- /dev/null
+++ b/src/onboarding/dto/professional-profile.dto.ts
@@ -0,0 +1,42 @@
+/**
+ * Professional Profile DTOs
+ * DTOs for professional profile step
+ */
+
+import {
+  IsString,
+  IsOptional,
+  IsUrl,
+  MinLength,
+  MaxLength,
+} from 'class-validator';
+import { ApiProperty } from '@nestjs/swagger';
+
+export class ProfessionalProfileDto {
+  @ApiProperty({ example: 'Senior Software Engineer' })
+  @IsString()
+  @MinLength(2)
+  @MaxLength(100)
+  jobTitle: string;
+
+  @ApiProperty({ example: 'Experienced full-stack developer with 5+ years...' })
+  @IsString()
+  @MinLength(10)
+  @MaxLength(2000)
+  summary: string;
+
+  @ApiProperty({ example: 'https://linkedin.com/in/johndoe', required: false })
+  @IsOptional()
+  @IsUrl()
+  linkedin?: string;
+
+  @ApiProperty({ example: 'https://github.com/johndoe', required: false })
+  @IsOptional()
+  @IsUrl()
+  github?: string;
+
+  @ApiProperty({ example: 'https://johndoe.dev', required: false })
+  @IsOptional()
+  @IsUrl()
+  website?: string;
+}
diff --git a/src/onboarding/dto/progress-data.types.ts b/src/onboarding/dto/progress-data.types.ts
new file mode 100644
index 0000000..7500030
--- /dev/null
+++ b/src/onboarding/dto/progress-data.types.ts
@@ -0,0 +1,61 @@
+/**
+ * Progress Data Types
+ * Partial data types for onboarding progress tracking
+ * These types are designed to be JSON-compatible for Prisma storage
+ */
+
+import type { Prisma } from '@prisma/client';
+
+export type PartialPersonalInfo = Prisma.InputJsonValue & {
+  fullName?: string;
+  email?: string;
+  phone?: string;
+  location?: string;
+};
+
+export type PartialProfessionalProfile = Prisma.InputJsonValue & {
+  jobTitle?: string;
+  summary?: string;
+  linkedin?: string;
+  github?: string;
+  website?: string;
+};
+
+export type PartialExperience = Prisma.InputJsonValue & {
+  id?: string;
+  company?: string;
+  position?: string;
+  startDate?: string;
+  endDate?: string;
+  isCurrent?: boolean;
+  description?: string;
+  location?: string;
+};
+
+export type PartialEducation = Prisma.InputJsonValue & {
+  id?: string;
+  institution?: string;
+  degree?: string;
+  field?: string;
+  startDate?: string;
+  endDate?: string;
+  isCurrent?: boolean;
+};
+
+export type PartialSkill = Prisma.InputJsonValue & {
+  id?: string;
+  name?: string;
+  category?: string;
+  level?: number;
+};
+
+export type PartialLanguage = Prisma.InputJsonValue & {
+  id?: string;
+  name?: string;
+  level?: string;
+};
+
+export type PartialTemplateSelection = Prisma.InputJsonValue & {
+  template?: string;
+  palette?: string;
+};
diff --git a/src/onboarding/dto/skills.dto.ts b/src/onboarding/dto/skills.dto.ts
new file mode 100644
index 0000000..967f7a0
--- /dev/null
+++ b/src/onboarding/dto/skills.dto.ts
@@ -0,0 +1,53 @@
+/**
+ * Skills DTOs
+ * DTOs for skills step
+ */
+
+import {
+  IsString,
+  IsOptional,
+  IsBoolean,
+  IsNumber,
+  IsArray,
+  ValidateNested,
+  MinLength,
+  MaxLength,
+  Min,
+  Max,
+} from 'class-validator';
+import { Type } from 'class-transformer';
+import { ApiProperty } from '@nestjs/swagger';
+
+export class SkillDto {
+  @ApiProperty({ example: 'JavaScript' })
+  @IsString()
+  @MinLength(1)
+  @MaxLength(50)
+  name: string;
+
+  @ApiProperty({ example: 'Programming Languages' })
+  @IsString()
+  @MinLength(1)
+  @MaxLength(50)
+  category: string;
+
+  @ApiProperty({ example: 4, minimum: 1, maximum: 5, required: false })
+  @IsOptional()
+  @IsNumber()
+  @Min(1)
+  @Max(5)
+  level?: number;
+}
+
+export class SkillsStepDto {
+  @ApiProperty({ type: [SkillDto], required: false })
+  @IsOptional()
+  @IsArray()
+  @ValidateNested({ each: true })
+  @Type(() => SkillDto)
+  skills?: SkillDto[];
+
+  @ApiProperty({ example: false })
+  @IsBoolean()
+  noSkills: boolean;
+}
diff --git a/src/onboarding/dto/template-selection.dto.ts b/src/onboarding/dto/template-selection.dto.ts
new file mode 100644
index 0000000..a0b91b5
--- /dev/null
+++ b/src/onboarding/dto/template-selection.dto.ts
@@ -0,0 +1,23 @@
+/**
+ * Template Selection DTO
+ * DTO for template and color selection step
+ */
+
+import { IsString } from 'class-validator';
+import { ApiProperty } from '@nestjs/swagger';
+
+export class TemplateSelectionDto {
+  @ApiProperty({
+    example: 'professional',
+    enum: ['professional', 'creative', 'minimal', 'modern'],
+  })
+  @IsString()
+  template: string;
+
+  @ApiProperty({
+    example: 'ocean',
+    enum: ['ocean', 'sunset', 'forest', 'lavender', 'rose', 'monochrome'],
+  })
+  @IsString()
+  palette: string;
+}
diff --git a/src/onboarding/onboarding.module.ts b/src/onboarding/onboarding.module.ts
index 1d7e4d6..c23fb03 100644
--- a/src/onboarding/onboarding.module.ts
+++ b/src/onboarding/onboarding.module.ts
@@ -7,17 +7,19 @@ import { SkillsOnboardingService } from './services/skills-onboarding.service';
 import { ExperienceOnboardingService } from './services/experience-onboarding.service';
 import { EducationOnboardingService } from './services/education-onboarding.service';
 import { LanguagesOnboardingService } from './services/languages-onboarding.service';
+import { OnboardingProgressService } from './services/onboarding-progress.service';
 
 @Module({
   imports: [PrismaModule],
   controllers: [OnboardingController],
   providers: [
-    OnboardingService,
     ResumeOnboardingService,
     SkillsOnboardingService,
     ExperienceOnboardingService,
     EducationOnboardingService,
     LanguagesOnboardingService,
+    OnboardingProgressService,
+    OnboardingService,
   ],
   exports: [OnboardingService],
 })
diff --git a/src/onboarding/onboarding.service.spec.ts b/src/onboarding/onboarding.service.spec.ts
index e7d1047..f6dd82c 100644
--- a/src/onboarding/onboarding.service.spec.ts
+++ b/src/onboarding/onboarding.service.spec.ts
@@ -8,6 +8,7 @@ import { SkillsOnboardingService } from './services/skills-onboarding.service';
 import { ExperienceOnboardingService } from './services/experience-onboarding.service';
 import { EducationOnboardingService } from './services/education-onboarding.service';
 import { LanguagesOnboardingService } from './services/languages-onboarding.service';
+import { OnboardingProgressService } from './services/onboarding-progress.service';
 import {
   ERROR_MESSAGES,
   SUCCESS_MESSAGES,
@@ -15,13 +16,7 @@ import {
 
 describe('OnboardingService', () => {
   let service: OnboardingService;
-  let prisma: PrismaService;
   let logger: AppLoggerService;
-  let resumeService: ResumeOnboardingService;
-  let skillsService: SkillsOnboardingService;
-  let experienceService: ExperienceOnboardingService;
-  let educationService: EducationOnboardingService;
-  let languagesService: LanguagesOnboardingService;
 
   const mockPrismaService = {
     user: {
@@ -60,6 +55,12 @@ describe('OnboardingService', () => {
     saveLanguages: jest.fn(),
   };
 
+  const mockOnboardingProgressService = {
+    updateProgress: jest.fn(),
+    markCompleted: jest.fn(),
+    deleteProgress: jest.fn(),
+  };
+
   beforeEach(async () => {
     const module: TestingModule = await Test.createTestingModule({
       providers: [
@@ -92,27 +93,15 @@ describe('OnboardingService', () => {
           provide: LanguagesOnboardingService,
           useValue: mockLanguagesOnboardingService,
         },
+        {
+          provide: OnboardingProgressService,
+          useValue: mockOnboardingProgressService,
+        },
       ],
     }).compile();
 
     service = module.get<OnboardingService>(OnboardingService);
-    prisma = module.get<PrismaService>(PrismaService);
     logger = module.get<AppLoggerService>(AppLoggerService);
-    resumeService = module.get<ResumeOnboardingService>(
-      ResumeOnboardingService,
-    );
-    skillsService = module.get<SkillsOnboardingService>(
-      SkillsOnboardingService,
-    );
-    experienceService = module.get<ExperienceOnboardingService>(
-      ExperienceOnboardingService,
-    );
-    educationService = module.get<EducationOnboardingService>(
-      EducationOnboardingService,
-    );
-    languagesService = module.get<LanguagesOnboardingService>(
-      LanguagesOnboardingService,
-    );
   });
 
   afterEach(() => {
diff --git a/src/onboarding/onboarding.service.ts b/src/onboarding/onboarding.service.ts
index b14eb49..97f3d1c 100644
--- a/src/onboarding/onboarding.service.ts
+++ b/src/onboarding/onboarding.service.ts
@@ -14,6 +14,7 @@ import { SkillsOnboardingService } from './services/skills-onboarding.service';
 import { ExperienceOnboardingService } from './services/experience-onboarding.service';
 import { EducationOnboardingService } from './services/education-onboarding.service';
 import { LanguagesOnboardingService } from './services/languages-onboarding.service';
+import { OnboardingProgressService } from './services/onboarding-progress.service';
 import { OnboardingProgressDto } from './dto/onboarding.dto';
 
 @Injectable()
@@ -26,15 +27,15 @@ export class OnboardingService {
     private readonly experienceService: ExperienceOnboardingService,
     private readonly educationService: EducationOnboardingService,
     private readonly languagesService: LanguagesOnboardingService,
+    private readonly progressService: OnboardingProgressService,
   ) {}
 
-  async completeOnboarding(userId: string, data: any) {
+  async completeOnboarding(userId: string, data: unknown) {
     this.logger.log('Onboarding process started', 'OnboardingService', {
       userId,
     });
 
     const validatedData = onboardingDataSchema.parse(data);
-
     const user = await this.findUser(userId);
     const resume = await this.resumeService.upsertResume(userId, validatedData);
 
@@ -55,9 +56,7 @@ export class OnboardingService {
     ]);
 
     await this.markOnboardingComplete(user.id, validatedData);
-
-    // Clean up progress after successful completion
-    await this.deleteProgress(userId);
+    await this.progressService.deleteProgress(userId);
 
     this.logger.log('Onboarding completed successfully', 'OnboardingService', {
       userId,
@@ -71,6 +70,32 @@ export class OnboardingService {
     };
   }
 
+  async getOnboardingStatus(userId: string) {
+    const user = await this.prisma.user.findUnique({
+      where: { id: userId },
+      select: { hasCompletedOnboarding: true, onboardingCompletedAt: true },
+    });
+
+    if (!user) throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
+
+    return {
+      hasCompletedOnboarding: user.hasCompletedOnboarding,
+      onboardingCompletedAt: user.onboardingCompletedAt,
+    };
+  }
+
+  async saveProgress(userId: string, data: OnboardingProgressDto) {
+    return this.progressService.saveProgress(userId, data);
+  }
+
+  async getProgress(userId: string) {
+    return this.progressService.getProgress(userId);
+  }
+
+  async deleteProgress(userId: string) {
+    return this.progressService.deleteProgress(userId);
+  }
+
   private async findUser(userId: string) {
     const user = await this.prisma.user.findUnique({ where: { id: userId } });
 
@@ -78,9 +103,7 @@ export class OnboardingService {
       this.logger.warn(
         'Onboarding attempted for non-existent user',
         'OnboardingService',
-        {
-          userId,
-        },
+        { userId },
       );
       throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
     }
@@ -99,127 +122,4 @@ export class OnboardingService {
       },
     });
   }
-
-  async getOnboardingStatus(userId: string) {
-    const user = await this.prisma.user.findUnique({
-      where: { id: userId },
-      select: {
-        hasCompletedOnboarding: true,
-        onboardingCompletedAt: true,
-      },
-    });
-
-    if (!user) {
-      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
-    }
-
-    return {
-      hasCompletedOnboarding: user.hasCompletedOnboarding,
-      onboardingCompletedAt: user.onboardingCompletedAt,
-    };
-  }
-
-  /**
-   * Save onboarding progress (checkpoint)
-   */
-  async saveProgress(userId: string, data: OnboardingProgressDto) {
-    this.logger.debug('Saving onboarding progress', 'OnboardingService', {
-      userId,
-      currentStep: data.currentStep,
-    });
-
-    const progress = await this.prisma.onboardingProgress.upsert({
-      where: { userId },
-      update: {
-        currentStep: data.currentStep,
-        completedSteps: data.completedSteps,
-        username: data.username ?? undefined,
-        personalInfo: data.personalInfo ?? undefined,
-        professionalProfile: data.professionalProfile ?? undefined,
-        experiences: data.experiences ?? undefined,
-        noExperience: data.noExperience ?? false,
-        education: data.education ?? undefined,
-        noEducation: data.noEducation ?? false,
-        skills: data.skills ?? undefined,
-        noSkills: data.noSkills ?? false,
-        languages: data.languages ?? undefined,
-        templateSelection: data.templateSelection ?? undefined,
-      },
-      create: {
-        userId,
-        currentStep: data.currentStep,
-        completedSteps: data.completedSteps,
-        username: data.username ?? undefined,
-        personalInfo: data.personalInfo ?? undefined,
-        professionalProfile: data.professionalProfile ?? undefined,
-        experiences: data.experiences ?? undefined,
-        noExperience: data.noExperience ?? false,
-        education: data.education ?? undefined,
-        noEducation: data.noEducation ?? false,
-        skills: data.skills ?? undefined,
-        noSkills: data.noSkills ?? false,
-        languages: data.languages ?? undefined,
-        templateSelection: data.templateSelection ?? undefined,
-      },
-    });
-
-    return {
-      success: true,
-      currentStep: progress.currentStep,
-      completedSteps: progress.completedSteps,
-    };
-  }
-
-  /**
-   * Get onboarding progress (checkpoint)
-   */
-  async getProgress(userId: string) {
-    const progress = await this.prisma.onboardingProgress.findUnique({
-      where: { userId },
-    });
-
-    if (!progress) {
-      // Return initial state if no progress saved
-      return {
-        currentStep: 'welcome',
-        completedSteps: [],
-        username: null,
-        personalInfo: null,
-        professionalProfile: null,
-        experiences: [],
-        noExperience: false,
-        education: [],
-        noEducation: false,
-        skills: [],
-        noSkills: false,
-        languages: [],
-        templateSelection: null,
-      };
-    }
-
-    return {
-      currentStep: progress.currentStep,
-      completedSteps: progress.completedSteps,
-      username: progress.username,
-      personalInfo: progress.personalInfo,
-      professionalProfile: progress.professionalProfile,
-      experiences: progress.experiences ?? [],
-      noExperience: progress.noExperience,
-      education: progress.education ?? [],
-      noEducation: progress.noEducation,
-      skills: progress.skills ?? [],
-      noSkills: progress.noSkills,
-      languages: progress.languages ?? [],
-      templateSelection: progress.templateSelection,
-    };
-  }
-
-  /**
-   * Delete onboarding progress after completion
-   */
-  async deleteProgress(userId: string) {
-    await this.prisma.onboardingProgress.deleteMany({
-      where: { userId },
-    });
-  }
 }
diff --git a/src/onboarding/schemas/onboarding.schema.ts b/src/onboarding/schemas/onboarding.schema.ts
index a44f9e4..48eb46a 100644
--- a/src/onboarding/schemas/onboarding.schema.ts
+++ b/src/onboarding/schemas/onboarding.schema.ts
@@ -1,216 +1,83 @@
 /**
- * Onboarding Types & Validation using Zod
- * Uncle Bob: "Clean code is simple and direct"
+ * Onboarding Schema
+ * Zod validation schemas for onboarding data
  */
 
 import { z } from 'zod';
-import { STRING_LENGTH } from '../../common/constants/validation.constants';
 
-// Step 1: Personal Info (REQUIRED)
-export const personalInfoSchema = z.object({
-  fullName: z
-    .string()
-    .min(2, 'Nome deve ter pelo menos 2 caracteres')
-    .max(STRING_LENGTH.MAX.NAME, 'Nome muito longo'),
-  email: z.string().email('Email inválido'),
+const personalInfoSchema = z.object({
+  fullName: z.string().min(2).max(100),
+  email: z.string().email(),
   phone: z.string().optional(),
   location: z.string().optional(),
 });
 
-export type PersonalInfo = z.infer<typeof personalInfoSchema>;
-
-// Step 2: Professional Profile (REQUIRED)
-export const professionalProfileSchema = z.object({
-  jobTitle: z
-    .string()
-    .min(2, 'Cargo deve ter pelo menos 2 caracteres')
-    .max(STRING_LENGTH.MAX.TITLE, 'Cargo muito longo'),
-  summary: z
-    .string()
-    .min(50, 'Resumo deve ter pelo menos 50 caracteres')
-    .max(STRING_LENGTH.MAX.DESCRIPTION, 'Resumo muito longo'),
-  linkedin: z.string().url('LinkedIn inválido').optional().or(z.literal('')),
-  github: z.string().url('GitHub inválido').optional().or(z.literal('')),
-  website: z.string().url('Website inválido').optional().or(z.literal('')),
+const professionalProfileSchema = z.object({
+  jobTitle: z.string().min(2).max(100),
+  summary: z.string().min(10).max(2000),
+  linkedin: z.string().url().optional().or(z.literal('')),
+  github: z.string().url().optional().or(z.literal('')),
+  website: z.string().url().optional().or(z.literal('')),
 });
 
-export type ProfessionalProfile = z.infer<typeof professionalProfileSchema>;
-
-// Step 3: Experience (OPTIONAL - can have "No experience")
-export const experienceSchema = z.object({
-  company: z.string().min(1, 'Empresa é obrigatória'),
-  position: z.string().min(1, 'Cargo é obrigatório'),
-  startDate: z
-    .string()
-    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Data inicial inválida (use YYYY-MM-DD)'),
-  endDate: z
-    .string()
-    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Data final inválida (use YYYY-MM-DD)')
-    .optional(),
-  isCurrent: z.boolean().default(false),
-  description: z.string().optional(),
+const experienceSchema = z.object({
+  company: z.string().min(1).max(100),
+  position: z.string().min(1).max(100),
+  startDate: z.string(),
+  endDate: z.string().optional(),
+  isCurrent: z.boolean(),
+  description: z.string().max(2000).optional(),
   location: z.string().optional(),
 });
 
-export type Experience = z.infer<typeof experienceSchema>;
-
-export const experiencesStepSchema = z.object({
+const experiencesStepSchema = z.object({
   experiences: z.array(experienceSchema).optional(),
-  noExperience: z.boolean().default(false),
+  noExperience: z.boolean(),
 });
 
-export type ExperiencesStep = z.infer<typeof experiencesStepSchema>;
-
-// Step 4: Education (OPTIONAL - can have "No formal education")
-export const educationSchema = z.object({
-  institution: z.string().min(1, 'Instituição é obrigatória'),
-  degree: z.string().min(1, 'Grau é obrigatório'),
-  field: z.string().min(1, 'Área de estudo é obrigatória'),
-  startDate: z
-    .string()
-    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Data inicial inválida (use YYYY-MM-DD)'),
-  endDate: z
-    .string()
-    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Data final inválida (use YYYY-MM-DD)')
-    .optional(),
-  isCurrent: z.boolean().default(false),
+const educationSchema = z.object({
+  institution: z.string().min(1).max(200),
+  degree: z.string().min(1).max(100),
+  field: z.string().min(1).max(100),
+  startDate: z.string(),
+  endDate: z.string().optional(),
+  isCurrent: z.boolean(),
 });
 
-export type Education = z.infer<typeof educationSchema>;
-
-export const educationStepSchema = z.object({
+const educationStepSchema = z.object({
   education: z.array(educationSchema).optional(),
-  noEducation: z.boolean().default(false),
+  noEducation: z.boolean(),
 });
 
-export type EducationStep = z.infer<typeof educationStepSchema>;
-
-// Step 5: Skills (REQUIRED - but can select "No specific skills")
-export const skillSchema = z.object({
-  name: z.string().min(1, 'Nome da habilidade é obrigatório'),
-  category: z.string().min(1, 'Categoria é obrigatória'),
+const skillSchema = z.object({
+  name: z.string().min(1).max(50),
+  category: z.string().min(1).max(50),
   level: z.number().min(1).max(5).optional(),
 });
 
-export type Skill = z.infer<typeof skillSchema>;
-
-export const skillsStepSchema = z
-  .object({
-    skills: z.array(skillSchema).optional().default([]),
-    noSkills: z.boolean().default(false),
-  })
-  .refine(
-    (data) => {
-      if (data.noSkills) {
-        return true;
-      }
-      return (
-        data.skills &&
-        data.skills.length > 0 &&
-        data.skills.some((skill) => skill.name.trim().length > 0)
-      );
-    },
-    {
-      message:
-        "Adicione pelo menos uma habilidade ou marque 'Ainda estou desenvolvendo minhas habilidades'",
-      path: ['skills'],
-    },
-  );
-
-export type SkillsStep = z.infer<typeof skillsStepSchema>;
-
-// Step 6: Languages (OPTIONAL)
-export const languageSchema = z.object({
-  name: z.string().min(1, 'Nome do idioma é obrigatório'),
-  level: z.enum(['básico', 'intermediário', 'avançado', 'fluente', 'nativo']),
-});
-
-export type Language = z.infer<typeof languageSchema>;
-
-// Step 7: Projects (OPTIONAL)
-export const projectSchema = z.object({
-  name: z.string().min(1, 'Nome do projeto é obrigatório'),
-  description: z.string().optional(),
-  url: z.string().url('URL inválida').optional().or(z.literal('')),
-  startDate: z
-    .string()
-    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Data inicial inválida (use YYYY-MM-DD)')
-    .optional(),
-  endDate: z
-    .string()
-    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Data final inválida (use YYYY-MM-DD)')
-    .optional(),
-  isCurrent: z.boolean().default(false),
-  technologies: z.array(z.string()).optional(),
-});
-
-export type Project = z.infer<typeof projectSchema>;
-
-// Step 8: Certifications (OPTIONAL)
-export const certificationSchema = z.object({
-  name: z.string().min(1, 'Nome da certificação é obrigatório'),
-  issuer: z.string().min(1, 'Emissor é obrigatório'),
-  issueDate: z
-    .string()
-    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Data de emissão inválida (use YYYY-MM-DD)'),
-  expiryDate: z
-    .string()
-    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Data de expiração inválida (use YYYY-MM-DD)')
-    .optional(),
-  credentialId: z.string().optional(),
-  credentialUrl: z.string().url('URL inválida').optional().or(z.literal('')),
+const skillsStepSchema = z.object({
+  skills: z.array(skillSchema).optional(),
+  noSkills: z.boolean(),
 });
 
-export type Certification = z.infer<typeof certificationSchema>;
-
-// Step 9: Awards (OPTIONAL)
-export const awardSchema = z.object({
-  title: z.string().min(1, 'Título do prêmio é obrigatório'),
-  issuer: z.string().min(1, 'Emissor é obrigatório'),
-  date: z
-    .string()
-    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Data inválida (use YYYY-MM-DD)'),
-  description: z.string().optional(),
+const languageSchema = z.object({
+  name: z.string().min(1).max(50),
+  level: z.string(),
 });
 
-export type Award = z.infer<typeof awardSchema>;
-
-// Step 10: Interests (OPTIONAL)
-export const interestSchema = z.object({
-  name: z.string().min(1, 'Nome do interesse é obrigatório'),
-  description: z.string().optional(),
+const templateSelectionSchema = z.object({
+  template: z.string(),
+  palette: z.string(),
 });
 
-export type Interest = z.infer<typeof interestSchema>;
-
-// Step 11: Template Selection (REQUIRED - Professional only for onboarding)
-export const templateSelectionSchema = z.object({
-  template: z.literal('professional'),
-  palette: z.string().min(1, 'Selecione uma paleta de cores'),
-});
-
-export type TemplateSelection = z.infer<typeof templateSelectionSchema>;
-
-// Username schema
-export const usernameSchema = z
-  .string()
-  .min(3, 'Username deve ter pelo menos 3 caracteres')
-  .max(30, 'Username deve ter no máximo 30 caracteres')
-  .regex(/^[a-zA-Z0-9_]+$/, 'Username pode conter apenas letras, números e underscore');
-
-// Complete Onboarding Data
 export const onboardingDataSchema = z.object({
-  username: usernameSchema,
+  username: z.string().min(3).max(30),
   personalInfo: personalInfoSchema,
   professionalProfile: professionalProfileSchema,
   skillsStep: skillsStepSchema,
   experiencesStep: experiencesStepSchema.optional(),
   educationStep: educationStepSchema.optional(),
   languages: z.array(languageSchema).optional(),
-  projects: z.array(projectSchema).optional(),
-  certifications: z.array(certificationSchema).optional(),
-  awards: z.array(awardSchema).optional(),
-  interests: z.array(interestSchema).optional(),
   templateSelection: templateSelectionSchema,
 });
 
diff --git a/src/onboarding/services/education-onboarding.service.ts b/src/onboarding/services/education-onboarding.service.ts
index 288ba6b..86ca2fc 100644
--- a/src/onboarding/services/education-onboarding.service.ts
+++ b/src/onboarding/services/education-onboarding.service.ts
@@ -2,7 +2,6 @@ import { Injectable, Logger } from '@nestjs/common';
 import { PrismaService } from '../../prisma/prisma.service';
 import { OnboardingData } from '../schemas/onboarding.schema';
 import { DateUtils } from '../../common/utils/date.utils';
-import { Prisma } from '@prisma/client';
 
 @Injectable()
 export class EducationOnboardingService {
diff --git a/src/onboarding/services/experience-onboarding.service.ts b/src/onboarding/services/experience-onboarding.service.ts
index f2bb3d1..46a3242 100644
--- a/src/onboarding/services/experience-onboarding.service.ts
+++ b/src/onboarding/services/experience-onboarding.service.ts
@@ -2,7 +2,6 @@ import { Injectable, Logger } from '@nestjs/common';
 import { PrismaService } from '../../prisma/prisma.service';
 import { OnboardingData } from '../schemas/onboarding.schema';
 import { DateUtils } from '../../common/utils/date.utils';
-import { Prisma } from '@prisma/client';
 
 @Injectable()
 export class ExperienceOnboardingService {
diff --git a/src/onboarding/services/onboarding-progress.service.ts b/src/onboarding/services/onboarding-progress.service.ts
new file mode 100644
index 0000000..227107b
--- /dev/null
+++ b/src/onboarding/services/onboarding-progress.service.ts
@@ -0,0 +1,106 @@
+/**
+ * Onboarding Progress Service
+ * Single Responsibility: Manage onboarding progress (checkpoints)
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { OnboardingProgressDto } from '../dto/onboarding.dto';
+
+const INITIAL_PROGRESS = {
+  currentStep: 'welcome',
+  completedSteps: [],
+  username: null,
+  personalInfo: null,
+  professionalProfile: null,
+  experiences: [],
+  noExperience: false,
+  education: [],
+  noEducation: false,
+  skills: [],
+  noSkills: false,
+  languages: [],
+  templateSelection: null,
+};
+
+@Injectable()
+export class OnboardingProgressService {
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly logger: AppLoggerService,
+  ) {}
+
+  async saveProgress(userId: string, data: OnboardingProgressDto) {
+    this.logger.debug(
+      'Saving onboarding progress',
+      'OnboardingProgressService',
+      {
+        userId,
+        currentStep: data.currentStep,
+      },
+    );
+
+    const progressData = this.buildProgressData(data);
+
+    const progress = await this.prisma.onboardingProgress.upsert({
+      where: { userId },
+      update: progressData,
+      create: { userId, ...progressData },
+    });
+
+    return {
+      success: true,
+      currentStep: progress.currentStep,
+      completedSteps: progress.completedSteps,
+    };
+  }
+
+  async getProgress(userId: string) {
+    const progress = await this.prisma.onboardingProgress.findUnique({
+      where: { userId },
+    });
+
+    if (!progress) {
+      return INITIAL_PROGRESS;
+    }
+
+    return {
+      currentStep: progress.currentStep,
+      completedSteps: progress.completedSteps,
+      username: progress.username,
+      personalInfo: progress.personalInfo,
+      professionalProfile: progress.professionalProfile,
+      experiences: progress.experiences ?? [],
+      noExperience: progress.noExperience,
+      education: progress.education ?? [],
+      noEducation: progress.noEducation,
+      skills: progress.skills ?? [],
+      noSkills: progress.noSkills,
+      languages: progress.languages ?? [],
+      templateSelection: progress.templateSelection,
+    };
+  }
+
+  async deleteProgress(userId: string) {
+    await this.prisma.onboardingProgress.deleteMany({ where: { userId } });
+  }
+
+  private buildProgressData(data: OnboardingProgressDto) {
+    return {
+      currentStep: data.currentStep,
+      completedSteps: data.completedSteps,
+      username: data.username ?? undefined,
+      personalInfo: data.personalInfo ?? undefined,
+      professionalProfile: data.professionalProfile ?? undefined,
+      experiences: data.experiences ?? undefined,
+      noExperience: data.noExperience ?? false,
+      education: data.education ?? undefined,
+      noEducation: data.noEducation ?? false,
+      skills: data.skills ?? undefined,
+      noSkills: data.noSkills ?? false,
+      languages: data.languages ?? undefined,
+      templateSelection: data.templateSelection ?? undefined,
+    };
+  }
+}
diff --git a/src/onboarding/services/resume-onboarding.service.ts b/src/onboarding/services/resume-onboarding.service.ts
index 43407f0..8635ee0 100644
--- a/src/onboarding/services/resume-onboarding.service.ts
+++ b/src/onboarding/services/resume-onboarding.service.ts
@@ -16,7 +16,7 @@ export class ResumeOnboardingService {
     });
 
     const resume = await this.prisma.resume.upsert({
-      where: { id: existingResume?.id || 'nonexistent' },
+      where: { id: existingResume?.id ?? 'nonexistent' },
       update: {
         fullName: personalInfo.fullName,
         emailContact: personalInfo.email,
diff --git a/src/onboarding/services/skills-onboarding.service.ts b/src/onboarding/services/skills-onboarding.service.ts
index b6f2708..66dd6c8 100644
--- a/src/onboarding/services/skills-onboarding.service.ts
+++ b/src/onboarding/services/skills-onboarding.service.ts
@@ -11,9 +11,9 @@ export class SkillsOnboardingService {
   async saveSkills(resumeId: string, data: OnboardingData) {
     const { skillsStep } = data;
 
-    if (!skillsStep || skillsStep.noSkills || !skillsStep.skills?.length) {
+    if (skillsStep.noSkills || !skillsStep.skills?.length) {
       this.logger.log(
-        skillsStep?.noSkills ? 'User selected noSkills' : 'No skills provided',
+        skillsStep.noSkills ? 'User selected noSkills' : 'No skills provided',
       );
       return;
     }
diff --git a/src/prisma/prisma.service.ts b/src/prisma/prisma.service.ts
index e9620a5..050dd50 100644
--- a/src/prisma/prisma.service.ts
+++ b/src/prisma/prisma.service.ts
@@ -6,6 +6,22 @@ import {
 } from '@nestjs/common';
 import { PrismaClient } from '@prisma/client';
 
+// Type-safe model accessor for cleanup operations
+type DeletableModel = { deleteMany: () => Promise<unknown> };
+type PrismaModelKey = keyof Omit<
+  PrismaClient,
+  | '$connect'
+  | '$disconnect'
+  | '$on'
+  | '$transaction'
+  | '$use'
+  | '$extends'
+  | '$executeRaw'
+  | '$executeRawUnsafe'
+  | '$queryRaw'
+  | '$queryRawUnsafe'
+>;
+
 @Injectable()
 export class PrismaService
   extends PrismaClient
@@ -69,8 +85,12 @@ export class PrismaService
 
     for (const modelName of modelNames) {
       try {
-        // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access
-        await (this[modelName] as any)?.deleteMany?.();
+        const model = this[modelName as PrismaModelKey] as
+          | DeletableModel
+          | undefined;
+        if (model) {
+          await model.deleteMany();
+        }
       } catch {
         // Model may not exist, skip
       }
diff --git a/src/resumes/controllers/base/base-sub-resource.controller.ts b/src/resumes/controllers/base/base-sub-resource.controller.ts
index 85751d4..f5c746c 100644
--- a/src/resumes/controllers/base/base-sub-resource.controller.ts
+++ b/src/resumes/controllers/base/base-sub-resource.controller.ts
@@ -25,7 +25,7 @@ import { MessageResponse } from '../../../common/dto/api-response.dto';
  * Configuration for the BaseSubResourceController
  */
 export interface SubResourceControllerConfig<
-  Entity,
+  _Entity,
   CreateDto,
   UpdateDto,
   ResponseDto,
@@ -90,13 +90,13 @@ export abstract class BaseSubResourceController<
   @ApiQuery({ name: 'page', required: false, type: Number })
   @ApiQuery({ name: 'limit', required: false, type: Number })
   @ApiResponse({ status: 200, description: 'List of entities' })
-  async findAll(
+  async listAll(
     @Param('resumeId', ParseCuidPipe) resumeId: string,
     @CurrentUser() user: UserPayload,
     @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,
     @Query('limit', new DefaultValuePipe(20), ParseIntPipe) limit: number,
   ): Promise<PaginatedResult<Entity>> {
-    return this.service.findAll(resumeId, user.userId, page, limit);
+    return this.service.listForResume(resumeId, user.userId, page, limit);
   }
 
   @Get(':id')
@@ -105,12 +105,12 @@ export abstract class BaseSubResourceController<
   @ApiParam({ name: 'id', description: 'Entity ID' })
   @ApiResponse({ status: 200, description: 'Entity found' })
   @ApiResponse({ status: 404, description: 'Entity not found' })
-  async findOne(
+  async getOne(
     @Param('resumeId', ParseCuidPipe) resumeId: string,
-    @Param('id', ParseCuidPipe) id: string,
+    @Param('id', ParseCuidPipe) entityId: string,
     @CurrentUser() user: UserPayload,
   ): Promise<Entity> {
-    return this.service.findOne(resumeId, id, user.userId);
+    return this.service.getById(resumeId, entityId, user.userId);
   }
 
   @Post()
@@ -119,12 +119,12 @@ export abstract class BaseSubResourceController<
   @ApiParam({ name: 'resumeId', description: 'Resume ID' })
   @ApiResponse({ status: 201, description: 'Entity created' })
   @ApiResponse({ status: 403, description: 'Access denied' })
-  async create(
+  async add(
     @Param('resumeId', ParseCuidPipe) resumeId: string,
     @CurrentUser() user: UserPayload,
     @Body() createDto: CreateDto,
   ): Promise<Entity> {
-    return this.service.create(resumeId, user.userId, createDto);
+    return this.service.addToResume(resumeId, user.userId, createDto);
   }
 
   @Patch(':id')
@@ -133,13 +133,13 @@ export abstract class BaseSubResourceController<
   @ApiParam({ name: 'id', description: 'Entity ID' })
   @ApiResponse({ status: 200, description: 'Entity updated' })
   @ApiResponse({ status: 404, description: 'Entity not found' })
-  async update(
+  async edit(
     @Param('resumeId', ParseCuidPipe) resumeId: string,
-    @Param('id', ParseCuidPipe) id: string,
+    @Param('id', ParseCuidPipe) entityId: string,
     @CurrentUser() user: UserPayload,
     @Body() updateDto: UpdateDto,
   ): Promise<Entity> {
-    return this.service.update(resumeId, id, user.userId, updateDto);
+    return this.service.updateById(resumeId, entityId, user.userId, updateDto);
   }
 
   @Delete(':id')
@@ -149,12 +149,12 @@ export abstract class BaseSubResourceController<
   @ApiParam({ name: 'id', description: 'Entity ID' })
   @ApiResponse({ status: 200, description: 'Entity deleted' })
   @ApiResponse({ status: 404, description: 'Entity not found' })
-  async remove(
+  async delete(
     @Param('resumeId', ParseCuidPipe) resumeId: string,
-    @Param('id', ParseCuidPipe) id: string,
+    @Param('id', ParseCuidPipe) entityId: string,
     @CurrentUser() user: UserPayload,
   ): Promise<MessageResponse> {
-    return this.service.remove(resumeId, id, user.userId);
+    return this.service.deleteById(resumeId, entityId, user.userId);
   }
 
   @Post('reorder')
@@ -167,6 +167,6 @@ export abstract class BaseSubResourceController<
     @CurrentUser() user: UserPayload,
     @Body() reorderDto: ReorderDto,
   ): Promise<MessageResponse> {
-    return this.service.reorder(resumeId, user.userId, reorderDto.ids);
+    return this.service.reorderInResume(resumeId, user.userId, reorderDto.ids);
   }
 }
diff --git a/src/resumes/controllers/skill.controller.ts b/src/resumes/controllers/skill.controller.ts
index 2755455..f5e2cc8 100644
--- a/src/resumes/controllers/skill.controller.ts
+++ b/src/resumes/controllers/skill.controller.ts
@@ -63,7 +63,7 @@ export class SkillController extends BaseSubResourceController<
     super(skillService);
   }
 
-  // Override findAll to add category filter
+  // Custom findAll with category filter (not overriding base listAll)
   @Get()
   @ApiOperation({ summary: 'Get all skills for a resume' })
   @ApiParam({ name: 'resumeId', description: 'Resume ID' })
@@ -71,7 +71,7 @@ export class SkillController extends BaseSubResourceController<
   @ApiQuery({ name: 'limit', required: false, type: Number })
   @ApiQuery({ name: 'category', required: false, type: String })
   @ApiResponse({ status: 200, description: 'List of skills' })
-  override async findAll(
+  async findAll(
     @Param('resumeId', ParseCuidPipe) resumeId: string,
     @CurrentUser() user: UserPayload,
     @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,
diff --git a/src/resumes/controllers/talk.controller.ts b/src/resumes/controllers/talk.controller.ts
index 2de59d2..1e159fa 100644
--- a/src/resumes/controllers/talk.controller.ts
+++ b/src/resumes/controllers/talk.controller.ts
@@ -2,11 +2,7 @@ import { Controller, UseGuards } from '@nestjs/common';
 import { ApiTags, ApiBearerAuth } from '@nestjs/swagger';
 import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
 import { TalkService } from '../services/talk.service';
-import {
-  CreateTalkDto,
-  UpdateTalkDto,
-  TalkResponseDto,
-} from '../dto/talk.dto';
+import { CreateTalkDto, UpdateTalkDto, TalkResponseDto } from '../dto/talk.dto';
 import {
   BaseSubResourceController,
   SubResourceControllerConfig,
diff --git a/src/resumes/dto/language.dto.ts b/src/resumes/dto/language.dto.ts
index 7e74ab2..f286bb1 100644
--- a/src/resumes/dto/language.dto.ts
+++ b/src/resumes/dto/language.dto.ts
@@ -1,4 +1,11 @@
-import { IsString, IsInt, Min, MaxLength, IsOptional, IsIn } from 'class-validator';
+import {
+  IsString,
+  IsInt,
+  Min,
+  MaxLength,
+  IsOptional,
+  IsIn,
+} from 'class-validator';
 import { ApiProperty, ApiPropertyOptional, PartialType } from '@nestjs/swagger';
 
 const CEFR_LEVELS = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2'] as const;
@@ -14,7 +21,11 @@ export class CreateLanguageDto {
   @MaxLength(50)
   level: string;
 
-  @ApiPropertyOptional({ example: 'B2', enum: CEFR_LEVELS, description: 'CEFR language proficiency level' })
+  @ApiPropertyOptional({
+    example: 'B2',
+    enum: CEFR_LEVELS,
+    description: 'CEFR language proficiency level',
+  })
   @IsOptional()
   @IsString()
   @IsIn(CEFR_LEVELS)
diff --git a/src/resumes/dto/pagination.dto.ts b/src/resumes/dto/pagination.dto.ts
index a952fa5..f1e6221 100644
--- a/src/resumes/dto/pagination.dto.ts
+++ b/src/resumes/dto/pagination.dto.ts
@@ -1,6 +1,7 @@
 import { IsOptional, IsInt, Min, Max } from 'class-validator';
 import { Type } from 'class-transformer';
 import { ApiPropertyOptional } from '@nestjs/swagger';
+import { APP_CONSTANTS } from '../../common/constants/app.constants';
 
 export class PaginationDto {
   @ApiPropertyOptional({ default: 1, minimum: 1 })
@@ -10,13 +11,17 @@ export class PaginationDto {
   @Min(1)
   page?: number = 1;
 
-  @ApiPropertyOptional({ default: 20, minimum: 1, maximum: 100 })
+  @ApiPropertyOptional({
+    default: APP_CONSTANTS.DEFAULT_PAGE_SIZE,
+    minimum: 1,
+    maximum: APP_CONSTANTS.MAX_PAGE_SIZE,
+  })
   @IsOptional()
   @Type(() => Number)
   @IsInt()
   @Min(1)
-  @Max(100)
-  limit?: number = 20;
+  @Max(APP_CONSTANTS.MAX_PAGE_SIZE)
+  limit?: number = APP_CONSTANTS.DEFAULT_PAGE_SIZE;
 }
 
 export interface PaginatedResult<T> {
diff --git a/src/resumes/module-imports.ts b/src/resumes/module-imports.ts
new file mode 100644
index 0000000..d16854d
--- /dev/null
+++ b/src/resumes/module-imports.ts
@@ -0,0 +1,61 @@
+/**
+ * Resumes Module Imports
+ * Centralized imports for resumes module
+ */
+
+// Sub-resource Controllers
+export {
+  ExperienceController,
+  EducationController,
+  SkillController,
+  ProjectController,
+  CertificationController,
+  AwardController,
+  LanguageController,
+  InterestController,
+  RecommendationController,
+  AchievementController,
+  PublicationController,
+  TalkController,
+  HackathonController,
+  BugBountyController,
+  OpenSourceController,
+} from './controllers';
+
+// Sub-resource Services
+export {
+  ExperienceService,
+  EducationService,
+  SkillService,
+  ProjectService,
+  CertificationService,
+  AwardService,
+  LanguageService,
+  InterestService,
+  RecommendationService,
+  AchievementService,
+  PublicationService,
+  TalkService,
+  HackathonService,
+  BugBountyService,
+  OpenSourceService,
+} from './services';
+
+// Sub-resource Repositories
+export {
+  ExperienceRepository,
+  EducationRepository,
+  SkillRepository,
+  ProjectRepository,
+  CertificationRepository,
+  AwardRepository,
+  LanguageRepository,
+  InterestRepository,
+  RecommendationRepository,
+  AchievementRepository,
+  PublicationRepository,
+  TalkRepository,
+  HackathonRepository,
+  BugBountyRepository,
+  OpenSourceRepository,
+} from './repositories';
diff --git a/src/resumes/resumes.module.ts b/src/resumes/resumes.module.ts
index 7883ab8..d52d3fd 100644
--- a/src/resumes/resumes.module.ts
+++ b/src/resumes/resumes.module.ts
@@ -3,9 +3,8 @@ import { ResumesService } from './resumes.service';
 import { ResumesController } from './resumes.controller';
 import { ResumesRepository } from './resumes.repository';
 import { PrismaModule } from '../prisma/prisma.module';
-
-// Sub-resource Controllers
 import {
+  // Controllers
   ExperienceController,
   EducationController,
   SkillController,
@@ -21,10 +20,7 @@ import {
   HackathonController,
   BugBountyController,
   OpenSourceController,
-} from './controllers';
-
-// Sub-resource Services
-import {
+  // Services
   ExperienceService,
   EducationService,
   SkillService,
@@ -40,10 +36,7 @@ import {
   HackathonService,
   BugBountyService,
   OpenSourceService,
-} from './services';
-
-// Sub-resource Repositories
-import {
+  // Repositories
   ExperienceRepository,
   EducationRepository,
   SkillRepository,
@@ -59,7 +52,7 @@ import {
   HackathonRepository,
   BugBountyRepository,
   OpenSourceRepository,
-} from './repositories';
+} from './module-imports';
 
 @Module({
   imports: [PrismaModule],
diff --git a/src/resumes/resumes.repository.spec.ts b/src/resumes/resumes.repository.spec.ts
index a4d6eb8..d36d350 100644
--- a/src/resumes/resumes.repository.spec.ts
+++ b/src/resumes/resumes.repository.spec.ts
@@ -16,7 +16,6 @@ const mockPrismaService = {
 
 describe('ResumesRepository', () => {
   let repository: ResumesRepository;
-  let prisma: PrismaService;
 
   beforeEach(async () => {
     const module: TestingModule = await Test.createTestingModule({
@@ -30,7 +29,6 @@ describe('ResumesRepository', () => {
     }).compile();
 
     repository = module.get<ResumesRepository>(ResumesRepository);
-    prisma = module.get<PrismaService>(PrismaService);
   });
 
   afterEach(() => {
diff --git a/src/resumes/resumes.service.spec.ts b/src/resumes/resumes.service.spec.ts
index 98eff98..0c0df4b 100644
--- a/src/resumes/resumes.service.spec.ts
+++ b/src/resumes/resumes.service.spec.ts
@@ -16,7 +16,6 @@ const mockResumesRepository = {
 
 describe('ResumesService', () => {
   let service: ResumesService;
-  let repository: ResumesRepository;
 
   beforeEach(async () => {
     const module: TestingModule = await Test.createTestingModule({
@@ -30,7 +29,6 @@ describe('ResumesService', () => {
     }).compile();
 
     service = module.get<ResumesService>(ResumesService);
-    repository = module.get<ResumesRepository>(ResumesRepository);
   });
 
   afterEach(() => {
diff --git a/src/resumes/resumes.service.ts b/src/resumes/resumes.service.ts
index 5d4594c..f486bf1 100644
--- a/src/resumes/resumes.service.ts
+++ b/src/resumes/resumes.service.ts
@@ -8,6 +8,7 @@ import { ResumesRepository } from './resumes.repository';
 import { CreateResumeDto } from './dto/create-resume.dto';
 import { UpdateResumeDto } from './dto/update-resume.dto';
 import { ApiResponseHelper } from '../common/dto/api-response.dto';
+import { ERROR_MESSAGES } from '../common/constants/app.constants';
 
 /** Maximum number of resumes a user can create */
 const MAX_RESUMES_PER_USER = 4;
@@ -57,7 +58,7 @@ export class ResumesService {
     );
 
     if (!resume) {
-      throw new NotFoundException('Resume not found');
+      throw new NotFoundException(ERROR_MESSAGES.RESUME_NOT_FOUND);
     }
 
     return resume;
@@ -68,7 +69,7 @@ export class ResumesService {
     const deleted = await this.resumesRepository.delete(id, userId);
 
     if (!deleted) {
-      throw new NotFoundException('Resume not found');
+      throw new NotFoundException(ERROR_MESSAGES.RESUME_NOT_FOUND);
     }
 
     return ApiResponseHelper.message('Resume deleted successfully');
diff --git a/src/resumes/services/achievement.service.spec.ts b/src/resumes/services/achievement.service.spec.ts
index 39bb74b..0e0a072 100644
--- a/src/resumes/services/achievement.service.spec.ts
+++ b/src/resumes/services/achievement.service.spec.ts
@@ -6,8 +6,6 @@ import { ResumesRepository } from '../resumes.repository';
 
 describe('AchievementService', () => {
   let service: AchievementService;
-  let achievementRepository: AchievementRepository;
-  let resumesRepository: ResumesRepository;
 
   const mockAchievementRepository = {
     findAll: jest.fn(),
@@ -38,10 +36,6 @@ describe('AchievementService', () => {
     }).compile();
 
     service = module.get<AchievementService>(AchievementService);
-    achievementRepository = module.get<AchievementRepository>(
-      AchievementRepository,
-    );
-    resumesRepository = module.get<ResumesRepository>(ResumesRepository);
   });
 
   afterEach(() => {
@@ -72,7 +66,7 @@ describe('AchievementService', () => {
       mockResumesRepository.findOne.mockResolvedValue(mockResume);
       mockAchievementRepository.findAll.mockResolvedValue(mockAchievements);
 
-      const result = await service.findAll(resumeId, userId);
+      const result = await service.listForResume(resumeId, userId);
 
       expect(result).toEqual(mockAchievements);
       expect(mockResumesRepository.findOne).toHaveBeenCalledWith(
@@ -92,7 +86,7 @@ describe('AchievementService', () => {
 
       mockResumesRepository.findOne.mockResolvedValue(null);
 
-      await expect(service.findAll(resumeId, userId)).rejects.toThrow(
+      await expect(service.listForResume(resumeId, userId)).rejects.toThrow(
         ForbiddenException,
       );
       expect(mockAchievementRepository.findAll).not.toHaveBeenCalled();
@@ -112,7 +106,7 @@ describe('AchievementService', () => {
         totalPages: 0,
       });
 
-      await service.findAll(resumeId, userId, 2, 10);
+      await service.listForResume(resumeId, userId, 2, 10);
 
       expect(mockAchievementRepository.findAll).toHaveBeenCalledWith(
         resumeId,
@@ -139,7 +133,7 @@ describe('AchievementService', () => {
       mockResumesRepository.findOne.mockResolvedValue(mockResume);
       mockAchievementRepository.findOne.mockResolvedValue(mockAchievement);
 
-      const result = await service.findOne(resumeId, achievementId, userId);
+      const result = await service.getById(resumeId, achievementId, userId);
 
       expect(result).toEqual(mockAchievement);
       expect(mockAchievementRepository.findOne).toHaveBeenCalledWith(
@@ -158,7 +152,7 @@ describe('AchievementService', () => {
       mockAchievementRepository.findOne.mockResolvedValue(null);
 
       await expect(
-        service.findOne(resumeId, achievementId, userId),
+        service.getById(resumeId, achievementId, userId),
       ).rejects.toThrow(NotFoundException);
     });
 
@@ -170,7 +164,7 @@ describe('AchievementService', () => {
       mockResumesRepository.findOne.mockResolvedValue(null);
 
       await expect(
-        service.findOne(resumeId, achievementId, userId),
+        service.getById(resumeId, achievementId, userId),
       ).rejects.toThrow(ForbiddenException);
       expect(mockAchievementRepository.findOne).not.toHaveBeenCalled();
     });
@@ -199,7 +193,7 @@ describe('AchievementService', () => {
         mockCreatedAchievement,
       );
 
-      const result = await service.create(resumeId, userId, createDto);
+      const result = await service.addToResume(resumeId, userId, createDto);
 
       expect(result).toEqual(mockCreatedAchievement);
       expect(mockAchievementRepository.create).toHaveBeenCalledWith(
@@ -220,9 +214,9 @@ describe('AchievementService', () => {
 
       mockResumesRepository.findOne.mockResolvedValue(null);
 
-      await expect(service.create(resumeId, userId, createDto)).rejects.toThrow(
-        ForbiddenException,
-      );
+      await expect(
+        service.addToResume(resumeId, userId, createDto),
+      ).rejects.toThrow(ForbiddenException);
       expect(mockAchievementRepository.create).not.toHaveBeenCalled();
     });
   });
@@ -249,7 +243,7 @@ describe('AchievementService', () => {
         mockUpdatedAchievement,
       );
 
-      const result = await service.update(
+      const result = await service.updateById(
         resumeId,
         achievementId,
         userId,
@@ -275,7 +269,7 @@ describe('AchievementService', () => {
       mockAchievementRepository.update.mockResolvedValue(null);
 
       await expect(
-        service.update(resumeId, achievementId, userId, updateDto),
+        service.updateById(resumeId, achievementId, userId, updateDto),
       ).rejects.toThrow(NotFoundException);
     });
   });
@@ -290,7 +284,7 @@ describe('AchievementService', () => {
       mockResumesRepository.findOne.mockResolvedValue(mockResume);
       mockAchievementRepository.delete.mockResolvedValue(true);
 
-      const result = await service.remove(resumeId, achievementId, userId);
+      const result = await service.deleteById(resumeId, achievementId, userId);
 
       expect(result).toEqual({
         success: true,
@@ -312,7 +306,7 @@ describe('AchievementService', () => {
       mockAchievementRepository.delete.mockResolvedValue(false);
 
       await expect(
-        service.remove(resumeId, achievementId, userId),
+        service.deleteById(resumeId, achievementId, userId),
       ).rejects.toThrow(NotFoundException);
     });
   });
@@ -327,7 +321,7 @@ describe('AchievementService', () => {
       mockResumesRepository.findOne.mockResolvedValue(mockResume);
       mockAchievementRepository.reorder.mockResolvedValue(undefined);
 
-      const result = await service.reorder(resumeId, userId, ids);
+      const result = await service.reorderInResume(resumeId, userId, ids);
 
       expect(result).toEqual({
         success: true,
@@ -346,9 +340,9 @@ describe('AchievementService', () => {
 
       mockResumesRepository.findOne.mockResolvedValue(null);
 
-      await expect(service.reorder(resumeId, userId, ids)).rejects.toThrow(
-        ForbiddenException,
-      );
+      await expect(
+        service.reorderInResume(resumeId, userId, ids),
+      ).rejects.toThrow(ForbiddenException);
       expect(mockAchievementRepository.reorder).not.toHaveBeenCalled();
     });
   });
diff --git a/src/resumes/services/base/base-sub-resource.service.spec.ts b/src/resumes/services/base/base-sub-resource.service.spec.ts
index b434935..22235bf 100644
--- a/src/resumes/services/base/base-sub-resource.service.spec.ts
+++ b/src/resumes/services/base/base-sub-resource.service.spec.ts
@@ -1,6 +1,3 @@
-/* eslint-disable @typescript-eslint/no-unsafe-assignment */
-/* eslint-disable @typescript-eslint/no-unsafe-argument */
-/* eslint-disable @typescript-eslint/unbound-method */
 /* eslint-disable @typescript-eslint/no-unused-vars */
 import { ForbiddenException, Logger, NotFoundException } from '@nestjs/common';
 import { Test, TestingModule } from '@nestjs/testing';
@@ -97,31 +94,31 @@ describe('BaseSubResourceService', () => {
 
       // Access private method through public methods
       await expect(
-        service.findAll(mockResumeId, mockUserId),
+        service.listForResume(mockResumeId, mockUserId),
       ).resolves.not.toThrow();
     });
 
     it('should throw ForbiddenException when resume not found', async () => {
       mockResumesRepository.findOne.mockResolvedValue(null);
 
-      await expect(service.findAll(mockResumeId, mockUserId)).rejects.toThrow(
-        ForbiddenException,
-      );
-      await expect(service.findAll(mockResumeId, mockUserId)).rejects.toThrow(
-        'Resume not found or access denied',
-      );
+      await expect(
+        service.listForResume(mockResumeId, mockUserId),
+      ).rejects.toThrow(ForbiddenException);
+      await expect(
+        service.listForResume(mockResumeId, mockUserId),
+      ).rejects.toThrow('Resume not found or access denied');
     });
 
     it('should throw ForbiddenException when user does not own resume', async () => {
       mockResumesRepository.findOne.mockResolvedValue(null);
 
-      await expect(service.findAll(mockResumeId, 'other-user')).rejects.toThrow(
-        ForbiddenException,
-      );
+      await expect(
+        service.listForResume(mockResumeId, 'other-user'),
+      ).rejects.toThrow(ForbiddenException);
     });
   });
 
-  describe('findAll', () => {
+  describe('listForResume', () => {
     const mockPaginatedResult: PaginatedResult<TestEntity> = {
       data: [mockEntity],
       meta: {
@@ -141,7 +138,7 @@ describe('BaseSubResourceService', () => {
     it('should return paginated results for valid owner', async () => {
       mockRepository.findAll.mockResolvedValue(mockPaginatedResult);
 
-      const result = await service.findAll(mockResumeId, mockUserId);
+      const result = await service.listForResume(mockResumeId, mockUserId);
 
       expect(result).toEqual(mockPaginatedResult);
       expect(mockResumesRepository.findOne).toHaveBeenCalledWith(
@@ -154,7 +151,7 @@ describe('BaseSubResourceService', () => {
     it('should pass custom pagination parameters', async () => {
       mockRepository.findAll.mockResolvedValue(mockPaginatedResult);
 
-      await service.findAll(mockResumeId, mockUserId, 2, 10);
+      await service.listForResume(mockResumeId, mockUserId, 2, 10);
 
       expect(mockRepository.findAll).toHaveBeenCalledWith(mockResumeId, 2, 10);
     });
@@ -162,7 +159,7 @@ describe('BaseSubResourceService', () => {
     it('should use default pagination when not provided', async () => {
       mockRepository.findAll.mockResolvedValue(mockPaginatedResult);
 
-      await service.findAll(mockResumeId, mockUserId);
+      await service.listForResume(mockResumeId, mockUserId);
 
       expect(mockRepository.findAll).toHaveBeenCalledWith(mockResumeId, 1, 20);
     });
@@ -176,7 +173,7 @@ describe('BaseSubResourceService', () => {
     it('should return entity when found', async () => {
       mockRepository.findOne.mockResolvedValue(mockEntity);
 
-      const result = await service.findOne(
+      const result = await service.getById(
         mockResumeId,
         mockEntityId,
         mockUserId,
@@ -193,10 +190,10 @@ describe('BaseSubResourceService', () => {
       mockRepository.findOne.mockResolvedValue(null);
 
       await expect(
-        service.findOne(mockResumeId, mockEntityId, mockUserId),
+        service.getById(mockResumeId, mockEntityId, mockUserId),
       ).rejects.toThrow(NotFoundException);
       await expect(
-        service.findOne(mockResumeId, mockEntityId, mockUserId),
+        service.getById(mockResumeId, mockEntityId, mockUserId),
       ).rejects.toThrow('TestEntity not found');
     });
 
@@ -204,7 +201,7 @@ describe('BaseSubResourceService', () => {
       mockResumesRepository.findOne.mockResolvedValue(null);
 
       await expect(
-        service.findOne(mockResumeId, mockEntityId, mockUserId),
+        service.getById(mockResumeId, mockEntityId, mockUserId),
       ).rejects.toThrow(ForbiddenException);
 
       expect(mockRepository.findOne).not.toHaveBeenCalled();
@@ -222,7 +219,11 @@ describe('BaseSubResourceService', () => {
     it('should create entity for valid owner', async () => {
       mockRepository.create.mockResolvedValue(createdEntity);
 
-      const result = await service.create(mockResumeId, mockUserId, createDto);
+      const result = await service.addToResume(
+        mockResumeId,
+        mockUserId,
+        createDto,
+      );
 
       expect(result).toEqual(createdEntity);
       expect(mockRepository.create).toHaveBeenCalledWith(
@@ -235,7 +236,7 @@ describe('BaseSubResourceService', () => {
       mockResumesRepository.findOne.mockResolvedValue(null);
 
       await expect(
-        service.create(mockResumeId, mockUserId, createDto),
+        service.addToResume(mockResumeId, mockUserId, createDto),
       ).rejects.toThrow(ForbiddenException);
 
       expect(mockRepository.create).not.toHaveBeenCalled();
@@ -244,7 +245,7 @@ describe('BaseSubResourceService', () => {
     it('should delegate creation to repository', async () => {
       mockRepository.create.mockResolvedValue(createdEntity);
 
-      await service.create(mockResumeId, mockUserId, createDto);
+      await service.addToResume(mockResumeId, mockUserId, createDto);
 
       expect(mockRepository.create).toHaveBeenCalledWith(
         mockResumeId,
@@ -264,7 +265,7 @@ describe('BaseSubResourceService', () => {
     it('should update entity for valid owner', async () => {
       mockRepository.update.mockResolvedValue(updatedEntity);
 
-      const result = await service.update(
+      const result = await service.updateById(
         mockResumeId,
         mockEntityId,
         mockUserId,
@@ -283,7 +284,7 @@ describe('BaseSubResourceService', () => {
       mockRepository.update.mockResolvedValue(null);
 
       await expect(
-        service.update(mockResumeId, mockEntityId, mockUserId, updateDto),
+        service.updateById(mockResumeId, mockEntityId, mockUserId, updateDto),
       ).rejects.toThrow(NotFoundException);
     });
 
@@ -291,7 +292,7 @@ describe('BaseSubResourceService', () => {
       mockResumesRepository.findOne.mockResolvedValue(null);
 
       await expect(
-        service.update(mockResumeId, mockEntityId, mockUserId, updateDto),
+        service.updateById(mockResumeId, mockEntityId, mockUserId, updateDto),
       ).rejects.toThrow(ForbiddenException);
 
       expect(mockRepository.update).not.toHaveBeenCalled();
@@ -306,7 +307,7 @@ describe('BaseSubResourceService', () => {
     it('should delete entity for valid owner', async () => {
       mockRepository.delete.mockResolvedValue(true);
 
-      const result = await service.remove(
+      const result = await service.deleteById(
         mockResumeId,
         mockEntityId,
         mockUserId,
@@ -326,10 +327,10 @@ describe('BaseSubResourceService', () => {
       mockRepository.delete.mockResolvedValue(false);
 
       await expect(
-        service.remove(mockResumeId, mockEntityId, mockUserId),
+        service.deleteById(mockResumeId, mockEntityId, mockUserId),
       ).rejects.toThrow(NotFoundException);
       await expect(
-        service.remove(mockResumeId, mockEntityId, mockUserId),
+        service.deleteById(mockResumeId, mockEntityId, mockUserId),
       ).rejects.toThrow('TestEntity not found');
     });
 
@@ -337,7 +338,7 @@ describe('BaseSubResourceService', () => {
       mockResumesRepository.findOne.mockResolvedValue(null);
 
       await expect(
-        service.remove(mockResumeId, mockEntityId, mockUserId),
+        service.deleteById(mockResumeId, mockEntityId, mockUserId),
       ).rejects.toThrow(ForbiddenException);
 
       expect(mockRepository.delete).not.toHaveBeenCalled();
@@ -354,7 +355,11 @@ describe('BaseSubResourceService', () => {
     it('should reorder entities for valid owner', async () => {
       mockRepository.reorder.mockResolvedValue(undefined);
 
-      const result = await service.reorder(mockResumeId, mockUserId, ids);
+      const result = await service.reorderInResume(
+        mockResumeId,
+        mockUserId,
+        ids,
+      );
 
       expect(result).toEqual({
         message: 'TestEntitys reordered successfully',
@@ -367,7 +372,7 @@ describe('BaseSubResourceService', () => {
       mockResumesRepository.findOne.mockResolvedValue(null);
 
       await expect(
-        service.reorder(mockResumeId, mockUserId, ids),
+        service.reorderInResume(mockResumeId, mockUserId, ids),
       ).rejects.toThrow(ForbiddenException);
 
       expect(mockRepository.reorder).not.toHaveBeenCalled();
@@ -376,7 +381,7 @@ describe('BaseSubResourceService', () => {
     it('should delegate to repository correctly', async () => {
       mockRepository.reorder.mockResolvedValue(undefined);
 
-      await service.reorder(mockResumeId, mockUserId, ids);
+      await service.reorderInResume(mockResumeId, mockUserId, ids);
 
       expect(mockRepository.reorder).toHaveBeenCalledWith(mockResumeId, ids);
     });
diff --git a/src/resumes/services/base/base-sub-resource.service.ts b/src/resumes/services/base/base-sub-resource.service.ts
index 17aa5c0..c911198 100644
--- a/src/resumes/services/base/base-sub-resource.service.ts
+++ b/src/resumes/services/base/base-sub-resource.service.ts
@@ -1,8 +1,4 @@
-import {
-  ForbiddenException,
-  Logger,
-  NotFoundException,
-} from '@nestjs/common';
+import { ForbiddenException, Logger, NotFoundException } from '@nestjs/common';
 import { ResumesRepository } from '../../resumes.repository';
 import { ISubResourceRepository } from '../../interfaces/base-sub-resource.interface';
 import { PaginatedResult } from '../../dto/pagination.dto';
@@ -10,6 +6,7 @@ import {
   ApiResponseHelper,
   MessageResponse,
 } from '../../../common/dto/api-response.dto';
+import { ERROR_MESSAGES } from '../../../common/constants/app.constants';
 
 /**
  * Abstract base service for resume sub-resources
@@ -40,7 +37,11 @@ export abstract class BaseSubResourceService<T, CreateDto, UpdateDto> {
   protected abstract readonly logger: Logger;
 
   constructor(
-    protected readonly repository: ISubResourceRepository<T, CreateDto, UpdateDto>,
+    protected readonly repository: ISubResourceRepository<
+      T,
+      CreateDto,
+      UpdateDto
+    >,
     protected readonly resumesRepository: ResumesRepository,
   ) {}
 
@@ -54,14 +55,14 @@ export abstract class BaseSubResourceService<T, CreateDto, UpdateDto> {
   ): Promise<void> {
     const resume = await this.resumesRepository.findOne(resumeId, userId);
     if (!resume) {
-      throw new ForbiddenException('Resume not found or access denied');
+      throw new ForbiddenException(ERROR_MESSAGES.RESUME_ACCESS_DENIED);
     }
   }
 
   /**
-   * Find all entities for a resume with pagination
+   * List all entities for a resume with pagination
    */
-  async findAll(
+  async listForResume(
     resumeId: string,
     userId: string,
     page: number = 1,
@@ -72,12 +73,16 @@ export abstract class BaseSubResourceService<T, CreateDto, UpdateDto> {
   }
 
   /**
-   * Find a single entity by ID
+   * Get a single entity by its ID
    * Throws NotFoundException if not found
    */
-  async findOne(resumeId: string, id: string, userId: string): Promise<T> {
+  async getById(
+    resumeId: string,
+    entityId: string,
+    userId: string,
+  ): Promise<T> {
     await this.validateResumeOwnership(resumeId, userId);
-    const entity = await this.repository.findOne(id, resumeId);
+    const entity = await this.repository.findOne(entityId, resumeId);
     if (!entity) {
       throw new NotFoundException(`${this.entityName} not found`);
     }
@@ -85,65 +90,65 @@ export abstract class BaseSubResourceService<T, CreateDto, UpdateDto> {
   }
 
   /**
-   * Create a new entity
+   * Add a new entity to the resume
    */
-  async create(
+  async addToResume(
     resumeId: string,
     userId: string,
-    data: CreateDto,
+    entityData: CreateDto,
   ): Promise<T> {
     await this.validateResumeOwnership(resumeId, userId);
     this.logger.log(`Creating ${this.entityName} for resume: ${resumeId}`);
-    return this.repository.create(resumeId, data);
+    return this.repository.create(resumeId, entityData);
   }
 
   /**
-   * Update an existing entity
+   * Update an existing entity by its ID
    * Throws NotFoundException if not found
    */
-  async update(
+  async updateById(
     resumeId: string,
-    id: string,
+    entityId: string,
     userId: string,
-    data: UpdateDto,
+    updateData: UpdateDto,
   ): Promise<T> {
     await this.validateResumeOwnership(resumeId, userId);
-    const entity = await this.repository.update(id, resumeId, data);
+    const entity = await this.repository.update(entityId, resumeId, updateData);
     if (!entity) {
       throw new NotFoundException(`${this.entityName} not found`);
     }
-    this.logger.log(`Updated ${this.entityName}: ${id}`);
+    this.logger.log(`Updated ${this.entityName}: ${entityId}`);
     return entity;
   }
 
   /**
-   * Remove an entity
+   * Delete an entity by its ID
    * Throws NotFoundException if not found
    */
-  async remove(
+  async deleteById(
     resumeId: string,
-    id: string,
+    entityId: string,
     userId: string,
   ): Promise<MessageResponse> {
     await this.validateResumeOwnership(resumeId, userId);
-    const deleted = await this.repository.delete(id, resumeId);
+    const deleted = await this.repository.delete(entityId, resumeId);
     if (!deleted) {
       throw new NotFoundException(`${this.entityName} not found`);
     }
-    this.logger.log(`Deleted ${this.entityName}: ${id}`);
+    this.logger.log(`Deleted ${this.entityName}: ${entityId}`);
     return ApiResponseHelper.message(`${this.entityName} deleted successfully`);
   }
 
   /**
    * Reorder entities within a resume
    */
-  async reorder(
+  async reorderInResume(
     resumeId: string,
     userId: string,
-    ids: string[],
+    entityIds: string[],
   ): Promise<MessageResponse> {
     await this.validateResumeOwnership(resumeId, userId);
-    await this.repository.reorder(resumeId, ids);
+    await this.repository.reorder(resumeId, entityIds);
     return ApiResponseHelper.message(
       `${this.entityName}s reordered successfully`,
     );
diff --git a/src/resumes/services/education.service.ts b/src/resumes/services/education.service.ts
index 171ef0f..38dcf64 100644
--- a/src/resumes/services/education.service.ts
+++ b/src/resumes/services/education.service.ts
@@ -4,7 +4,10 @@ import { EducationRepository } from '../repositories/education.repository';
 import { ResumesRepository } from '../resumes.repository';
 import { CreateEducationDto, UpdateEducationDto } from '../dto/education.dto';
 import { BaseSubResourceService } from './base';
-import { ApiResponseHelper, MessageResponse } from '../../common/dto/api-response.dto';
+import {
+  ApiResponseHelper,
+  MessageResponse,
+} from '../../common/dto/api-response.dto';
 
 @Injectable()
 export class EducationService extends BaseSubResourceService<
@@ -32,6 +35,8 @@ export class EducationService extends BaseSubResourceService<
   ): Promise<MessageResponse> {
     await this.validateResumeOwnership(resumeId, userId);
     await this.repository.reorder(resumeId, ids);
-    return ApiResponseHelper.message('Education entries reordered successfully');
+    return ApiResponseHelper.message(
+      'Education entries reordered successfully',
+    );
   }
 }
diff --git a/src/resumes/services/skill.service.ts b/src/resumes/services/skill.service.ts
index dd23caa..13f1633 100644
--- a/src/resumes/services/skill.service.ts
+++ b/src/resumes/services/skill.service.ts
@@ -8,7 +8,10 @@ import {
   BulkCreateSkillsDto,
 } from '../dto/skill.dto';
 import { PaginatedResult } from '../dto/pagination.dto';
-import { ApiResponseHelper, ApiResponse } from '../../common/dto/api-response.dto';
+import {
+  ApiResponseHelper,
+  ApiResponse,
+} from '../../common/dto/api-response.dto';
 import { BaseSubResourceService } from './base';
 
 @Injectable()
diff --git a/src/spoken-languages/services/spoken-languages.service.ts b/src/spoken-languages/services/spoken-languages.service.ts
index 1283951..49fd555 100644
--- a/src/spoken-languages/services/spoken-languages.service.ts
+++ b/src/spoken-languages/services/spoken-languages.service.ts
@@ -5,6 +5,7 @@
 
 import { Injectable } from '@nestjs/common';
 import { PrismaService } from '../../prisma/prisma.service';
+import { APP_CONSTANTS } from '../../common/constants/app.constants';
 
 export interface SpokenLanguageDto {
   code: string;
@@ -40,9 +41,10 @@ export class SpokenLanguagesService {
   /**
    * Search spoken languages by name (in any supported language)
    */
-  async search(query: string, limit = 10): Promise<SpokenLanguageDto[]> {
-    const searchTerm = `%${query.toLowerCase()}%`;
-
+  async search(
+    query: string,
+    limit: number = APP_CONSTANTS.SEARCH_AUTOCOMPLETE_LIMIT,
+  ): Promise<SpokenLanguageDto[]> {
     const languages = await this.prisma.spokenLanguage.findMany({
       where: {
         isActive: true,
diff --git a/src/spoken-languages/spoken-languages.controller.ts b/src/spoken-languages/spoken-languages.controller.ts
index 09cceb2..b5b4436 100644
--- a/src/spoken-languages/spoken-languages.controller.ts
+++ b/src/spoken-languages/spoken-languages.controller.ts
@@ -9,7 +9,9 @@ import { Public } from '../auth/decorators/public.decorator';
 
 @Controller('spoken-languages')
 export class SpokenLanguagesController {
-  constructor(private readonly spokenLanguagesService: SpokenLanguagesService) {}
+  constructor(
+    private readonly spokenLanguagesService: SpokenLanguagesService,
+  ) {}
 
   /**
    * Get all spoken languages
@@ -26,10 +28,7 @@ export class SpokenLanguagesController {
    */
   @Public()
   @Get('search')
-  async search(
-    @Query('q') query: string,
-    @Query('limit') limit?: string,
-  ) {
+  async search(@Query('q') query: string, @Query('limit') limit?: string) {
     return this.spokenLanguagesService.search(
       query || '',
       limit ? parseInt(limit, 10) : 10,
diff --git a/src/tech-skills/constants/index.ts b/src/tech-skills/constants/index.ts
new file mode 100644
index 0000000..d9e76f0
--- /dev/null
+++ b/src/tech-skills/constants/index.ts
@@ -0,0 +1,43 @@
+/**
+ * Tech Skills Constants - Barrel Export
+ */
+
+// Skill constants
+export { SKILL_CATEGORIES } from './skill-categories.const';
+export { SKILL_TRANSLATIONS } from './skill-translations.const';
+export { SKILL_COLORS } from './skill-colors.const';
+
+// Language constants
+export { LANGUAGE_TRANSLATIONS } from './language-translations.const';
+export { LANGUAGE_PARADIGMS } from './language-paradigms.const';
+export { LANGUAGE_TYPING } from './language-typing.const';
+export { POPULARITY_ORDER } from './language-popularity.const';
+export { LANGUAGE_WEBSITES } from './language-websites.const';
+export {
+  LANGUAGE_METADATA,
+  GITHUB_LINGUIST_URL,
+} from './language-metadata.const';
+
+// Stack Overflow specific constants
+export {
+  STACKOVERFLOW_CATEGORIES,
+  type StackOverflowCategory,
+} from './stackoverflow-categories.const';
+export { STACKOVERFLOW_TRANSLATIONS } from './stackoverflow-translations.const';
+export { STACKOVERFLOW_COLORS } from './stackoverflow-colors.const';
+
+// Individual category groups (for specific imports)
+export {
+  FRAMEWORK_CATEGORIES,
+  DATABASE_CATEGORIES,
+  DEVOPS_CATEGORIES,
+  DATA_AI_CATEGORIES,
+  TESTING_CATEGORIES,
+  DESIGN_CATEGORIES,
+  SECURITY_CATEGORIES,
+  COLLABORATION_CATEGORIES,
+  LIBRARY_CATEGORIES,
+  METHODOLOGY_CATEGORIES,
+  BLOCKCHAIN_CATEGORIES,
+  IDE_CATEGORIES,
+} from './skill-categories.const';
diff --git a/src/tech-skills/constants/language-metadata.const.ts b/src/tech-skills/constants/language-metadata.const.ts
new file mode 100644
index 0000000..bfb8f3e
--- /dev/null
+++ b/src/tech-skills/constants/language-metadata.const.ts
@@ -0,0 +1,35 @@
+/**
+ * Language Metadata Constants
+ * Aggregates language-related constants for GitHub Linguist parsing
+ */
+
+import { LANGUAGE_TRANSLATIONS } from './language-translations.const';
+import { LANGUAGE_PARADIGMS } from './language-paradigms.const';
+import { LANGUAGE_TYPING } from './language-typing.const';
+import { LANGUAGE_WEBSITES } from './language-websites.const';
+import { POPULARITY_ORDER } from './language-popularity.const';
+
+/**
+ * Language metadata configuration
+ * Combines all language-related constants for easy access
+ */
+export const LANGUAGE_METADATA = {
+  translations: LANGUAGE_TRANSLATIONS,
+  paradigms: LANGUAGE_PARADIGMS,
+  typing: LANGUAGE_TYPING,
+  websites: LANGUAGE_WEBSITES,
+  popularityOrder: POPULARITY_ORDER,
+} as const;
+
+/**
+ * GitHub Linguist URL
+ */
+export const GITHUB_LINGUIST_URL =
+  'https://raw.githubusercontent.com/github/linguist/master/lib/linguist/languages.yml';
+
+// Re-export individual constants for backward compatibility
+export { LANGUAGE_TRANSLATIONS };
+export { LANGUAGE_PARADIGMS };
+export { LANGUAGE_TYPING };
+export { LANGUAGE_WEBSITES };
+export { POPULARITY_ORDER };
diff --git a/src/tech-skills/constants/language-paradigms.const.ts b/src/tech-skills/constants/language-paradigms.const.ts
new file mode 100644
index 0000000..0c1b9ca
--- /dev/null
+++ b/src/tech-skills/constants/language-paradigms.const.ts
@@ -0,0 +1,41 @@
+/**
+ * Language Paradigms
+ * Programming paradigms for each language
+ */
+
+export const LANGUAGE_PARADIGMS: Record<string, string[]> = {
+  JavaScript: [
+    'multi-paradigm',
+    'event-driven',
+    'functional',
+    'imperative',
+    'object-oriented',
+  ],
+  TypeScript: ['multi-paradigm', 'object-oriented', 'functional'],
+  Python: ['multi-paradigm', 'object-oriented', 'functional', 'imperative'],
+  Java: ['object-oriented', 'imperative'],
+  'C#': ['multi-paradigm', 'object-oriented', 'functional'],
+  'C++': ['multi-paradigm', 'object-oriented', 'procedural', 'functional'],
+  C: ['procedural', 'imperative'],
+  Go: ['concurrent', 'imperative', 'structured'],
+  Rust: ['multi-paradigm', 'concurrent', 'functional', 'imperative'],
+  Ruby: ['multi-paradigm', 'object-oriented', 'functional'],
+  PHP: ['multi-paradigm', 'object-oriented', 'procedural'],
+  Swift: [
+    'multi-paradigm',
+    'object-oriented',
+    'functional',
+    'protocol-oriented',
+  ],
+  Kotlin: ['multi-paradigm', 'object-oriented', 'functional'],
+  Scala: ['multi-paradigm', 'object-oriented', 'functional'],
+  Haskell: ['purely functional', 'lazy evaluation'],
+  Elixir: ['functional', 'concurrent', 'distributed'],
+  Erlang: ['functional', 'concurrent', 'distributed'],
+  Clojure: ['functional', 'concurrent', 'lisp'],
+  'F#': ['functional', 'object-oriented', 'imperative'],
+  R: ['multi-paradigm', 'functional', 'object-oriented'],
+  Julia: ['multi-paradigm', 'functional', 'multiple dispatch'],
+  Dart: ['object-oriented', 'class-based'],
+  Lua: ['multi-paradigm', 'scripting', 'imperative'],
+};
diff --git a/src/tech-skills/constants/language-popularity.const.ts b/src/tech-skills/constants/language-popularity.const.ts
new file mode 100644
index 0000000..ce4b906
--- /dev/null
+++ b/src/tech-skills/constants/language-popularity.const.ts
@@ -0,0 +1,55 @@
+/**
+ * Language Popularity Order
+ * Defines popularity ranking for programming languages
+ */
+
+export const POPULARITY_ORDER: string[] = [
+  'JavaScript',
+  'Python',
+  'TypeScript',
+  'Java',
+  'C#',
+  'C++',
+  'PHP',
+  'C',
+  'Go',
+  'Rust',
+  'Ruby',
+  'Swift',
+  'Kotlin',
+  'Dart',
+  'Scala',
+  'R',
+  'Shell',
+  'PowerShell',
+  'SQL',
+  'HTML',
+  'CSS',
+  'Sass',
+  'SCSS',
+  'Objective-C',
+  'Perl',
+  'Haskell',
+  'Elixir',
+  'Erlang',
+  'Clojure',
+  'F#',
+  'Lua',
+  'Julia',
+  'MATLAB',
+  'Groovy',
+  'Assembly',
+  'COBOL',
+  'Fortran',
+  'Pascal',
+  'Visual Basic',
+  'VBA',
+  'Solidity',
+  'Move',
+  'Cairo',
+  'Vyper',
+  'Zig',
+  'Nim',
+  'Crystal',
+  'V',
+];
diff --git a/src/tech-skills/constants/language-translations.const.ts b/src/tech-skills/constants/language-translations.const.ts
new file mode 100644
index 0000000..d669386
--- /dev/null
+++ b/src/tech-skills/constants/language-translations.const.ts
@@ -0,0 +1,58 @@
+/**
+ * Language Translations
+ * Portuguese translations for programming languages
+ */
+
+export const LANGUAGE_TRANSLATIONS: Record<string, string> = {
+  JavaScript: 'JavaScript',
+  TypeScript: 'TypeScript',
+  Python: 'Python',
+  Java: 'Java',
+  'C#': 'C#',
+  'C++': 'C++',
+  C: 'C',
+  Go: 'Go',
+  Rust: 'Rust',
+  Ruby: 'Ruby',
+  PHP: 'PHP',
+  Swift: 'Swift',
+  Kotlin: 'Kotlin',
+  Scala: 'Scala',
+  R: 'R',
+  MATLAB: 'MATLAB',
+  Shell: 'Shell',
+  Bash: 'Bash',
+  PowerShell: 'PowerShell',
+  SQL: 'SQL',
+  HTML: 'HTML',
+  CSS: 'CSS',
+  Sass: 'Sass',
+  SCSS: 'SCSS',
+  Less: 'Less',
+  'Objective-C': 'Objective-C',
+  Dart: 'Dart',
+  Lua: 'Lua',
+  Perl: 'Perl',
+  Haskell: 'Haskell',
+  Elixir: 'Elixir',
+  Erlang: 'Erlang',
+  Clojure: 'Clojure',
+  'F#': 'F#',
+  Assembly: 'Assembly',
+  COBOL: 'COBOL',
+  Fortran: 'Fortran',
+  Pascal: 'Pascal',
+  Delphi: 'Delphi',
+  'Visual Basic': 'Visual Basic',
+  VBA: 'VBA',
+  Groovy: 'Groovy',
+  Julia: 'Julia',
+  Zig: 'Zig',
+  Nim: 'Nim',
+  Crystal: 'Crystal',
+  V: 'V',
+  Solidity: 'Solidity',
+  Move: 'Move',
+  Cairo: 'Cairo',
+  Vyper: 'Vyper',
+};
diff --git a/src/tech-skills/constants/language-typing.const.ts b/src/tech-skills/constants/language-typing.const.ts
new file mode 100644
index 0000000..3b066df
--- /dev/null
+++ b/src/tech-skills/constants/language-typing.const.ts
@@ -0,0 +1,30 @@
+/**
+ * Language Typing
+ * Type system classification for languages
+ */
+
+export const LANGUAGE_TYPING: Record<string, string> = {
+  JavaScript: 'dynamic',
+  TypeScript: 'static',
+  Python: 'dynamic',
+  Java: 'static',
+  'C#': 'static',
+  'C++': 'static',
+  C: 'static',
+  Go: 'static',
+  Rust: 'static',
+  Ruby: 'dynamic',
+  PHP: 'dynamic',
+  Swift: 'static',
+  Kotlin: 'static',
+  Scala: 'static',
+  Haskell: 'static',
+  Elixir: 'dynamic',
+  Erlang: 'dynamic',
+  Clojure: 'dynamic',
+  'F#': 'static',
+  R: 'dynamic',
+  Julia: 'dynamic',
+  Dart: 'static',
+  Lua: 'dynamic',
+};
diff --git a/src/tech-skills/constants/language-websites.const.ts b/src/tech-skills/constants/language-websites.const.ts
new file mode 100644
index 0000000..1ba3ac2
--- /dev/null
+++ b/src/tech-skills/constants/language-websites.const.ts
@@ -0,0 +1,35 @@
+/**
+ * Language Websites
+ * Official websites for programming languages
+ */
+
+export const LANGUAGE_WEBSITES: Record<string, string> = {
+  JavaScript: 'https://developer.mozilla.org/en-US/docs/Web/JavaScript',
+  TypeScript: 'https://www.typescriptlang.org/',
+  Python: 'https://www.python.org/',
+  Java: 'https://www.java.com/',
+  'C#': 'https://docs.microsoft.com/en-us/dotnet/csharp/',
+  'C++': 'https://isocpp.org/',
+  C: 'https://en.cppreference.com/w/c',
+  Go: 'https://go.dev/',
+  Rust: 'https://www.rust-lang.org/',
+  Ruby: 'https://www.ruby-lang.org/',
+  PHP: 'https://www.php.net/',
+  Swift: 'https://swift.org/',
+  Kotlin: 'https://kotlinlang.org/',
+  Scala: 'https://www.scala-lang.org/',
+  R: 'https://www.r-project.org/',
+  Haskell: 'https://www.haskell.org/',
+  Elixir: 'https://elixir-lang.org/',
+  Erlang: 'https://www.erlang.org/',
+  Clojure: 'https://clojure.org/',
+  'F#': 'https://fsharp.org/',
+  Julia: 'https://julialang.org/',
+  Dart: 'https://dart.dev/',
+  Lua: 'https://www.lua.org/',
+  Perl: 'https://www.perl.org/',
+  Zig: 'https://ziglang.org/',
+  Nim: 'https://nim-lang.org/',
+  Crystal: 'https://crystal-lang.org/',
+  Solidity: 'https://soliditylang.org/',
+};
diff --git a/src/tech-skills/constants/skill-categories-data.const.ts b/src/tech-skills/constants/skill-categories-data.const.ts
new file mode 100644
index 0000000..00ff84c
--- /dev/null
+++ b/src/tech-skills/constants/skill-categories-data.const.ts
@@ -0,0 +1,51 @@
+/**
+ * Stack Overflow Skill Categories - Data, AI & Testing
+ *
+ * Maps data science, AI/ML, and testing tags to skill types and niches.
+ */
+
+import type { SkillType } from '../interfaces';
+
+type SkillCategory = { type: SkillType; niche: string | null };
+
+export const DATA_AI_CATEGORIES: Record<string, SkillCategory> = {
+  pandas: { type: 'LIBRARY', niche: 'data-science' },
+  numpy: { type: 'LIBRARY', niche: 'data-science' },
+  'scikit-learn': { type: 'LIBRARY', niche: 'data-science' },
+  tensorflow: { type: 'FRAMEWORK', niche: 'machine-learning' },
+  pytorch: { type: 'FRAMEWORK', niche: 'machine-learning' },
+  keras: { type: 'LIBRARY', niche: 'machine-learning' },
+  opencv: { type: 'LIBRARY', niche: 'machine-learning' },
+  spark: { type: 'PLATFORM', niche: 'data-engineering' },
+  hadoop: { type: 'PLATFORM', niche: 'data-engineering' },
+  airflow: { type: 'TOOL', niche: 'data-engineering' },
+  kafka: { type: 'PLATFORM', niche: 'data-engineering' },
+  dbt: { type: 'TOOL', niche: 'data-engineering' },
+  snowflake: { type: 'PLATFORM', niche: 'data-engineering' },
+  'power-bi': { type: 'TOOL', niche: 'data-analytics' },
+  tableau: { type: 'TOOL', niche: 'data-analytics' },
+  looker: { type: 'TOOL', niche: 'data-analytics' },
+  metabase: { type: 'TOOL', niche: 'data-analytics' },
+  jupyter: { type: 'TOOL', niche: 'data-science' },
+  langchain: { type: 'FRAMEWORK', niche: 'machine-learning' },
+  huggingface: { type: 'PLATFORM', niche: 'machine-learning' },
+  openai: { type: 'PLATFORM', niche: 'machine-learning' },
+};
+
+export const TESTING_CATEGORIES: Record<string, SkillCategory> = {
+  jest: { type: 'TOOL', niche: 'qa' },
+  mocha: { type: 'TOOL', niche: 'qa' },
+  cypress: { type: 'TOOL', niche: 'qa' },
+  playwright: { type: 'TOOL', niche: 'qa' },
+  selenium: { type: 'TOOL', niche: 'qa' },
+  puppeteer: { type: 'TOOL', niche: 'qa' },
+  pytest: { type: 'TOOL', niche: 'qa' },
+  junit: { type: 'TOOL', niche: 'qa' },
+  testng: { type: 'TOOL', niche: 'qa' },
+  postman: { type: 'TOOL', niche: 'qa' },
+  insomnia: { type: 'TOOL', niche: 'qa' },
+  sentry: { type: 'TOOL', niche: 'qa' },
+  'new-relic': { type: 'TOOL', niche: 'qa' },
+  vitest: { type: 'TOOL', niche: 'qa' },
+  'testing-library': { type: 'LIBRARY', niche: 'qa' },
+};
diff --git a/src/tech-skills/constants/skill-categories-frameworks.const.ts b/src/tech-skills/constants/skill-categories-frameworks.const.ts
new file mode 100644
index 0000000..5af1996
--- /dev/null
+++ b/src/tech-skills/constants/skill-categories-frameworks.const.ts
@@ -0,0 +1,62 @@
+/**
+ * Stack Overflow Skill Categories
+ *
+ * Maps Stack Overflow tags to skill types and niches.
+ * Used for categorizing skills fetched from the API.
+ */
+
+import type { SkillType } from '../interfaces';
+
+type SkillCategory = { type: SkillType; niche: string | null };
+
+export const SKILL_CATEGORIES: Record<string, SkillCategory> = {
+  // Frameworks - Frontend
+  react: { type: 'FRAMEWORK', niche: 'frontend' },
+  reactjs: { type: 'FRAMEWORK', niche: 'frontend' },
+  angular: { type: 'FRAMEWORK', niche: 'frontend' },
+  angularjs: { type: 'FRAMEWORK', niche: 'frontend' },
+  'vue.js': { type: 'FRAMEWORK', niche: 'frontend' },
+  vuejs: { type: 'FRAMEWORK', niche: 'frontend' },
+  svelte: { type: 'FRAMEWORK', niche: 'frontend' },
+  'next.js': { type: 'FRAMEWORK', niche: 'frontend' },
+  nextjs: { type: 'FRAMEWORK', niche: 'frontend' },
+  'nuxt.js': { type: 'FRAMEWORK', niche: 'frontend' },
+  gatsby: { type: 'FRAMEWORK', niche: 'frontend' },
+  'ember.js': { type: 'FRAMEWORK', niche: 'frontend' },
+  'backbone.js': { type: 'FRAMEWORK', niche: 'frontend' },
+
+  // Frameworks - Backend
+  'node.js': { type: 'FRAMEWORK', niche: 'backend' },
+  nodejs: { type: 'FRAMEWORK', niche: 'backend' },
+  express: { type: 'FRAMEWORK', niche: 'backend' },
+  expressjs: { type: 'FRAMEWORK', niche: 'backend' },
+  nestjs: { type: 'FRAMEWORK', niche: 'backend' },
+  fastify: { type: 'FRAMEWORK', niche: 'backend' },
+  koa: { type: 'FRAMEWORK', niche: 'backend' },
+  django: { type: 'FRAMEWORK', niche: 'backend' },
+  flask: { type: 'FRAMEWORK', niche: 'backend' },
+  fastapi: { type: 'FRAMEWORK', niche: 'backend' },
+  spring: { type: 'FRAMEWORK', niche: 'backend' },
+  'spring-boot': { type: 'FRAMEWORK', niche: 'backend' },
+  rails: { type: 'FRAMEWORK', niche: 'backend' },
+  'ruby-on-rails': { type: 'FRAMEWORK', niche: 'backend' },
+  laravel: { type: 'FRAMEWORK', niche: 'backend' },
+  symfony: { type: 'FRAMEWORK', niche: 'backend' },
+  'asp.net': { type: 'FRAMEWORK', niche: 'backend' },
+  'asp.net-core': { type: 'FRAMEWORK', niche: 'backend' },
+  'asp.net-mvc': { type: 'FRAMEWORK', niche: 'backend' },
+  gin: { type: 'FRAMEWORK', niche: 'backend' },
+  fiber: { type: 'FRAMEWORK', niche: 'backend' },
+  actix: { type: 'FRAMEWORK', niche: 'backend' },
+  rocket: { type: 'FRAMEWORK', niche: 'backend' },
+  phoenix: { type: 'FRAMEWORK', niche: 'backend' },
+
+  // Frameworks - Mobile
+  'react-native': { type: 'FRAMEWORK', niche: 'mobile' },
+  flutter: { type: 'FRAMEWORK', niche: 'mobile' },
+  ionic: { type: 'FRAMEWORK', niche: 'mobile' },
+  xamarin: { type: 'FRAMEWORK', niche: 'mobile' },
+  swiftui: { type: 'FRAMEWORK', niche: 'mobile' },
+  'jetpack-compose': { type: 'FRAMEWORK', niche: 'mobile' },
+  'kotlin-multiplatform': { type: 'FRAMEWORK', niche: 'mobile' },
+};
diff --git a/src/tech-skills/constants/skill-categories-infra.const.ts b/src/tech-skills/constants/skill-categories-infra.const.ts
new file mode 100644
index 0000000..ee74109
--- /dev/null
+++ b/src/tech-skills/constants/skill-categories-infra.const.ts
@@ -0,0 +1,58 @@
+/**
+ * Stack Overflow Skill Categories - Databases & DevOps
+ *
+ * Maps database and DevOps-related tags to skill types and niches.
+ */
+
+import type { SkillType } from '../interfaces';
+
+type SkillCategory = { type: SkillType; niche: string | null };
+
+export const DATABASE_CATEGORIES: Record<string, SkillCategory> = {
+  mysql: { type: 'DATABASE', niche: 'backend' },
+  postgresql: { type: 'DATABASE', niche: 'backend' },
+  postgres: { type: 'DATABASE', niche: 'backend' },
+  mongodb: { type: 'DATABASE', niche: 'backend' },
+  redis: { type: 'DATABASE', niche: 'backend' },
+  sqlite: { type: 'DATABASE', niche: 'backend' },
+  oracle: { type: 'DATABASE', niche: 'backend' },
+  'sql-server': { type: 'DATABASE', niche: 'backend' },
+  mariadb: { type: 'DATABASE', niche: 'backend' },
+  cassandra: { type: 'DATABASE', niche: 'backend' },
+  dynamodb: { type: 'DATABASE', niche: 'backend' },
+  elasticsearch: { type: 'DATABASE', niche: 'backend' },
+  neo4j: { type: 'DATABASE', niche: 'backend' },
+  firebase: { type: 'DATABASE', niche: 'backend' },
+  supabase: { type: 'DATABASE', niche: 'backend' },
+  prisma: { type: 'LIBRARY', niche: 'backend' },
+  typeorm: { type: 'LIBRARY', niche: 'backend' },
+  sequelize: { type: 'LIBRARY', niche: 'backend' },
+  mongoose: { type: 'LIBRARY', niche: 'backend' },
+};
+
+export const DEVOPS_CATEGORIES: Record<string, SkillCategory> = {
+  docker: { type: 'TOOL', niche: 'devops' },
+  kubernetes: { type: 'PLATFORM', niche: 'devops' },
+  k8s: { type: 'PLATFORM', niche: 'devops' },
+  aws: { type: 'PLATFORM', niche: 'devops' },
+  azure: { type: 'PLATFORM', niche: 'devops' },
+  'google-cloud-platform': { type: 'PLATFORM', niche: 'devops' },
+  gcp: { type: 'PLATFORM', niche: 'devops' },
+  terraform: { type: 'TOOL', niche: 'devops' },
+  ansible: { type: 'TOOL', niche: 'devops' },
+  jenkins: { type: 'TOOL', niche: 'devops' },
+  'github-actions': { type: 'TOOL', niche: 'devops' },
+  'gitlab-ci': { type: 'TOOL', niche: 'devops' },
+  circleci: { type: 'TOOL', niche: 'devops' },
+  nginx: { type: 'TOOL', niche: 'devops' },
+  apache: { type: 'TOOL', niche: 'devops' },
+  linux: { type: 'PLATFORM', niche: 'devops' },
+  bash: { type: 'TOOL', niche: 'devops' },
+  prometheus: { type: 'TOOL', niche: 'devops' },
+  grafana: { type: 'TOOL', niche: 'devops' },
+  datadog: { type: 'TOOL', niche: 'devops' },
+  heroku: { type: 'PLATFORM', niche: 'devops' },
+  vercel: { type: 'PLATFORM', niche: 'devops' },
+  netlify: { type: 'PLATFORM', niche: 'devops' },
+  digitalocean: { type: 'PLATFORM', niche: 'devops' },
+};
diff --git a/src/tech-skills/constants/skill-categories-misc.const.ts b/src/tech-skills/constants/skill-categories-misc.const.ts
new file mode 100644
index 0000000..e814cbd
--- /dev/null
+++ b/src/tech-skills/constants/skill-categories-misc.const.ts
@@ -0,0 +1,67 @@
+/**
+ * Stack Overflow Skill Categories - Libraries & Methodologies
+ *
+ * Maps general libraries, methodologies, and blockchain tags.
+ */
+
+import type { SkillType } from '../interfaces';
+
+type SkillCategory = { type: SkillType; niche: string | null };
+
+export const LIBRARY_CATEGORIES: Record<string, SkillCategory> = {
+  jquery: { type: 'LIBRARY', niche: 'frontend' },
+  lodash: { type: 'LIBRARY', niche: null },
+  axios: { type: 'LIBRARY', niche: null },
+  redux: { type: 'LIBRARY', niche: 'frontend' },
+  zustand: { type: 'LIBRARY', niche: 'frontend' },
+  mobx: { type: 'LIBRARY', niche: 'frontend' },
+  rxjs: { type: 'LIBRARY', niche: null },
+  graphql: { type: 'LIBRARY', niche: null },
+  apollo: { type: 'LIBRARY', niche: null },
+  'socket.io': { type: 'LIBRARY', niche: 'backend' },
+  webpack: { type: 'TOOL', niche: 'frontend' },
+  vite: { type: 'TOOL', niche: 'frontend' },
+  rollup: { type: 'TOOL', niche: 'frontend' },
+  esbuild: { type: 'TOOL', niche: 'frontend' },
+  babel: { type: 'TOOL', niche: 'frontend' },
+  eslint: { type: 'TOOL', niche: null },
+  prettier: { type: 'TOOL', niche: null },
+};
+
+export const METHODOLOGY_CATEGORIES: Record<string, SkillCategory> = {
+  agile: { type: 'METHODOLOGY', niche: null },
+  scrum: { type: 'METHODOLOGY', niche: null },
+  kanban: { type: 'METHODOLOGY', niche: null },
+  tdd: { type: 'METHODOLOGY', niche: null },
+  bdd: { type: 'METHODOLOGY', niche: null },
+  'ci-cd': { type: 'METHODOLOGY', niche: 'devops' },
+  devops: { type: 'METHODOLOGY', niche: 'devops' },
+  microservices: { type: 'METHODOLOGY', niche: 'backend' },
+  serverless: { type: 'METHODOLOGY', niche: 'backend' },
+  rest: { type: 'METHODOLOGY', niche: null },
+  restful: { type: 'METHODOLOGY', niche: null },
+  api: { type: 'METHODOLOGY', niche: null },
+  'design-patterns': { type: 'METHODOLOGY', niche: null },
+  solid: { type: 'METHODOLOGY', niche: null },
+  'clean-architecture': { type: 'METHODOLOGY', niche: null },
+  ddd: { type: 'METHODOLOGY', niche: null },
+  'event-driven': { type: 'METHODOLOGY', niche: null },
+  cqrs: { type: 'METHODOLOGY', niche: null },
+};
+
+export const BLOCKCHAIN_CATEGORIES: Record<string, SkillCategory> = {
+  solidity: { type: 'LANGUAGE', niche: 'blockchain' },
+  web3: { type: 'LIBRARY', niche: 'blockchain' },
+  'ethers.js': { type: 'LIBRARY', niche: 'blockchain' },
+  hardhat: { type: 'TOOL', niche: 'blockchain' },
+  truffle: { type: 'TOOL', niche: 'blockchain' },
+  ethereum: { type: 'PLATFORM', niche: 'blockchain' },
+};
+
+export const IDE_CATEGORIES: Record<string, SkillCategory> = {
+  vscode: { type: 'TOOL', niche: null },
+  intellij: { type: 'TOOL', niche: null },
+  vim: { type: 'TOOL', niche: null },
+  neovim: { type: 'TOOL', niche: null },
+  emacs: { type: 'TOOL', niche: null },
+};
diff --git a/src/tech-skills/constants/skill-categories-tools.const.ts b/src/tech-skills/constants/skill-categories-tools.const.ts
new file mode 100644
index 0000000..efb9261
--- /dev/null
+++ b/src/tech-skills/constants/skill-categories-tools.const.ts
@@ -0,0 +1,55 @@
+/**
+ * Stack Overflow Skill Categories - Design, Security & Tools
+ *
+ * Maps design, security, and general tool tags to skill types and niches.
+ */
+
+import type { SkillType } from '../interfaces';
+
+type SkillCategory = { type: SkillType; niche: string | null };
+
+export const DESIGN_CATEGORIES: Record<string, SkillCategory> = {
+  figma: { type: 'TOOL', niche: 'design' },
+  sketch: { type: 'TOOL', niche: 'design' },
+  'adobe-xd': { type: 'TOOL', niche: 'design' },
+  invision: { type: 'TOOL', niche: 'design' },
+  zeplin: { type: 'TOOL', niche: 'design' },
+  tailwindcss: { type: 'FRAMEWORK', niche: 'frontend' },
+  'tailwind-css': { type: 'FRAMEWORK', niche: 'frontend' },
+  bootstrap: { type: 'FRAMEWORK', niche: 'frontend' },
+  'material-ui': { type: 'LIBRARY', niche: 'frontend' },
+  'chakra-ui': { type: 'LIBRARY', niche: 'frontend' },
+  'ant-design': { type: 'LIBRARY', niche: 'frontend' },
+  'styled-components': { type: 'LIBRARY', niche: 'frontend' },
+  emotion: { type: 'LIBRARY', niche: 'frontend' },
+  sass: { type: 'TOOL', niche: 'frontend' },
+  less: { type: 'TOOL', niche: 'frontend' },
+  storybook: { type: 'TOOL', niche: 'frontend' },
+};
+
+export const SECURITY_CATEGORIES: Record<string, SkillCategory> = {
+  oauth: { type: 'METHODOLOGY', niche: 'security' },
+  jwt: { type: 'METHODOLOGY', niche: 'security' },
+  owasp: { type: 'METHODOLOGY', niche: 'security' },
+  'penetration-testing': { type: 'METHODOLOGY', niche: 'security' },
+  'burp-suite': { type: 'TOOL', niche: 'security' },
+  nmap: { type: 'TOOL', niche: 'security' },
+  wireshark: { type: 'TOOL', niche: 'security' },
+  metasploit: { type: 'TOOL', niche: 'security' },
+  'kali-linux': { type: 'PLATFORM', niche: 'security' },
+  'hashicorp-vault': { type: 'TOOL', niche: 'security' },
+};
+
+export const COLLABORATION_CATEGORIES: Record<string, SkillCategory> = {
+  git: { type: 'TOOL', niche: null },
+  github: { type: 'PLATFORM', niche: null },
+  gitlab: { type: 'PLATFORM', niche: null },
+  bitbucket: { type: 'PLATFORM', niche: null },
+  jira: { type: 'TOOL', niche: null },
+  confluence: { type: 'TOOL', niche: null },
+  slack: { type: 'TOOL', niche: null },
+  notion: { type: 'TOOL', niche: null },
+  trello: { type: 'TOOL', niche: null },
+  asana: { type: 'TOOL', niche: null },
+  linear: { type: 'TOOL', niche: null },
+};
diff --git a/src/tech-skills/constants/skill-categories.const.ts b/src/tech-skills/constants/skill-categories.const.ts
new file mode 100644
index 0000000..57f08a1
--- /dev/null
+++ b/src/tech-skills/constants/skill-categories.const.ts
@@ -0,0 +1,63 @@
+/**
+ * Skill Categories - Aggregated Export
+ *
+ * Combines all skill category mappings into a single record.
+ */
+
+import type { SkillType } from '../interfaces';
+import { SKILL_CATEGORIES as FRAMEWORK_CATEGORIES } from './skill-categories-frameworks.const';
+import {
+  DATABASE_CATEGORIES,
+  DEVOPS_CATEGORIES,
+} from './skill-categories-infra.const';
+import {
+  DATA_AI_CATEGORIES,
+  TESTING_CATEGORIES,
+} from './skill-categories-data.const';
+import {
+  DESIGN_CATEGORIES,
+  SECURITY_CATEGORIES,
+  COLLABORATION_CATEGORIES,
+} from './skill-categories-tools.const';
+import {
+  LIBRARY_CATEGORIES,
+  METHODOLOGY_CATEGORIES,
+  BLOCKCHAIN_CATEGORIES,
+  IDE_CATEGORIES,
+} from './skill-categories-misc.const';
+
+type SkillCategory = { type: SkillType; niche: string | null };
+
+/**
+ * All skill categories combined
+ */
+export const SKILL_CATEGORIES: Record<string, SkillCategory> = {
+  ...FRAMEWORK_CATEGORIES,
+  ...DATABASE_CATEGORIES,
+  ...DEVOPS_CATEGORIES,
+  ...DATA_AI_CATEGORIES,
+  ...TESTING_CATEGORIES,
+  ...DESIGN_CATEGORIES,
+  ...SECURITY_CATEGORIES,
+  ...COLLABORATION_CATEGORIES,
+  ...LIBRARY_CATEGORIES,
+  ...METHODOLOGY_CATEGORIES,
+  ...BLOCKCHAIN_CATEGORIES,
+  ...IDE_CATEGORIES,
+};
+
+// Re-export individual category groups
+export {
+  FRAMEWORK_CATEGORIES,
+  DATABASE_CATEGORIES,
+  DEVOPS_CATEGORIES,
+  DATA_AI_CATEGORIES,
+  TESTING_CATEGORIES,
+  DESIGN_CATEGORIES,
+  SECURITY_CATEGORIES,
+  COLLABORATION_CATEGORIES,
+  LIBRARY_CATEGORIES,
+  METHODOLOGY_CATEGORIES,
+  BLOCKCHAIN_CATEGORIES,
+  IDE_CATEGORIES,
+};
diff --git a/src/tech-skills/constants/skill-colors.const.ts b/src/tech-skills/constants/skill-colors.const.ts
new file mode 100644
index 0000000..74c87a7
--- /dev/null
+++ b/src/tech-skills/constants/skill-colors.const.ts
@@ -0,0 +1,46 @@
+/**
+ * Skill Brand Colors
+ *
+ * Maps skill slugs to their official brand colors.
+ */
+
+export const SKILL_COLORS: Record<string, string> = {
+  react: '#61DAFB',
+  angular: '#DD0031',
+  'vue.js': '#4FC08D',
+  svelte: '#FF3E00',
+  'next.js': '#000000',
+  'node.js': '#339933',
+  express: '#000000',
+  nestjs: '#E0234E',
+  django: '#092E20',
+  flask: '#000000',
+  fastapi: '#009688',
+  spring: '#6DB33F',
+  laravel: '#FF2D20',
+  rails: '#CC0000',
+  docker: '#2496ED',
+  kubernetes: '#326CE5',
+  aws: '#FF9900',
+  azure: '#0078D4',
+  gcp: '#4285F4',
+  terraform: '#7B42BC',
+  mysql: '#4479A1',
+  postgresql: '#336791',
+  mongodb: '#47A248',
+  redis: '#DC382D',
+  elasticsearch: '#005571',
+  firebase: '#FFCA28',
+  git: '#F05032',
+  github: '#181717',
+  gitlab: '#FCA121',
+  figma: '#F24E1E',
+  tailwindcss: '#06B6D4',
+  bootstrap: '#7952B3',
+  graphql: '#E10098',
+  tensorflow: '#FF6F00',
+  pytorch: '#EE4C2C',
+  jest: '#C21325',
+  cypress: '#17202C',
+  selenium: '#43B02A',
+};
diff --git a/src/tech-skills/constants/skill-translations.const.ts b/src/tech-skills/constants/skill-translations.const.ts
new file mode 100644
index 0000000..c4e6f67
--- /dev/null
+++ b/src/tech-skills/constants/skill-translations.const.ts
@@ -0,0 +1,50 @@
+/**
+ * Skill Translations - Portuguese (Brazilian)
+ *
+ * Maps skill slugs to their Portuguese translations.
+ */
+
+export const SKILL_TRANSLATIONS: Record<string, string> = {
+  react: 'React',
+  angular: 'Angular',
+  'vue.js': 'Vue.js',
+  'node.js': 'Node.js',
+  express: 'Express',
+  django: 'Django',
+  flask: 'Flask',
+  spring: 'Spring',
+  docker: 'Docker',
+  kubernetes: 'Kubernetes',
+  aws: 'AWS',
+  azure: 'Azure',
+  git: 'Git',
+  mysql: 'MySQL',
+  postgresql: 'PostgreSQL',
+  mongodb: 'MongoDB',
+  redis: 'Redis',
+  linux: 'Linux',
+  agile: 'Ágil',
+  scrum: 'Scrum',
+  kanban: 'Kanban',
+  tdd: 'TDD',
+  bdd: 'BDD',
+  'ci-cd': 'CI/CD',
+  devops: 'DevOps',
+  microservices: 'Microsserviços',
+  serverless: 'Serverless',
+  rest: 'REST',
+  api: 'API',
+  'design-patterns': 'Padrões de Projeto',
+  'clean-architecture': 'Arquitetura Limpa',
+  'machine-learning': 'Machine Learning',
+  'artificial-intelligence': 'Inteligência Artificial',
+  'data-science': 'Ciência de Dados',
+  'big-data': 'Big Data',
+  blockchain: 'Blockchain',
+  security: 'Segurança',
+  testing: 'Testes',
+  frontend: 'Frontend',
+  backend: 'Backend',
+  fullstack: 'Fullstack',
+  mobile: 'Mobile',
+};
diff --git a/src/tech-skills/constants/stackoverflow-categories.const.ts b/src/tech-skills/constants/stackoverflow-categories.const.ts
new file mode 100644
index 0000000..b0f7b20
--- /dev/null
+++ b/src/tech-skills/constants/stackoverflow-categories.const.ts
@@ -0,0 +1,16 @@
+/**
+ * Stack Overflow Categories
+ * Re-exports skill categories for Stack Overflow tag parsing
+ */
+
+import { SKILL_CATEGORIES } from './skill-categories.const';
+import type { SkillType } from '../interfaces';
+
+export type StackOverflowCategory = { type: SkillType; niche: string | null };
+
+/**
+ * Stack Overflow specific category mappings
+ * Uses the general skill categories but can be extended with SO-specific mappings
+ */
+export const STACKOVERFLOW_CATEGORIES: Record<string, StackOverflowCategory> =
+  SKILL_CATEGORIES;
diff --git a/src/tech-skills/constants/stackoverflow-colors.const.ts b/src/tech-skills/constants/stackoverflow-colors.const.ts
new file mode 100644
index 0000000..a315d60
--- /dev/null
+++ b/src/tech-skills/constants/stackoverflow-colors.const.ts
@@ -0,0 +1,12 @@
+/**
+ * Stack Overflow Colors
+ * Re-exports skill colors for Stack Overflow tag parsing
+ */
+
+import { SKILL_COLORS } from './skill-colors.const';
+
+/**
+ * Stack Overflow specific color mappings
+ * Uses the general skill colors but can be extended with SO-specific mappings
+ */
+export const STACKOVERFLOW_COLORS: Record<string, string> = SKILL_COLORS;
diff --git a/src/tech-skills/constants/stackoverflow-translations.const.ts b/src/tech-skills/constants/stackoverflow-translations.const.ts
new file mode 100644
index 0000000..a0e5a39
--- /dev/null
+++ b/src/tech-skills/constants/stackoverflow-translations.const.ts
@@ -0,0 +1,13 @@
+/**
+ * Stack Overflow Translations
+ * Re-exports skill translations for Stack Overflow tag parsing
+ */
+
+import { SKILL_TRANSLATIONS } from './skill-translations.const';
+
+/**
+ * Stack Overflow specific translations
+ * Uses the general skill translations but can be extended with SO-specific mappings
+ */
+export const STACKOVERFLOW_TRANSLATIONS: Record<string, string> =
+  SKILL_TRANSLATIONS;
diff --git a/src/tech-skills/controllers/index.ts b/src/tech-skills/controllers/index.ts
new file mode 100644
index 0000000..bce2f03
--- /dev/null
+++ b/src/tech-skills/controllers/index.ts
@@ -0,0 +1,9 @@
+/**
+ * Tech Skills Controllers - Barrel Export
+ */
+
+export { TechSkillsSyncController } from './tech-skills-sync.controller';
+export { TechSkillsQueryController } from './tech-skills-query.controller';
+export { TechAreaController } from './tech-area.controller';
+export { TechNicheController } from './tech-niche.controller';
+export { TechSkillController } from './tech-skill.controller';
diff --git a/src/tech-skills/controllers/tech-area.controller.ts b/src/tech-skills/controllers/tech-area.controller.ts
new file mode 100644
index 0000000..ac5cf67
--- /dev/null
+++ b/src/tech-skills/controllers/tech-area.controller.ts
@@ -0,0 +1,41 @@
+/**
+ * Tech Area Controller
+ * Endpoints for tech areas
+ */
+
+import { Controller, Get, Param } from '@nestjs/common';
+import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
+import { TechAreaQueryService } from '../services/area-query.service';
+import { TechSkillsQueryService } from '../services/tech-skills-query.service';
+import { Public } from '../../auth/decorators/public.decorator';
+import type { TechAreaType } from '../interfaces';
+import type { TechAreaDto, TechNicheDto } from '../dtos';
+
+@ApiTags('tech-areas')
+@Controller('tech-areas')
+export class TechAreaController {
+  constructor(
+    private readonly areaQuery: TechAreaQueryService,
+    private readonly queryService: TechSkillsQueryService,
+  ) {}
+
+  /** Get all tech areas */
+  @Get()
+  @Public()
+  @ApiOperation({ summary: 'Get all tech areas' })
+  @ApiResponse({ status: 200, description: 'List of tech areas' })
+  async getAreas(): Promise<TechAreaDto[]> {
+    return this.areaQuery.getAllAreas();
+  }
+
+  /** Get niches by area type */
+  @Get(':areaType/niches')
+  @Public()
+  @ApiOperation({ summary: 'Get niches by area type' })
+  @ApiResponse({ status: 200, description: 'List of niches for the area' })
+  async getNichesByArea(
+    @Param('areaType') areaType: TechAreaType,
+  ): Promise<TechNicheDto[]> {
+    return this.queryService.getNichesByArea(areaType);
+  }
+}
diff --git a/src/tech-skills/controllers/tech-niche.controller.ts b/src/tech-skills/controllers/tech-niche.controller.ts
new file mode 100644
index 0000000..a8873bb
--- /dev/null
+++ b/src/tech-skills/controllers/tech-niche.controller.ts
@@ -0,0 +1,40 @@
+/**
+ * Tech Niche Controller
+ * Endpoints for tech niches
+ */
+
+import { Controller, Get, Param } from '@nestjs/common';
+import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
+import { TechNicheQueryService } from '../services/niche-query.service';
+import { TechSkillsQueryService } from '../services/tech-skills-query.service';
+import { Public } from '../../auth/decorators/public.decorator';
+import type { TechNicheDto, TechSkillDto } from '../dtos';
+
+@ApiTags('tech-niches')
+@Controller('tech-niches')
+export class TechNicheController {
+  constructor(
+    private readonly nicheQuery: TechNicheQueryService,
+    private readonly queryService: TechSkillsQueryService,
+  ) {}
+
+  /** Get all tech niches */
+  @Get()
+  @Public()
+  @ApiOperation({ summary: 'Get all tech niches' })
+  @ApiResponse({ status: 200, description: 'List of tech niches' })
+  async getNiches(): Promise<TechNicheDto[]> {
+    return this.nicheQuery.getAllNiches();
+  }
+
+  /** Get skills by niche */
+  @Get(':nicheSlug/skills')
+  @Public()
+  @ApiOperation({ summary: 'Get skills by niche slug' })
+  @ApiResponse({ status: 200, description: 'List of skills for the niche' })
+  async getSkillsByNiche(
+    @Param('nicheSlug') nicheSlug: string,
+  ): Promise<TechSkillDto[]> {
+    return this.queryService.getSkillsByNiche(nicheSlug);
+  }
+}
diff --git a/src/tech-skills/controllers/tech-skill.controller.ts b/src/tech-skills/controllers/tech-skill.controller.ts
new file mode 100644
index 0000000..00016f8
--- /dev/null
+++ b/src/tech-skills/controllers/tech-skill.controller.ts
@@ -0,0 +1,62 @@
+/**
+ * Tech Skill Controller
+ * Endpoints for tech skills
+ */
+
+import { Controller, Get, Query, Param } from '@nestjs/common';
+import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
+import { SkillQueryService } from '../services/skill-query.service';
+import { SkillSearchService } from '../services/skill-search.service';
+import { TechSkillsQueryService } from '../services/tech-skills-query.service';
+import { Public } from '../../auth/decorators/public.decorator';
+import type { SkillType } from '../interfaces';
+import type { TechSkillDto } from '../dtos';
+
+@ApiTags('tech-skills')
+@Controller('tech-skills')
+export class TechSkillController {
+  constructor(
+    private readonly skillQuery: SkillQueryService,
+    private readonly skillSearch: SkillSearchService,
+    private readonly queryService: TechSkillsQueryService,
+  ) {}
+
+  /** Get all skills */
+  @Get()
+  @Public()
+  @ApiOperation({ summary: 'Get all tech skills' })
+  @ApiResponse({ status: 200, description: 'List of tech skills' })
+  async getSkills(): Promise<TechSkillDto[]> {
+    return this.skillQuery.getAllSkills();
+  }
+
+  /** Search skills */
+  @Get('search')
+  @Public()
+  @ApiOperation({ summary: 'Search tech skills' })
+  @ApiResponse({ status: 200, description: 'Search results' })
+  async searchSkills(
+    @Query('q') query: string,
+    @Query('limit') limit?: string,
+  ): Promise<TechSkillDto[]> {
+    return this.skillSearch.searchSkills(
+      query,
+      limit ? parseInt(limit, 10) : 20,
+    );
+  }
+
+  /** Get skills by type */
+  @Get('type/:type')
+  @Public()
+  @ApiOperation({ summary: 'Get skills by type' })
+  @ApiResponse({ status: 200, description: 'List of skills by type' })
+  async getSkillsByType(
+    @Param('type') type: SkillType,
+    @Query('limit') limit?: string,
+  ): Promise<TechSkillDto[]> {
+    return this.queryService.getSkillsByType(
+      type,
+      limit ? parseInt(limit, 10) : 50,
+    );
+  }
+}
diff --git a/src/tech-skills/controllers/tech-skills-query.controller.ts b/src/tech-skills/controllers/tech-skills-query.controller.ts
new file mode 100644
index 0000000..b64343d
--- /dev/null
+++ b/src/tech-skills/controllers/tech-skills-query.controller.ts
@@ -0,0 +1,102 @@
+/**
+ * Tech Skills Query Controller
+ * Public API endpoints for querying tech skills, languages, areas, and niches
+ */
+
+import { Controller, Get, Query, Param } from '@nestjs/common';
+import { TechSkillsQueryService } from '../services/tech-skills-query.service';
+import { Public } from '../../auth/decorators/public.decorator';
+import type { TechAreaType, SkillType } from '../interfaces';
+
+@Controller('tech-skills')
+export class TechSkillsQueryController {
+  constructor(private readonly queryService: TechSkillsQueryService) {}
+
+  /** Get all tech areas */
+  @Get('areas')
+  @Public()
+  async getAreas() {
+    return this.queryService.getAllAreas();
+  }
+
+  /** Get all tech niches */
+  @Get('niches')
+  @Public()
+  async getNiches() {
+    return this.queryService.getAllNiches();
+  }
+
+  /** Get niches by area type */
+  @Get('areas/:areaType/niches')
+  @Public()
+  async getNichesByArea(@Param('areaType') areaType: TechAreaType) {
+    return this.queryService.getNichesByArea(areaType);
+  }
+
+  /** Get all programming languages */
+  @Get('languages')
+  @Public()
+  async getLanguages() {
+    return this.queryService.getAllLanguages();
+  }
+
+  /** Search programming languages */
+  @Get('languages/search')
+  @Public()
+  async searchLanguages(
+    @Query('q') query: string,
+    @Query('limit') limit?: string,
+  ) {
+    return this.queryService.searchLanguages(
+      query,
+      limit ? parseInt(limit, 10) : 20,
+    );
+  }
+
+  /** Get all skills */
+  @Get('skills')
+  @Public()
+  async getSkills() {
+    return this.queryService.getAllSkills();
+  }
+
+  /** Search skills */
+  @Get('skills/search')
+  @Public()
+  async searchSkills(
+    @Query('q') query: string,
+    @Query('limit') limit?: string,
+  ) {
+    return this.queryService.searchSkills(
+      query,
+      limit ? parseInt(limit, 10) : 20,
+    );
+  }
+
+  /** Get skills by niche */
+  @Get('niches/:nicheSlug/skills')
+  @Public()
+  async getSkillsByNiche(@Param('nicheSlug') nicheSlug: string) {
+    return this.queryService.getSkillsByNiche(nicheSlug);
+  }
+
+  /** Get skills by type */
+  @Get('skills/type/:type')
+  @Public()
+  async getSkillsByType(
+    @Param('type') type: SkillType,
+    @Query('limit') limit?: string,
+  ) {
+    return this.queryService.getSkillsByType(
+      type,
+      limit ? parseInt(limit, 10) : 50,
+    );
+  }
+
+  /** Combined search (languages + skills) */
+  @Get('search')
+  @Public()
+  async searchAll(@Query('q') query: string, @Query('limit') limit?: string) {
+    return this.queryService.searchAll(query, limit ? parseInt(limit, 10) : 20);
+  }
+}
diff --git a/src/tech-skills/controllers/tech-skills-sync.controller.ts b/src/tech-skills/controllers/tech-skills-sync.controller.ts
new file mode 100644
index 0000000..41bf551
--- /dev/null
+++ b/src/tech-skills/controllers/tech-skills-sync.controller.ts
@@ -0,0 +1,36 @@
+/**
+ * Tech Skills Sync Controller
+ * API endpoints for tech skills synchronization (Admin/Internal only)
+ */
+
+import {
+  Controller,
+  Post,
+  UseGuards,
+  HttpCode,
+  HttpStatus,
+} from '@nestjs/common';
+import { TechSkillsSyncService } from '../services/tech-skills-sync.service';
+import { InternalAuthGuard } from '../../mec-sync/guards/internal-auth.guard';
+import { Public } from '../../auth/decorators/public.decorator';
+
+@Controller('tech-skills')
+export class TechSkillsSyncController {
+  constructor(private readonly syncService: TechSkillsSyncService) {}
+
+  /**
+   * Trigger manual sync of tech skills from external sources
+   * Requires internal API token (bypasses JWT auth)
+   */
+  @Post('sync')
+  @Public() // Bypass global JWT guard
+  @UseGuards(InternalAuthGuard) // Use internal token instead
+  @HttpCode(HttpStatus.OK)
+  async triggerSync() {
+    const result = await this.syncService.runSync();
+    return {
+      message: 'Tech skills sync completed',
+      result,
+    };
+  }
+}
diff --git a/src/tech-skills/data/index.ts b/src/tech-skills/data/index.ts
new file mode 100644
index 0000000..17c819f
--- /dev/null
+++ b/src/tech-skills/data/index.ts
@@ -0,0 +1,10 @@
+/**
+ * Tech Skills Data Index
+ */
+
+export {
+  TECH_AREAS,
+  TECH_NICHES,
+  TechAreaData,
+  TechNicheData,
+} from './tech-skills.data';
diff --git a/src/tech-skills/data/tech-skills.data.ts b/src/tech-skills/data/tech-skills.data.ts
new file mode 100644
index 0000000..0032aec
--- /dev/null
+++ b/src/tech-skills/data/tech-skills.data.ts
@@ -0,0 +1,35 @@
+/**
+ * Tech Skills Data
+ * Single Responsibility: Load tech skills configuration data
+ */
+
+import { TechAreaType } from '../interfaces';
+import techSkillsData from '../../../data/tech-skills-data.json';
+
+export interface TechAreaData {
+  type: TechAreaType;
+  nameEn: string;
+  namePtBr: string;
+  descriptionEn: string;
+  descriptionPtBr: string;
+  icon: string;
+  color: string;
+  order: number;
+}
+
+export interface TechNicheData {
+  slug: string;
+  areaType: TechAreaType;
+  nameEn: string;
+  namePtBr: string;
+  descriptionEn: string;
+  descriptionPtBr: string;
+  icon: string;
+  color: string;
+  order: number;
+}
+
+export const TECH_AREAS: TechAreaData[] =
+  techSkillsData.techAreas as TechAreaData[];
+export const TECH_NICHES: TechNicheData[] =
+  techSkillsData.techNiches as TechNicheData[];
diff --git a/src/tech-skills/dtos/index.ts b/src/tech-skills/dtos/index.ts
new file mode 100644
index 0000000..e7433fa
--- /dev/null
+++ b/src/tech-skills/dtos/index.ts
@@ -0,0 +1,9 @@
+/**
+ * Tech Skills DTOs
+ * Data transfer objects for tech skills module
+ */
+
+export * from './tech-area.dto';
+export * from './tech-niche.dto';
+export * from './tech-skill.dto';
+export * from './programming-language.dto';
diff --git a/src/tech-skills/dtos/programming-language.dto.ts b/src/tech-skills/dtos/programming-language.dto.ts
new file mode 100644
index 0000000..3eb6e78
--- /dev/null
+++ b/src/tech-skills/dtos/programming-language.dto.ts
@@ -0,0 +1,18 @@
+/**
+ * Programming Language DTO
+ * Data transfer object for programming languages
+ */
+
+export interface ProgrammingLanguageDto {
+  id: string;
+  slug: string;
+  nameEn: string;
+  namePtBr: string;
+  color: string | null;
+  website: string | null;
+  aliases: string[];
+  fileExtensions: string[];
+  paradigms: string[];
+  typing: string | null;
+  popularity: number;
+}
diff --git a/src/tech-skills/dtos/tech-area.dto.ts b/src/tech-skills/dtos/tech-area.dto.ts
new file mode 100644
index 0000000..2237ef8
--- /dev/null
+++ b/src/tech-skills/dtos/tech-area.dto.ts
@@ -0,0 +1,18 @@
+/**
+ * Tech Area DTO
+ * Data transfer object for tech areas
+ */
+
+import type { TechAreaType } from '../interfaces';
+
+export interface TechAreaDto {
+  id: string;
+  type: TechAreaType;
+  nameEn: string;
+  namePtBr: string;
+  descriptionEn: string | null;
+  descriptionPtBr: string | null;
+  icon: string | null;
+  color: string | null;
+  order: number;
+}
diff --git a/src/tech-skills/dtos/tech-niche.dto.ts b/src/tech-skills/dtos/tech-niche.dto.ts
new file mode 100644
index 0000000..f000b36
--- /dev/null
+++ b/src/tech-skills/dtos/tech-niche.dto.ts
@@ -0,0 +1,19 @@
+/**
+ * Tech Niche DTO
+ * Data transfer object for tech niches
+ */
+
+import type { TechAreaType } from '../interfaces';
+
+export interface TechNicheDto {
+  id: string;
+  slug: string;
+  nameEn: string;
+  namePtBr: string;
+  descriptionEn: string | null;
+  descriptionPtBr: string | null;
+  icon: string | null;
+  color: string | null;
+  order: number;
+  areaType: TechAreaType;
+}
diff --git a/src/tech-skills/dtos/tech-skill.dto.ts b/src/tech-skills/dtos/tech-skill.dto.ts
new file mode 100644
index 0000000..a493f7c
--- /dev/null
+++ b/src/tech-skills/dtos/tech-skill.dto.ts
@@ -0,0 +1,46 @@
+/**
+ * Tech Skill DTO
+ * Data transfer object for tech skills
+ */
+
+import type { SkillType } from '../interfaces';
+
+export interface NicheReferenceDto {
+  slug: string;
+  nameEn: string;
+  namePtBr: string;
+}
+
+export interface TechSkillDto {
+  id: string;
+  slug: string;
+  nameEn: string;
+  namePtBr: string;
+  type: SkillType;
+  icon: string | null;
+  color: string | null;
+  website: string | null;
+  aliases: string[];
+  popularity: number;
+  niche: NicheReferenceDto | null;
+}
+
+/**
+ * Raw skill query result from database
+ * Used internally for raw SQL queries
+ */
+export interface TechSkillRawQueryResult {
+  id: string;
+  slug: string;
+  nameEn: string;
+  namePtBr: string;
+  type: string;
+  icon: string | null;
+  color: string | null;
+  website: string | null;
+  aliases: string[];
+  popularity: number;
+  niche_slug: string | null;
+  niche_nameEn: string | null;
+  niche_namePtBr: string | null;
+}
diff --git a/src/tech-skills/interfaces/cache.config.ts b/src/tech-skills/interfaces/cache.config.ts
new file mode 100644
index 0000000..10aae06
--- /dev/null
+++ b/src/tech-skills/interfaces/cache.config.ts
@@ -0,0 +1,24 @@
+/**
+ * Tech Skills Cache Configuration
+ * Cache keys and TTL values for tech skills module
+ */
+
+export const TECH_SKILLS_CACHE_KEYS = {
+  LANGUAGES_LIST: 'tech:languages:list',
+  SKILLS_LIST: 'tech:skills:list',
+  SKILLS_BY_NICHE: 'tech:skills:niche:',
+  SKILLS_BY_AREA: 'tech:skills:area:',
+  SKILLS_SEARCH: 'tech:skills:search:',
+  NICHES_LIST: 'tech:niches:list',
+  AREAS_LIST: 'tech:areas:list',
+} as const;
+
+export const TECH_SKILLS_CACHE_TTL = {
+  LANGUAGES_LIST: 86400, // 24 hours
+  SKILLS_LIST: 86400,
+  SKILLS_BY_NICHE: 86400,
+  SKILLS_BY_AREA: 86400,
+  SKILLS_SEARCH: 3600, // 1 hour
+  NICHES_LIST: 86400,
+  AREAS_LIST: 86400,
+} as const;
diff --git a/src/tech-skills/interfaces/github-linguist.interface.ts b/src/tech-skills/interfaces/github-linguist.interface.ts
new file mode 100644
index 0000000..88e487b
--- /dev/null
+++ b/src/tech-skills/interfaces/github-linguist.interface.ts
@@ -0,0 +1,24 @@
+/**
+ * GitHub Linguist Types
+ * Types for parsing GitHub's linguist repository
+ */
+
+export interface GithubLanguage {
+  type: 'programming' | 'data' | 'markup' | 'prose';
+  color?: string;
+  extensions?: string[];
+  filenames?: string[];
+  aliases?: string[];
+  interpreters?: string[];
+  tm_scope?: string;
+  ace_mode?: string;
+  codemirror_mode?: string;
+  codemirror_mime_type?: string;
+  language_id?: number;
+  group?: string;
+  wrap?: boolean;
+}
+
+export interface GithubLanguagesYml {
+  [name: string]: GithubLanguage;
+}
diff --git a/src/tech-skills/interfaces/index.ts b/src/tech-skills/interfaces/index.ts
index 536e63a..4ed4823 100644
--- a/src/tech-skills/interfaces/index.ts
+++ b/src/tech-skills/interfaces/index.ts
@@ -1 +1,14 @@
+/**
+ * Tech Skills Interfaces - Barrel Export
+ */
+
+// Re-export from original file for backward compatibility
 export * from './tech-skills.interface';
+
+// New modular exports
+export * from './github-linguist.interface';
+export * from './stackoverflow.interface';
+export * from './tech-skill-types.interface';
+export * from './parsed-skill.interface';
+export * from './sync-result.interface';
+export * from './cache.config';
diff --git a/src/tech-skills/interfaces/parsed-skill.interface.ts b/src/tech-skills/interfaces/parsed-skill.interface.ts
new file mode 100644
index 0000000..c68b0ad
--- /dev/null
+++ b/src/tech-skills/interfaces/parsed-skill.interface.ts
@@ -0,0 +1,33 @@
+/**
+ * Parsed Skill Types
+ * Types for parsed language and skill data from external sources
+ */
+
+import type { SkillType } from './tech-skill-types.interface';
+
+export interface ParsedLanguage {
+  slug: string;
+  nameEn: string;
+  namePtBr: string;
+  color: string | null;
+  extensions: string[];
+  aliases: string[];
+  paradigms: string[];
+  typing: string | null;
+  website: string | null;
+  popularity: number;
+}
+
+export interface ParsedSkill {
+  slug: string;
+  nameEn: string;
+  namePtBr: string;
+  type: SkillType;
+  nicheSlug: string | null;
+  color: string | null;
+  icon: string | null;
+  website: string | null;
+  aliases: string[];
+  keywords: string[];
+  popularity: number;
+}
diff --git a/src/tech-skills/interfaces/stackoverflow.interface.ts b/src/tech-skills/interfaces/stackoverflow.interface.ts
new file mode 100644
index 0000000..6150ae7
--- /dev/null
+++ b/src/tech-skills/interfaces/stackoverflow.interface.ts
@@ -0,0 +1,19 @@
+/**
+ * Stack Overflow Types
+ * Types for parsing Stack Overflow tags API
+ */
+
+export interface StackOverflowTag {
+  name: string;
+  count: number;
+  has_synonyms: boolean;
+  is_moderator_only: boolean;
+  is_required: boolean;
+}
+
+export interface StackOverflowResponse {
+  items: StackOverflowTag[];
+  has_more: boolean;
+  quota_max: number;
+  quota_remaining: number;
+}
diff --git a/src/tech-skills/interfaces/sync-result.interface.ts b/src/tech-skills/interfaces/sync-result.interface.ts
new file mode 100644
index 0000000..f64a858
--- /dev/null
+++ b/src/tech-skills/interfaces/sync-result.interface.ts
@@ -0,0 +1,14 @@
+/**
+ * Sync Result Types
+ * Types for tech skills sync operation results
+ */
+
+export interface TechSkillsSyncResult {
+  languagesInserted: number;
+  languagesUpdated: number;
+  skillsInserted: number;
+  skillsUpdated: number;
+  areasCreated: number;
+  nichesCreated: number;
+  errors: string[];
+}
diff --git a/src/tech-skills/interfaces/tech-skill-types.interface.ts b/src/tech-skills/interfaces/tech-skill-types.interface.ts
new file mode 100644
index 0000000..0a7741b
--- /dev/null
+++ b/src/tech-skills/interfaces/tech-skill-types.interface.ts
@@ -0,0 +1,27 @@
+/**
+ * Tech Skills Enum Types
+ * Type definitions for tech areas and skill types
+ */
+
+export type TechAreaType =
+  | 'DEVELOPMENT'
+  | 'DEVOPS'
+  | 'DATA'
+  | 'SECURITY'
+  | 'DESIGN'
+  | 'PRODUCT'
+  | 'QA'
+  | 'INFRASTRUCTURE'
+  | 'OTHER';
+
+export type SkillType =
+  | 'LANGUAGE'
+  | 'FRAMEWORK'
+  | 'LIBRARY'
+  | 'DATABASE'
+  | 'TOOL'
+  | 'PLATFORM'
+  | 'METHODOLOGY'
+  | 'SOFT_SKILL'
+  | 'CERTIFICATION'
+  | 'OTHER';
diff --git a/src/tech-skills/interfaces/tech-skills.interface.ts b/src/tech-skills/interfaces/tech-skills.interface.ts
index 6f09e54..668f900 100644
--- a/src/tech-skills/interfaces/tech-skills.interface.ts
+++ b/src/tech-skills/interfaces/tech-skills.interface.ts
@@ -1,125 +1,29 @@
 /**
  * Tech Skills Interfaces
- * Types for tech skills synchronization
+ * Re-exports for backward compatibility
+ * @deprecated Import from specific interface files instead
  */
 
-// GitHub Linguist language structure
-export interface GithubLanguage {
-  type: 'programming' | 'data' | 'markup' | 'prose';
-  color?: string;
-  extensions?: string[];
-  filenames?: string[];
-  aliases?: string[];
-  interpreters?: string[];
-  tm_scope?: string;
-  ace_mode?: string;
-  codemirror_mode?: string;
-  codemirror_mime_type?: string;
-  language_id?: number;
-  group?: string;
-  wrap?: boolean;
-}
+// GitHub Linguist types
+export type {
+  GithubLanguage,
+  GithubLanguagesYml,
+} from './github-linguist.interface';
 
-export interface GithubLanguagesYml {
-  [name: string]: GithubLanguage;
-}
+// Stack Overflow types
+export type {
+  StackOverflowTag,
+  StackOverflowResponse,
+} from './stackoverflow.interface';
 
-// Stack Overflow tag structure
-export interface StackOverflowTag {
-  name: string;
-  count: number;
-  has_synonyms: boolean;
-  is_moderator_only: boolean;
-  is_required: boolean;
-}
+// Skill type enums
+export type { TechAreaType, SkillType } from './tech-skill-types.interface';
 
-export interface StackOverflowResponse {
-  items: StackOverflowTag[];
-  has_more: boolean;
-  quota_max: number;
-  quota_remaining: number;
-}
-
-// Tech area types
-export type TechAreaType =
-  | 'DEVELOPMENT'
-  | 'DEVOPS'
-  | 'DATA'
-  | 'SECURITY'
-  | 'DESIGN'
-  | 'PRODUCT'
-  | 'QA'
-  | 'INFRASTRUCTURE'
-  | 'OTHER';
-
-export type SkillType =
-  | 'LANGUAGE'
-  | 'FRAMEWORK'
-  | 'LIBRARY'
-  | 'DATABASE'
-  | 'TOOL'
-  | 'PLATFORM'
-  | 'METHODOLOGY'
-  | 'SOFT_SKILL'
-  | 'CERTIFICATION'
-  | 'OTHER';
-
-// Parsed skill data
-export interface ParsedLanguage {
-  slug: string;
-  nameEn: string;
-  namePtBr: string;
-  color: string | null;
-  extensions: string[];
-  aliases: string[];
-  paradigms: string[];
-  typing: string | null;
-  website: string | null;
-  popularity: number;
-}
-
-export interface ParsedSkill {
-  slug: string;
-  nameEn: string;
-  namePtBr: string;
-  type: SkillType;
-  nicheSlug: string | null;
-  color: string | null;
-  icon: string | null;
-  website: string | null;
-  aliases: string[];
-  keywords: string[];
-  popularity: number;
-}
+// Parsed data types
+export type { ParsedLanguage, ParsedSkill } from './parsed-skill.interface';
 
 // Sync result
-export interface TechSkillsSyncResult {
-  languagesInserted: number;
-  languagesUpdated: number;
-  skillsInserted: number;
-  skillsUpdated: number;
-  areasCreated: number;
-  nichesCreated: number;
-  errors: string[];
-}
-
-// Cache keys
-export const TECH_SKILLS_CACHE_KEYS = {
-  LANGUAGES_LIST: 'tech:languages:list',
-  SKILLS_LIST: 'tech:skills:list',
-  SKILLS_BY_NICHE: 'tech:skills:niche:',
-  SKILLS_BY_AREA: 'tech:skills:area:',
-  SKILLS_SEARCH: 'tech:skills:search:',
-  NICHES_LIST: 'tech:niches:list',
-  AREAS_LIST: 'tech:areas:list',
-};
+export type { TechSkillsSyncResult } from './sync-result.interface';
 
-export const TECH_SKILLS_CACHE_TTL = {
-  LANGUAGES_LIST: 86400, // 24 hours
-  SKILLS_LIST: 86400,
-  SKILLS_BY_NICHE: 86400,
-  SKILLS_BY_AREA: 86400,
-  SKILLS_SEARCH: 3600, // 1 hour
-  NICHES_LIST: 86400,
-  AREAS_LIST: 86400,
-};
+// Cache configuration
+export { TECH_SKILLS_CACHE_KEYS, TECH_SKILLS_CACHE_TTL } from './cache.config';
diff --git a/src/tech-skills/services/area-query.service.ts b/src/tech-skills/services/area-query.service.ts
new file mode 100644
index 0000000..cd2b7ba
--- /dev/null
+++ b/src/tech-skills/services/area-query.service.ts
@@ -0,0 +1,47 @@
+/**
+ * Tech Area Query Service
+ * Handles cached queries for tech areas
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { CacheService } from '../../common/cache/cache.service';
+import { TECH_SKILLS_CACHE_KEYS, TECH_SKILLS_CACHE_TTL } from '../interfaces';
+import type { TechAreaDto } from '../dtos';
+
+@Injectable()
+export class TechAreaQueryService {
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly cache: CacheService,
+  ) {}
+
+  /**
+   * Get all tech areas
+   */
+  async getAllAreas(): Promise<TechAreaDto[]> {
+    const cacheKey = TECH_SKILLS_CACHE_KEYS.AREAS_LIST;
+
+    const cached = await this.cache.get<TechAreaDto[]>(cacheKey);
+    if (cached) return cached;
+
+    const areas = await this.prisma.techArea.findMany({
+      where: { isActive: true },
+      orderBy: { order: 'asc' },
+      select: {
+        id: true,
+        type: true,
+        nameEn: true,
+        namePtBr: true,
+        descriptionEn: true,
+        descriptionPtBr: true,
+        icon: true,
+        color: true,
+        order: true,
+      },
+    });
+
+    await this.cache.set(cacheKey, areas, TECH_SKILLS_CACHE_TTL.AREAS_LIST);
+    return areas as TechAreaDto[];
+  }
+}
diff --git a/src/tech-skills/services/github-linguist-parser.service.ts b/src/tech-skills/services/github-linguist-parser.service.ts
index 840bf03..c9b3622 100644
--- a/src/tech-skills/services/github-linguist-parser.service.ts
+++ b/src/tech-skills/services/github-linguist-parser.service.ts
@@ -7,194 +7,22 @@ import { Injectable } from '@nestjs/common';
 import { AppLoggerService } from '../../common/logger/logger.service';
 import * as yaml from 'js-yaml';
 import type { GithubLanguagesYml, ParsedLanguage } from '../interfaces';
-
-// Portuguese translations for common languages
-const LANGUAGE_TRANSLATIONS: Record<string, string> = {
-  JavaScript: 'JavaScript',
-  TypeScript: 'TypeScript',
-  Python: 'Python',
-  Java: 'Java',
-  'C#': 'C#',
-  'C++': 'C++',
-  C: 'C',
-  Go: 'Go',
-  Rust: 'Rust',
-  Ruby: 'Ruby',
-  PHP: 'PHP',
-  Swift: 'Swift',
-  Kotlin: 'Kotlin',
-  Scala: 'Scala',
-  R: 'R',
-  MATLAB: 'MATLAB',
-  Shell: 'Shell',
-  Bash: 'Bash',
-  PowerShell: 'PowerShell',
-  SQL: 'SQL',
-  HTML: 'HTML',
-  CSS: 'CSS',
-  Sass: 'Sass',
-  SCSS: 'SCSS',
-  Less: 'Less',
-  'Objective-C': 'Objective-C',
-  Dart: 'Dart',
-  Lua: 'Lua',
-  Perl: 'Perl',
-  Haskell: 'Haskell',
-  Elixir: 'Elixir',
-  Erlang: 'Erlang',
-  Clojure: 'Clojure',
-  'F#': 'F#',
-  Assembly: 'Assembly',
-  COBOL: 'COBOL',
-  Fortran: 'Fortran',
-  Pascal: 'Pascal',
-  Delphi: 'Delphi',
-  'Visual Basic': 'Visual Basic',
-  VBA: 'VBA',
-  Groovy: 'Groovy',
-  Julia: 'Julia',
-  Zig: 'Zig',
-  Nim: 'Nim',
-  Crystal: 'Crystal',
-  V: 'V',
-  Solidity: 'Solidity',
-  Move: 'Move',
-  Cairo: 'Cairo',
-  Vyper: 'Vyper',
-};
-
-// Language paradigms mapping
-const LANGUAGE_PARADIGMS: Record<string, string[]> = {
-  JavaScript: [
-    'multi-paradigm',
-    'event-driven',
-    'functional',
-    'imperative',
-    'object-oriented',
-  ],
-  TypeScript: ['multi-paradigm', 'object-oriented', 'functional'],
-  Python: ['multi-paradigm', 'object-oriented', 'functional', 'imperative'],
-  Java: ['object-oriented', 'imperative'],
-  'C#': ['multi-paradigm', 'object-oriented', 'functional'],
-  'C++': ['multi-paradigm', 'object-oriented', 'procedural', 'functional'],
-  C: ['procedural', 'imperative'],
-  Go: ['concurrent', 'imperative', 'structured'],
-  Rust: ['multi-paradigm', 'concurrent', 'functional', 'imperative'],
-  Ruby: ['multi-paradigm', 'object-oriented', 'functional'],
-  PHP: ['multi-paradigm', 'object-oriented', 'procedural'],
-  Swift: [
-    'multi-paradigm',
-    'object-oriented',
-    'functional',
-    'protocol-oriented',
-  ],
-  Kotlin: ['multi-paradigm', 'object-oriented', 'functional'],
-  Scala: ['multi-paradigm', 'object-oriented', 'functional'],
-  Haskell: ['purely functional', 'lazy evaluation'],
-  Elixir: ['functional', 'concurrent', 'distributed'],
-  Erlang: ['functional', 'concurrent', 'distributed'],
-  Clojure: ['functional', 'concurrent', 'lisp'],
-  'F#': ['functional', 'object-oriented', 'imperative'],
-  R: ['multi-paradigm', 'functional', 'object-oriented'],
-  Julia: ['multi-paradigm', 'functional', 'multiple dispatch'],
-  Dart: ['object-oriented', 'class-based'],
-  Lua: ['multi-paradigm', 'scripting', 'imperative'],
-};
-
-// Typing system mapping
-const LANGUAGE_TYPING: Record<string, string> = {
-  JavaScript: 'dynamic',
-  TypeScript: 'static',
-  Python: 'dynamic',
-  Java: 'static',
-  'C#': 'static',
-  'C++': 'static',
-  C: 'static',
-  Go: 'static',
-  Rust: 'static',
-  Ruby: 'dynamic',
-  PHP: 'dynamic',
-  Swift: 'static',
-  Kotlin: 'static',
-  Scala: 'static',
-  Haskell: 'static',
-  Elixir: 'dynamic',
-  Erlang: 'dynamic',
-  Clojure: 'dynamic',
-  'F#': 'static',
-  R: 'dynamic',
-  Julia: 'dynamic',
-  Dart: 'static',
-  Lua: 'dynamic',
-};
-
-// Popular languages for ordering
-const POPULARITY_ORDER: string[] = [
-  'JavaScript',
-  'Python',
-  'TypeScript',
-  'Java',
-  'C#',
-  'C++',
-  'PHP',
-  'C',
-  'Go',
-  'Rust',
-  'Ruby',
-  'Swift',
-  'Kotlin',
-  'Dart',
-  'Scala',
-  'R',
-  'Shell',
-  'PowerShell',
-  'SQL',
-  'HTML',
-  'CSS',
-  'Sass',
-  'SCSS',
-  'Objective-C',
-  'Perl',
-  'Haskell',
-  'Elixir',
-  'Erlang',
-  'Clojure',
-  'F#',
-  'Lua',
-  'Julia',
-  'MATLAB',
-  'Groovy',
-  'Assembly',
-  'COBOL',
-  'Fortran',
-  'Pascal',
-  'Visual Basic',
-  'VBA',
-  'Solidity',
-  'Move',
-  'Cairo',
-  'Vyper',
-  'Zig',
-  'Nim',
-  'Crystal',
-  'V',
-];
+import {
+  LANGUAGE_METADATA,
+  GITHUB_LINGUIST_URL,
+} from '../constants/language-metadata.const';
+import { createLanguageSlug } from '../utils';
 
 @Injectable()
 export class GithubLinguistParserService {
-  private readonly LINGUIST_URL =
-    'https://raw.githubusercontent.com/github/linguist/master/lib/linguist/languages.yml';
-
   constructor(private readonly logger: AppLoggerService) {}
 
-  /**
-   * Fetch and parse languages from GitHub Linguist
-   */
+  /** Fetch and parse languages from GitHub Linguist */
   async fetchAndParse(): Promise<ParsedLanguage[]> {
     this.logger.log('Fetching GitHub Linguist languages...');
 
     try {
-      const response = await fetch(this.LINGUIST_URL);
+      const response = await fetch(GITHUB_LINGUIST_URL);
       if (!response.ok) {
         throw new Error(
           `Failed to fetch: ${response.status} ${response.statusText}`,
@@ -206,100 +34,38 @@ export class GithubLinguistParserService {
 
       return this.parseLanguages(languages);
     } catch (error) {
-      this.logger.error('Failed to fetch GitHub Linguist', error);
-      throw error;
+      const err = error instanceof Error ? error : new Error(String(error));
+      this.logger.error('Failed to fetch GitHub Linguist', err.message);
+      throw err;
     }
   }
 
-  /**
-   * Parse YAML content into structured language data
-   */
+  /** Parse YAML content into structured language data */
   private parseLanguages(languages: GithubLanguagesYml): ParsedLanguage[] {
     const parsed: ParsedLanguage[] = [];
 
     for (const [name, lang] of Object.entries(languages)) {
-      // Only include programming languages (skip data, markup, prose)
-      if (lang.type !== 'programming') {
-        continue;
-      }
+      if (lang.type !== 'programming') continue;
 
-      const slug = this.createSlug(name);
-      const popularityIndex = POPULARITY_ORDER.indexOf(name);
+      const popularityIndex = LANGUAGE_METADATA.popularityOrder.indexOf(name);
 
       parsed.push({
-        slug,
+        slug: createLanguageSlug(name),
         nameEn: name,
-        namePtBr: LANGUAGE_TRANSLATIONS[name] || name,
-        color: lang.color || null,
-        extensions: lang.extensions || [],
-        aliases: lang.aliases || [],
-        paradigms: LANGUAGE_PARADIGMS[name] || [],
-        typing: LANGUAGE_TYPING[name] || null,
-        website: this.getLanguageWebsite(name),
+        namePtBr: LANGUAGE_METADATA.translations[name] ?? name,
+        color: lang.color ?? null,
+        extensions: lang.extensions ?? [],
+        aliases: lang.aliases ?? [],
+        paradigms: LANGUAGE_METADATA.paradigms[name] ?? [],
+        typing: LANGUAGE_METADATA.typing[name] ?? null,
+        website: LANGUAGE_METADATA.websites[name] ?? null,
         popularity: popularityIndex >= 0 ? 1000 - popularityIndex : 0,
       });
     }
 
-    // Sort by popularity
     parsed.sort((a, b) => b.popularity - a.popularity);
 
     this.logger.log(`Parsed ${parsed.length} programming languages`);
     return parsed;
   }
-
-  /**
-   * Create URL-safe slug from language name
-   */
-  private createSlug(name: string): string {
-    return name
-      .toLowerCase()
-      .replace(/[#+]+/g, (match) => {
-        if (match === '#') return 'sharp';
-        if (match === '++') return 'plusplus';
-        if (match === '+') return 'plus';
-        return '';
-      })
-      .replace(/\s+/g, '-')
-      .replace(/[^a-z0-9-]/g, '')
-      .replace(/-+/g, '-')
-      .replace(/^-|-$/g, '');
-  }
-
-  /**
-   * Get official website for language
-   */
-  private getLanguageWebsite(name: string): string | null {
-    const websites: Record<string, string> = {
-      JavaScript: 'https://developer.mozilla.org/en-US/docs/Web/JavaScript',
-      TypeScript: 'https://www.typescriptlang.org/',
-      Python: 'https://www.python.org/',
-      Java: 'https://www.java.com/',
-      'C#': 'https://docs.microsoft.com/en-us/dotnet/csharp/',
-      'C++': 'https://isocpp.org/',
-      C: 'https://en.cppreference.com/w/c',
-      Go: 'https://go.dev/',
-      Rust: 'https://www.rust-lang.org/',
-      Ruby: 'https://www.ruby-lang.org/',
-      PHP: 'https://www.php.net/',
-      Swift: 'https://swift.org/',
-      Kotlin: 'https://kotlinlang.org/',
-      Scala: 'https://www.scala-lang.org/',
-      R: 'https://www.r-project.org/',
-      Haskell: 'https://www.haskell.org/',
-      Elixir: 'https://elixir-lang.org/',
-      Erlang: 'https://www.erlang.org/',
-      Clojure: 'https://clojure.org/',
-      'F#': 'https://fsharp.org/',
-      Julia: 'https://julialang.org/',
-      Dart: 'https://dart.dev/',
-      Lua: 'https://www.lua.org/',
-      Perl: 'https://www.perl.org/',
-      Zig: 'https://ziglang.org/',
-      Nim: 'https://nim-lang.org/',
-      Crystal: 'https://crystal-lang.org/',
-      Solidity: 'https://soliditylang.org/',
-    };
-
-    return websites[name] || null;
-  }
 }
diff --git a/src/tech-skills/services/index.ts b/src/tech-skills/services/index.ts
index 5f6d3f6..943776a 100644
--- a/src/tech-skills/services/index.ts
+++ b/src/tech-skills/services/index.ts
@@ -2,3 +2,8 @@ export * from './github-linguist-parser.service';
 export * from './stackoverflow-parser.service';
 export * from './tech-skills-sync.service';
 export * from './tech-skills-query.service';
+export * from './area-query.service';
+export * from './niche-query.service';
+export * from './language-query.service';
+export * from './skill-query.service';
+export * from './skill-search.service';
diff --git a/src/tech-skills/services/language-query.service.ts b/src/tech-skills/services/language-query.service.ts
new file mode 100644
index 0000000..2f544f7
--- /dev/null
+++ b/src/tech-skills/services/language-query.service.ts
@@ -0,0 +1,99 @@
+/**
+ * Programming Language Query Service
+ * Handles cached queries for programming languages
+ */
+
+import { Injectable } from '@nestjs/common';
+import * as crypto from 'crypto';
+import { PrismaService } from '../../prisma/prisma.service';
+import { CacheService } from '../../common/cache/cache.service';
+import { API_LIMITS } from '../../common/constants/app.constants';
+import { TECH_SKILLS_CACHE_KEYS, TECH_SKILLS_CACHE_TTL } from '../interfaces';
+import type { ProgrammingLanguageDto } from '../dtos';
+
+@Injectable()
+export class LanguageQueryService {
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly cache: CacheService,
+  ) {}
+
+  /**
+   * Get all programming languages
+   */
+  async getAllLanguages(): Promise<ProgrammingLanguageDto[]> {
+    const cacheKey = TECH_SKILLS_CACHE_KEYS.LANGUAGES_LIST;
+
+    const cached = await this.cache.get<ProgrammingLanguageDto[]>(cacheKey);
+    if (cached) return cached;
+
+    const languages = await this.prisma.programmingLanguage.findMany({
+      where: { isActive: true },
+      orderBy: { popularity: 'desc' },
+      select: {
+        id: true,
+        slug: true,
+        nameEn: true,
+        namePtBr: true,
+        color: true,
+        website: true,
+        aliases: true,
+        fileExtensions: true,
+        paradigms: true,
+        typing: true,
+        popularity: true,
+      },
+    });
+
+    await this.cache.set(
+      cacheKey,
+      languages,
+      TECH_SKILLS_CACHE_TTL.LANGUAGES_LIST,
+    );
+    return languages;
+  }
+
+  /**
+   * Search programming languages with accent-insensitive matching
+   */
+  async searchLanguages(
+    query: string,
+    limit = 20,
+  ): Promise<ProgrammingLanguageDto[]> {
+    const normalizedQuery = query.toLowerCase().trim();
+    if (normalizedQuery.length < 1) return [];
+
+    const queryHash = crypto
+      .createHash('md5')
+      .update(`lang:${normalizedQuery}`)
+      .digest('hex')
+      .slice(0, API_LIMITS.MAX_SUGGESTIONS);
+    const cacheKey = `${TECH_SKILLS_CACHE_KEYS.SKILLS_SEARCH}${queryHash}`;
+
+    const cached = await this.cache.get<ProgrammingLanguageDto[]>(cacheKey);
+    if (cached) return cached;
+
+    const languages = await this.prisma.$queryRaw<ProgrammingLanguageDto[]>`
+      SELECT 
+        id, slug, "nameEn", "namePtBr", color, website,
+        aliases, "fileExtensions", paradigms, typing, popularity
+      FROM "ProgrammingLanguage"
+      WHERE "isActive" = true
+        AND (
+          immutable_unaccent(lower("nameEn")) LIKE '%' || immutable_unaccent(lower(${normalizedQuery})) || '%'
+          OR immutable_unaccent(lower("namePtBr")) LIKE '%' || immutable_unaccent(lower(${normalizedQuery})) || '%'
+          OR slug LIKE '%' || ${normalizedQuery} || '%'
+          OR ${normalizedQuery} = ANY(aliases)
+        )
+      ORDER BY popularity DESC
+      LIMIT ${limit}
+    `;
+
+    await this.cache.set(
+      cacheKey,
+      languages,
+      TECH_SKILLS_CACHE_TTL.SKILLS_SEARCH,
+    );
+    return languages;
+  }
+}
diff --git a/src/tech-skills/services/languages-sync.service.ts b/src/tech-skills/services/languages-sync.service.ts
new file mode 100644
index 0000000..7da474a
--- /dev/null
+++ b/src/tech-skills/services/languages-sync.service.ts
@@ -0,0 +1,53 @@
+/**
+ * Languages Sync Service
+ * Single Responsibility: Sync programming languages to database
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import type { ParsedLanguage } from '../interfaces';
+
+@Injectable()
+export class LanguagesSyncService {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async syncLanguages(
+    languages: ParsedLanguage[],
+  ): Promise<{ inserted: number; updated: number }> {
+    let inserted = 0;
+    let updated = 0;
+
+    for (const lang of languages) {
+      const existing = await this.prisma.programmingLanguage.findUnique({
+        where: { slug: lang.slug },
+      });
+
+      const data = {
+        nameEn: lang.nameEn,
+        namePtBr: lang.namePtBr,
+        color: lang.color,
+        website: lang.website,
+        aliases: lang.aliases,
+        fileExtensions: lang.extensions,
+        paradigms: lang.paradigms,
+        typing: lang.typing,
+        popularity: lang.popularity,
+      };
+
+      if (existing) {
+        await this.prisma.programmingLanguage.update({
+          where: { slug: lang.slug },
+          data,
+        });
+        updated++;
+      } else {
+        await this.prisma.programmingLanguage.create({
+          data: { slug: lang.slug, ...data },
+        });
+        inserted++;
+      }
+    }
+
+    return { inserted, updated };
+  }
+}
diff --git a/src/tech-skills/services/niche-query.service.ts b/src/tech-skills/services/niche-query.service.ts
new file mode 100644
index 0000000..60975d6
--- /dev/null
+++ b/src/tech-skills/services/niche-query.service.ts
@@ -0,0 +1,97 @@
+/**
+ * Tech Niche Query Service
+ * Handles cached queries for tech niches
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { CacheService } from '../../common/cache/cache.service';
+import {
+  TECH_SKILLS_CACHE_KEYS,
+  TECH_SKILLS_CACHE_TTL,
+  type TechAreaType,
+} from '../interfaces';
+import type { TechNicheDto } from '../dtos';
+
+@Injectable()
+export class TechNicheQueryService {
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly cache: CacheService,
+  ) {}
+
+  /**
+   * Get all niches
+   */
+  async getAllNiches(): Promise<TechNicheDto[]> {
+    const cacheKey = TECH_SKILLS_CACHE_KEYS.NICHES_LIST;
+
+    const cached = await this.cache.get<TechNicheDto[]>(cacheKey);
+    if (cached) return cached;
+
+    const niches = await this.prisma.techNiche.findMany({
+      where: { isActive: true },
+      orderBy: [{ area: { order: 'asc' } }, { order: 'asc' }],
+      include: {
+        area: { select: { type: true } },
+      },
+    });
+
+    const result: TechNicheDto[] = niches.map((n) => ({
+      id: n.id,
+      slug: n.slug,
+      nameEn: n.nameEn,
+      namePtBr: n.namePtBr,
+      descriptionEn: n.descriptionEn,
+      descriptionPtBr: n.descriptionPtBr,
+      icon: n.icon,
+      color: n.color,
+      order: n.order,
+      areaType: n.area.type as TechAreaType,
+    }));
+
+    await this.cache.set(cacheKey, result, TECH_SKILLS_CACHE_TTL.NICHES_LIST);
+    return result;
+  }
+
+  /**
+   * Get niches by area type
+   */
+  async getNichesByArea(areaType: TechAreaType): Promise<TechNicheDto[]> {
+    const cacheKey = `${TECH_SKILLS_CACHE_KEYS.SKILLS_BY_AREA}${areaType}`;
+
+    const cached = await this.cache.get<TechNicheDto[]>(cacheKey);
+    if (cached) return cached;
+
+    const niches = await this.prisma.techNiche.findMany({
+      where: {
+        isActive: true,
+        area: { type: areaType },
+      },
+      orderBy: { order: 'asc' },
+      include: {
+        area: { select: { type: true } },
+      },
+    });
+
+    const result: TechNicheDto[] = niches.map((n) => ({
+      id: n.id,
+      slug: n.slug,
+      nameEn: n.nameEn,
+      namePtBr: n.namePtBr,
+      descriptionEn: n.descriptionEn,
+      descriptionPtBr: n.descriptionPtBr,
+      icon: n.icon,
+      color: n.color,
+      order: n.order,
+      areaType: n.area.type as TechAreaType,
+    }));
+
+    await this.cache.set(
+      cacheKey,
+      result,
+      TECH_SKILLS_CACHE_TTL.SKILLS_BY_AREA,
+    );
+    return result;
+  }
+}
diff --git a/src/tech-skills/services/skill-query.service.ts b/src/tech-skills/services/skill-query.service.ts
new file mode 100644
index 0000000..d7a947e
--- /dev/null
+++ b/src/tech-skills/services/skill-query.service.ts
@@ -0,0 +1,77 @@
+/**
+ * Tech Skill Query Service
+ * Handles cached queries for tech skills
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { CacheService } from '../../common/cache/cache.service';
+import {
+  TECH_SKILLS_CACHE_KEYS,
+  TECH_SKILLS_CACHE_TTL,
+  type SkillType,
+} from '../interfaces';
+import type { TechSkillDto } from '../dtos';
+import { mapSkillsToDto } from '../utils';
+
+const NICHE_SELECT = { slug: true, nameEn: true, namePtBr: true } as const;
+
+@Injectable()
+export class SkillQueryService {
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly cache: CacheService,
+  ) {}
+
+  /** Get all skills */
+  async getAllSkills(): Promise<TechSkillDto[]> {
+    const cacheKey = TECH_SKILLS_CACHE_KEYS.SKILLS_LIST;
+
+    const cached = await this.cache.get<TechSkillDto[]>(cacheKey);
+    if (cached) return cached;
+
+    const skills = await this.prisma.techSkill.findMany({
+      where: { isActive: true },
+      orderBy: { popularity: 'desc' },
+      include: { niche: { select: NICHE_SELECT } },
+    });
+
+    const result = mapSkillsToDto(skills);
+    await this.cache.set(cacheKey, result, TECH_SKILLS_CACHE_TTL.SKILLS_LIST);
+    return result;
+  }
+
+  /** Get skills by niche slug */
+  async getSkillsByNiche(nicheSlug: string): Promise<TechSkillDto[]> {
+    const cacheKey = `${TECH_SKILLS_CACHE_KEYS.SKILLS_BY_NICHE}${nicheSlug}`;
+
+    const cached = await this.cache.get<TechSkillDto[]>(cacheKey);
+    if (cached) return cached;
+
+    const skills = await this.prisma.techSkill.findMany({
+      where: { isActive: true, niche: { slug: nicheSlug } },
+      orderBy: { popularity: 'desc' },
+      include: { niche: { select: NICHE_SELECT } },
+    });
+
+    const result = mapSkillsToDto(skills);
+    await this.cache.set(
+      cacheKey,
+      result,
+      TECH_SKILLS_CACHE_TTL.SKILLS_BY_NICHE,
+    );
+    return result;
+  }
+
+  /** Get skills by type */
+  async getSkillsByType(type: SkillType, limit = 50): Promise<TechSkillDto[]> {
+    const skills = await this.prisma.techSkill.findMany({
+      where: { isActive: true, type },
+      take: limit,
+      orderBy: { popularity: 'desc' },
+      include: { niche: { select: NICHE_SELECT } },
+    });
+
+    return mapSkillsToDto(skills);
+  }
+}
diff --git a/src/tech-skills/services/skill-search.service.ts b/src/tech-skills/services/skill-search.service.ts
new file mode 100644
index 0000000..a4570ab
--- /dev/null
+++ b/src/tech-skills/services/skill-search.service.ts
@@ -0,0 +1,73 @@
+/**
+ * Skill Search Service
+ * Handles skill search with caching
+ */
+
+import { Injectable } from '@nestjs/common';
+import * as crypto from 'crypto';
+import { PrismaService } from '../../prisma/prisma.service';
+import { CacheService } from '../../common/cache/cache.service';
+import { API_LIMITS } from '../../common/constants/app.constants';
+import { TECH_SKILLS_CACHE_KEYS, TECH_SKILLS_CACHE_TTL } from '../interfaces';
+import type { TechSkillDto, TechSkillRawQueryResult } from '../dtos';
+import { mapRawSkillsToDto } from '../utils';
+
+@Injectable()
+export class SkillSearchService {
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly cache: CacheService,
+  ) {}
+
+  /** Search skills with accent-insensitive matching */
+  async searchSkills(query: string, limit = 20): Promise<TechSkillDto[]> {
+    const normalizedQuery = query.toLowerCase().trim();
+    if (normalizedQuery.length < 1) return [];
+
+    const cacheKey = this.buildCacheKey(normalizedQuery);
+
+    const cached = await this.cache.get<TechSkillDto[]>(cacheKey);
+    if (cached) return cached;
+
+    const skills = await this.executeSearchQuery(normalizedQuery, limit);
+    const result = mapRawSkillsToDto(skills);
+
+    await this.cache.set(cacheKey, result, TECH_SKILLS_CACHE_TTL.SKILLS_SEARCH);
+    return result;
+  }
+
+  private buildCacheKey(query: string): string {
+    const queryHash = crypto
+      .createHash('md5')
+      .update(`skill:${query}`)
+      .digest('hex')
+      .slice(0, API_LIMITS.MAX_SUGGESTIONS);
+    return `${TECH_SKILLS_CACHE_KEYS.SKILLS_SEARCH}${queryHash}`;
+  }
+
+  private async executeSearchQuery(
+    query: string,
+    limit: number,
+  ): Promise<TechSkillRawQueryResult[]> {
+    return this.prisma.$queryRaw<TechSkillRawQueryResult[]>`
+      SELECT 
+        s.id, s.slug, s."nameEn", s."namePtBr", s.type,
+        s.icon, s.color, s.website, s.aliases, s.popularity,
+        n.slug as niche_slug,
+        n."nameEn" as "niche_nameEn",
+        n."namePtBr" as "niche_namePtBr"
+      FROM "TechSkill" s
+      LEFT JOIN "TechNiche" n ON s."nicheId" = n.id
+      WHERE s."isActive" = true
+        AND (
+          immutable_unaccent(lower(s."nameEn")) LIKE '%' || immutable_unaccent(lower(${query})) || '%'
+          OR immutable_unaccent(lower(s."namePtBr")) LIKE '%' || immutable_unaccent(lower(${query})) || '%'
+          OR s.slug LIKE '%' || ${query} || '%'
+          OR ${query} = ANY(s.aliases)
+          OR ${query} = ANY(s.keywords)
+        )
+      ORDER BY s.popularity DESC
+      LIMIT ${limit}
+    `;
+  }
+}
diff --git a/src/tech-skills/services/skills-data-sync.service.ts b/src/tech-skills/services/skills-data-sync.service.ts
new file mode 100644
index 0000000..3bc5a9b
--- /dev/null
+++ b/src/tech-skills/services/skills-data-sync.service.ts
@@ -0,0 +1,65 @@
+/**
+ * Skills Data Sync Service
+ * Single Responsibility: Sync tech skills to database
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import type { ParsedSkill } from '../interfaces';
+
+@Injectable()
+export class SkillsDataSyncService {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async syncSkills(
+    skills: ParsedSkill[],
+  ): Promise<{ inserted: number; updated: number }> {
+    let inserted = 0;
+    let updated = 0;
+
+    for (const skill of skills) {
+      const nicheId = await this.findNicheId(skill.nicheSlug ?? undefined);
+      const existing = await this.prisma.techSkill.findUnique({
+        where: { slug: skill.slug },
+      });
+
+      const data = {
+        nameEn: skill.nameEn,
+        namePtBr: skill.namePtBr,
+        type: skill.type,
+        nicheId,
+        color: skill.color,
+        icon: skill.icon,
+        website: skill.website,
+        aliases: skill.aliases,
+        keywords: skill.keywords,
+        popularity: skill.popularity,
+      };
+
+      if (existing) {
+        await this.prisma.techSkill.update({
+          where: { slug: skill.slug },
+          data,
+        });
+        updated++;
+      } else {
+        await this.prisma.techSkill.create({
+          data: { slug: skill.slug, ...data },
+        });
+        inserted++;
+      }
+    }
+
+    return { inserted, updated };
+  }
+
+  private async findNicheId(nicheSlug?: string): Promise<string | undefined> {
+    if (!nicheSlug) return undefined;
+
+    const niche = await this.prisma.techNiche.findUnique({
+      where: { slug: nicheSlug },
+    });
+
+    return niche?.id ?? undefined;
+  }
+}
diff --git a/src/tech-skills/services/stackoverflow-parser.service.ts b/src/tech-skills/services/stackoverflow-parser.service.ts
index 33e3834..cf14b06 100644
--- a/src/tech-skills/services/stackoverflow-parser.service.ts
+++ b/src/tech-skills/services/stackoverflow-parser.service.ts
@@ -1,6 +1,8 @@
 /**
  * Stack Overflow Tags Parser Service
- * Fetches popular tech skills from Stack Overflow tags
+ *
+ * Fetches popular tech skills from Stack Overflow tags API
+ * and parses them into structured skill data.
  */
 
 import { Injectable } from '@nestjs/common';
@@ -10,339 +12,23 @@ import type {
   ParsedSkill,
   SkillType,
 } from '../interfaces';
-
-// Skill categorization mappings
-const SKILL_CATEGORIES: Record<
-  string,
-  { type: SkillType; niche: string | null }
-> = {
-  // Frameworks - Frontend
-  react: { type: 'FRAMEWORK', niche: 'frontend' },
-  reactjs: { type: 'FRAMEWORK', niche: 'frontend' },
-  angular: { type: 'FRAMEWORK', niche: 'frontend' },
-  angularjs: { type: 'FRAMEWORK', niche: 'frontend' },
-  'vue.js': { type: 'FRAMEWORK', niche: 'frontend' },
-  vuejs: { type: 'FRAMEWORK', niche: 'frontend' },
-  svelte: { type: 'FRAMEWORK', niche: 'frontend' },
-  'next.js': { type: 'FRAMEWORK', niche: 'frontend' },
-  nextjs: { type: 'FRAMEWORK', niche: 'frontend' },
-  'nuxt.js': { type: 'FRAMEWORK', niche: 'frontend' },
-  gatsby: { type: 'FRAMEWORK', niche: 'frontend' },
-  'ember.js': { type: 'FRAMEWORK', niche: 'frontend' },
-  'backbone.js': { type: 'FRAMEWORK', niche: 'frontend' },
-
-  // Frameworks - Backend
-  'node.js': { type: 'FRAMEWORK', niche: 'backend' },
-  nodejs: { type: 'FRAMEWORK', niche: 'backend' },
-  express: { type: 'FRAMEWORK', niche: 'backend' },
-  expressjs: { type: 'FRAMEWORK', niche: 'backend' },
-  nestjs: { type: 'FRAMEWORK', niche: 'backend' },
-  fastify: { type: 'FRAMEWORK', niche: 'backend' },
-  koa: { type: 'FRAMEWORK', niche: 'backend' },
-  django: { type: 'FRAMEWORK', niche: 'backend' },
-  flask: { type: 'FRAMEWORK', niche: 'backend' },
-  fastapi: { type: 'FRAMEWORK', niche: 'backend' },
-  spring: { type: 'FRAMEWORK', niche: 'backend' },
-  'spring-boot': { type: 'FRAMEWORK', niche: 'backend' },
-  rails: { type: 'FRAMEWORK', niche: 'backend' },
-  'ruby-on-rails': { type: 'FRAMEWORK', niche: 'backend' },
-  laravel: { type: 'FRAMEWORK', niche: 'backend' },
-  symfony: { type: 'FRAMEWORK', niche: 'backend' },
-  'asp.net': { type: 'FRAMEWORK', niche: 'backend' },
-  'asp.net-core': { type: 'FRAMEWORK', niche: 'backend' },
-  'asp.net-mvc': { type: 'FRAMEWORK', niche: 'backend' },
-  gin: { type: 'FRAMEWORK', niche: 'backend' },
-  fiber: { type: 'FRAMEWORK', niche: 'backend' },
-  actix: { type: 'FRAMEWORK', niche: 'backend' },
-  rocket: { type: 'FRAMEWORK', niche: 'backend' },
-  phoenix: { type: 'FRAMEWORK', niche: 'backend' },
-
-  // Frameworks - Mobile
-  'react-native': { type: 'FRAMEWORK', niche: 'mobile' },
-  flutter: { type: 'FRAMEWORK', niche: 'mobile' },
-  ionic: { type: 'FRAMEWORK', niche: 'mobile' },
-  xamarin: { type: 'FRAMEWORK', niche: 'mobile' },
-  swiftui: { type: 'FRAMEWORK', niche: 'mobile' },
-  'jetpack-compose': { type: 'FRAMEWORK', niche: 'mobile' },
-  'kotlin-multiplatform': { type: 'FRAMEWORK', niche: 'mobile' },
-
-  // Databases
-  mysql: { type: 'DATABASE', niche: 'backend' },
-  postgresql: { type: 'DATABASE', niche: 'backend' },
-  postgres: { type: 'DATABASE', niche: 'backend' },
-  mongodb: { type: 'DATABASE', niche: 'backend' },
-  redis: { type: 'DATABASE', niche: 'backend' },
-  sqlite: { type: 'DATABASE', niche: 'backend' },
-  oracle: { type: 'DATABASE', niche: 'backend' },
-  'sql-server': { type: 'DATABASE', niche: 'backend' },
-  mariadb: { type: 'DATABASE', niche: 'backend' },
-  cassandra: { type: 'DATABASE', niche: 'backend' },
-  dynamodb: { type: 'DATABASE', niche: 'backend' },
-  elasticsearch: { type: 'DATABASE', niche: 'backend' },
-  neo4j: { type: 'DATABASE', niche: 'backend' },
-  firebase: { type: 'DATABASE', niche: 'backend' },
-  supabase: { type: 'DATABASE', niche: 'backend' },
-  prisma: { type: 'LIBRARY', niche: 'backend' },
-  typeorm: { type: 'LIBRARY', niche: 'backend' },
-  sequelize: { type: 'LIBRARY', niche: 'backend' },
-  mongoose: { type: 'LIBRARY', niche: 'backend' },
-
-  // DevOps & Cloud
-  docker: { type: 'TOOL', niche: 'devops' },
-  kubernetes: { type: 'PLATFORM', niche: 'devops' },
-  k8s: { type: 'PLATFORM', niche: 'devops' },
-  aws: { type: 'PLATFORM', niche: 'devops' },
-  azure: { type: 'PLATFORM', niche: 'devops' },
-  'google-cloud-platform': { type: 'PLATFORM', niche: 'devops' },
-  gcp: { type: 'PLATFORM', niche: 'devops' },
-  terraform: { type: 'TOOL', niche: 'devops' },
-  ansible: { type: 'TOOL', niche: 'devops' },
-  jenkins: { type: 'TOOL', niche: 'devops' },
-  'github-actions': { type: 'TOOL', niche: 'devops' },
-  'gitlab-ci': { type: 'TOOL', niche: 'devops' },
-  circleci: { type: 'TOOL', niche: 'devops' },
-  nginx: { type: 'TOOL', niche: 'devops' },
-  apache: { type: 'TOOL', niche: 'devops' },
-  linux: { type: 'PLATFORM', niche: 'devops' },
-  bash: { type: 'TOOL', niche: 'devops' },
-  prometheus: { type: 'TOOL', niche: 'devops' },
-  grafana: { type: 'TOOL', niche: 'devops' },
-  datadog: { type: 'TOOL', niche: 'devops' },
-  heroku: { type: 'PLATFORM', niche: 'devops' },
-  vercel: { type: 'PLATFORM', niche: 'devops' },
-  netlify: { type: 'PLATFORM', niche: 'devops' },
-  digitalocean: { type: 'PLATFORM', niche: 'devops' },
-
-  // Data & AI
-  pandas: { type: 'LIBRARY', niche: 'data-science' },
-  numpy: { type: 'LIBRARY', niche: 'data-science' },
-  'scikit-learn': { type: 'LIBRARY', niche: 'data-science' },
-  tensorflow: { type: 'FRAMEWORK', niche: 'machine-learning' },
-  pytorch: { type: 'FRAMEWORK', niche: 'machine-learning' },
-  keras: { type: 'LIBRARY', niche: 'machine-learning' },
-  opencv: { type: 'LIBRARY', niche: 'machine-learning' },
-  spark: { type: 'PLATFORM', niche: 'data-engineering' },
-  hadoop: { type: 'PLATFORM', niche: 'data-engineering' },
-  airflow: { type: 'TOOL', niche: 'data-engineering' },
-  kafka: { type: 'PLATFORM', niche: 'data-engineering' },
-  dbt: { type: 'TOOL', niche: 'data-engineering' },
-  snowflake: { type: 'PLATFORM', niche: 'data-engineering' },
-  'power-bi': { type: 'TOOL', niche: 'data-analytics' },
-  tableau: { type: 'TOOL', niche: 'data-analytics' },
-  looker: { type: 'TOOL', niche: 'data-analytics' },
-  metabase: { type: 'TOOL', niche: 'data-analytics' },
-  jupyter: { type: 'TOOL', niche: 'data-science' },
-  langchain: { type: 'FRAMEWORK', niche: 'machine-learning' },
-  huggingface: { type: 'PLATFORM', niche: 'machine-learning' },
-  openai: { type: 'PLATFORM', niche: 'machine-learning' },
-
-  // Testing & QA
-  jest: { type: 'TOOL', niche: 'qa' },
-  mocha: { type: 'TOOL', niche: 'qa' },
-  cypress: { type: 'TOOL', niche: 'qa' },
-  playwright: { type: 'TOOL', niche: 'qa' },
-  selenium: { type: 'TOOL', niche: 'qa' },
-  puppeteer: { type: 'TOOL', niche: 'qa' },
-  pytest: { type: 'TOOL', niche: 'qa' },
-  junit: { type: 'TOOL', niche: 'qa' },
-  testng: { type: 'TOOL', niche: 'qa' },
-  postman: { type: 'TOOL', niche: 'qa' },
-  insomnia: { type: 'TOOL', niche: 'qa' },
-  sentry: { type: 'TOOL', niche: 'qa' },
-  'new-relic': { type: 'TOOL', niche: 'qa' },
-  vitest: { type: 'TOOL', niche: 'qa' },
-  'testing-library': { type: 'LIBRARY', niche: 'qa' },
-
-  // Design & UI
-  figma: { type: 'TOOL', niche: 'design' },
-  sketch: { type: 'TOOL', niche: 'design' },
-  'adobe-xd': { type: 'TOOL', niche: 'design' },
-  invision: { type: 'TOOL', niche: 'design' },
-  zeplin: { type: 'TOOL', niche: 'design' },
-  tailwindcss: { type: 'FRAMEWORK', niche: 'frontend' },
-  'tailwind-css': { type: 'FRAMEWORK', niche: 'frontend' },
-  bootstrap: { type: 'FRAMEWORK', niche: 'frontend' },
-  'material-ui': { type: 'LIBRARY', niche: 'frontend' },
-  'chakra-ui': { type: 'LIBRARY', niche: 'frontend' },
-  'ant-design': { type: 'LIBRARY', niche: 'frontend' },
-  'styled-components': { type: 'LIBRARY', niche: 'frontend' },
-  emotion: { type: 'LIBRARY', niche: 'frontend' },
-  sass: { type: 'TOOL', niche: 'frontend' },
-  less: { type: 'TOOL', niche: 'frontend' },
-  storybook: { type: 'TOOL', niche: 'frontend' },
-
-  // Security
-  oauth: { type: 'METHODOLOGY', niche: 'security' },
-  jwt: { type: 'METHODOLOGY', niche: 'security' },
-  owasp: { type: 'METHODOLOGY', niche: 'security' },
-  'penetration-testing': { type: 'METHODOLOGY', niche: 'security' },
-  'burp-suite': { type: 'TOOL', niche: 'security' },
-  nmap: { type: 'TOOL', niche: 'security' },
-  wireshark: { type: 'TOOL', niche: 'security' },
-  metasploit: { type: 'TOOL', niche: 'security' },
-  'kali-linux': { type: 'PLATFORM', niche: 'security' },
-  'hashicorp-vault': { type: 'TOOL', niche: 'security' },
-
-  // Version Control & Collaboration
-  git: { type: 'TOOL', niche: null },
-  github: { type: 'PLATFORM', niche: null },
-  gitlab: { type: 'PLATFORM', niche: null },
-  bitbucket: { type: 'PLATFORM', niche: null },
-  jira: { type: 'TOOL', niche: null },
-  confluence: { type: 'TOOL', niche: null },
-  slack: { type: 'TOOL', niche: null },
-  notion: { type: 'TOOL', niche: null },
-  trello: { type: 'TOOL', niche: null },
-  asana: { type: 'TOOL', niche: null },
-  linear: { type: 'TOOL', niche: null },
-
-  // Libraries
-  jquery: { type: 'LIBRARY', niche: 'frontend' },
-  lodash: { type: 'LIBRARY', niche: null },
-  axios: { type: 'LIBRARY', niche: null },
-  redux: { type: 'LIBRARY', niche: 'frontend' },
-  zustand: { type: 'LIBRARY', niche: 'frontend' },
-  mobx: { type: 'LIBRARY', niche: 'frontend' },
-  rxjs: { type: 'LIBRARY', niche: null },
-  graphql: { type: 'LIBRARY', niche: null },
-  apollo: { type: 'LIBRARY', niche: null },
-  'socket.io': { type: 'LIBRARY', niche: 'backend' },
-  webpack: { type: 'TOOL', niche: 'frontend' },
-  vite: { type: 'TOOL', niche: 'frontend' },
-  rollup: { type: 'TOOL', niche: 'frontend' },
-  esbuild: { type: 'TOOL', niche: 'frontend' },
-  babel: { type: 'TOOL', niche: 'frontend' },
-  eslint: { type: 'TOOL', niche: null },
-  prettier: { type: 'TOOL', niche: null },
-
-  // Methodologies
-  agile: { type: 'METHODOLOGY', niche: null },
-  scrum: { type: 'METHODOLOGY', niche: null },
-  kanban: { type: 'METHODOLOGY', niche: null },
-  tdd: { type: 'METHODOLOGY', niche: null },
-  bdd: { type: 'METHODOLOGY', niche: null },
-  'ci-cd': { type: 'METHODOLOGY', niche: 'devops' },
-  devops: { type: 'METHODOLOGY', niche: 'devops' },
-  microservices: { type: 'METHODOLOGY', niche: 'backend' },
-  serverless: { type: 'METHODOLOGY', niche: 'backend' },
-  rest: { type: 'METHODOLOGY', niche: null },
-  restful: { type: 'METHODOLOGY', niche: null },
-  api: { type: 'METHODOLOGY', niche: null },
-  'design-patterns': { type: 'METHODOLOGY', niche: null },
-  solid: { type: 'METHODOLOGY', niche: null },
-  'clean-architecture': { type: 'METHODOLOGY', niche: null },
-  ddd: { type: 'METHODOLOGY', niche: null },
-  'event-driven': { type: 'METHODOLOGY', niche: null },
-  cqrs: { type: 'METHODOLOGY', niche: null },
-
-  // Blockchain
-  solidity: { type: 'LANGUAGE', niche: 'blockchain' },
-  web3: { type: 'LIBRARY', niche: 'blockchain' },
-  'ethers.js': { type: 'LIBRARY', niche: 'blockchain' },
-  hardhat: { type: 'TOOL', niche: 'blockchain' },
-  truffle: { type: 'TOOL', niche: 'blockchain' },
-  ethereum: { type: 'PLATFORM', niche: 'blockchain' },
-
-  // Other tools
-  vscode: { type: 'TOOL', niche: null },
-  intellij: { type: 'TOOL', niche: null },
-  vim: { type: 'TOOL', niche: null },
-  neovim: { type: 'TOOL', niche: null },
-  emacs: { type: 'TOOL', niche: null },
-};
-
-// Portuguese translations
-const SKILL_TRANSLATIONS: Record<string, string> = {
-  react: 'React',
-  angular: 'Angular',
-  'vue.js': 'Vue.js',
-  'node.js': 'Node.js',
-  express: 'Express',
-  django: 'Django',
-  flask: 'Flask',
-  spring: 'Spring',
-  docker: 'Docker',
-  kubernetes: 'Kubernetes',
-  aws: 'AWS',
-  azure: 'Azure',
-  git: 'Git',
-  mysql: 'MySQL',
-  postgresql: 'PostgreSQL',
-  mongodb: 'MongoDB',
-  redis: 'Redis',
-  linux: 'Linux',
-  agile: 'Ágil',
-  scrum: 'Scrum',
-  kanban: 'Kanban',
-  tdd: 'TDD',
-  bdd: 'BDD',
-  'ci-cd': 'CI/CD',
-  devops: 'DevOps',
-  microservices: 'Microsserviços',
-  serverless: 'Serverless',
-  rest: 'REST',
-  api: 'API',
-  'design-patterns': 'Padrões de Projeto',
-  'clean-architecture': 'Arquitetura Limpa',
-  'machine-learning': 'Machine Learning',
-  'artificial-intelligence': 'Inteligência Artificial',
-  'data-science': 'Ciência de Dados',
-  'big-data': 'Big Data',
-  blockchain: 'Blockchain',
-  security: 'Segurança',
-  testing: 'Testes',
-  frontend: 'Frontend',
-  backend: 'Backend',
-  fullstack: 'Fullstack',
-  mobile: 'Mobile',
-};
-
-// Skill colors (brand colors where applicable)
-const SKILL_COLORS: Record<string, string> = {
-  react: '#61DAFB',
-  angular: '#DD0031',
-  'vue.js': '#4FC08D',
-  svelte: '#FF3E00',
-  'next.js': '#000000',
-  'node.js': '#339933',
-  express: '#000000',
-  nestjs: '#E0234E',
-  django: '#092E20',
-  flask: '#000000',
-  fastapi: '#009688',
-  spring: '#6DB33F',
-  laravel: '#FF2D20',
-  rails: '#CC0000',
-  docker: '#2496ED',
-  kubernetes: '#326CE5',
-  aws: '#FF9900',
-  azure: '#0078D4',
-  gcp: '#4285F4',
-  terraform: '#7B42BC',
-  mysql: '#4479A1',
-  postgresql: '#336791',
-  mongodb: '#47A248',
-  redis: '#DC382D',
-  elasticsearch: '#005571',
-  firebase: '#FFCA28',
-  git: '#F05032',
-  github: '#181717',
-  gitlab: '#FCA121',
-  figma: '#F24E1E',
-  tailwindcss: '#06B6D4',
-  bootstrap: '#7952B3',
-  graphql: '#E10098',
-  tensorflow: '#FF6F00',
-  pytorch: '#EE4C2C',
-  jest: '#C21325',
-  cypress: '#17202C',
-  selenium: '#43B02A',
-};
+import {
+  STACKOVERFLOW_CATEGORIES,
+  STACKOVERFLOW_TRANSLATIONS,
+  STACKOVERFLOW_COLORS,
+} from '../constants';
+import {
+  formatDisplayName,
+  normalizeSlug,
+  shouldIncludeStackOverflowTag,
+  getAliases,
+  getKeywords,
+} from '../utils';
 
 @Injectable()
 export class StackOverflowParserService {
   private readonly SO_API_URL = 'https://api.stackexchange.com/2.3/tags';
-  private readonly MAX_PAGES = 10; // Fetch top 1000 tags (100 per page)
+  private readonly MAX_PAGES = 10;
 
   constructor(private readonly logger: AppLoggerService) {}
 
@@ -355,7 +41,6 @@ export class StackOverflowParserService {
     const allTags: { name: string; count: number }[] = [];
 
     try {
-      // Fetch multiple pages of tags
       for (let page = 1; page <= this.MAX_PAGES; page++) {
         const url = `${this.SO_API_URL}?page=${page}&pagesize=100&order=desc&sort=popular&site=stackoverflow`;
 
@@ -365,22 +50,20 @@ export class StackOverflowParserService {
           break;
         }
 
-        const data: StackOverflowResponse = await response.json();
-
+        const data = (await response.json()) as StackOverflowResponse;
         for (const tag of data.items) {
           allTags.push({ name: tag.name, count: tag.count });
         }
 
         if (!data.has_more) break;
-
-        // Rate limiting - wait 100ms between requests
         await new Promise((resolve) => setTimeout(resolve, 100));
       }
 
       return this.parseTags(allTags);
     } catch (error) {
-      this.logger.error('Failed to fetch Stack Overflow tags', error);
-      throw error;
+      const err = error instanceof Error ? error : new Error(String(error));
+      this.logger.error('Failed to fetch Stack Overflow tags', err.message);
+      throw err;
     }
   }
 
@@ -390,52 +73,31 @@ export class StackOverflowParserService {
   private parseTags(tags: { name: string; count: number }[]): ParsedSkill[] {
     const parsed: ParsedSkill[] = [];
     const seenSlugs = new Set<string>();
-    // Helper to avoid prototype pollution (e.g., "constructor" tag)
-    const hasOwn = (obj: Record<string, unknown>, key: string) =>
-      Object.prototype.hasOwnProperty.call(obj, key);
+    const hasOwn = (obj: Record<string, unknown>, key: string): boolean => {
+      return Boolean(Object.prototype.hasOwnProperty.call(obj, key));
+    };
 
     for (const tag of tags) {
-      const slug = this.normalizeSlug(tag.name);
+      const slug = normalizeSlug(tag.name);
       const tagLower = tag.name.toLowerCase();
 
-      // Skip if already seen or is a programming language (handled by Linguist)
       if (seenSlugs.has(slug)) continue;
-      if (this.isProgrammingLanguage(tag.name)) continue;
-
-      const category = (hasOwn(SKILL_CATEGORIES, tagLower)
-        ? SKILL_CATEGORIES[tagLower]
-        : null) ||
-        (hasOwn(SKILL_CATEGORIES, slug) ? SKILL_CATEGORIES[slug] : null) || {
-          type: 'OTHER' as SkillType,
-          niche: null,
-        };
-
-      // Skip generic/non-tech tags
-      if (this.shouldSkipTag(tag.name)) continue;
+      if (!shouldIncludeStackOverflowTag(tag.name)) continue;
 
+      const category = this.getCategory(tagLower, slug, hasOwn);
       seenSlugs.add(slug);
 
       parsed.push({
         slug,
-        nameEn: this.formatDisplayName(tag.name),
-        namePtBr:
-          (hasOwn(SKILL_TRANSLATIONS, tagLower)
-            ? SKILL_TRANSLATIONS[tagLower]
-            : null) ||
-          (hasOwn(SKILL_TRANSLATIONS, slug)
-            ? SKILL_TRANSLATIONS[slug]
-            : null) ||
-          this.formatDisplayName(tag.name),
+        nameEn: formatDisplayName(tag.name),
+        namePtBr: this.getTranslation(tagLower, slug, tag.name, hasOwn),
         type: category.type,
         nicheSlug: category.niche,
-        color:
-          (hasOwn(SKILL_COLORS, tagLower) ? SKILL_COLORS[tagLower] : null) ||
-          (hasOwn(SKILL_COLORS, slug) ? SKILL_COLORS[slug] : null) ||
-          null,
+        color: this.getColor(tagLower, slug, hasOwn),
         icon: null,
         website: null,
-        aliases: this.getAliases(tag.name),
-        keywords: this.getKeywords(tag.name),
+        aliases: getAliases(tag.name),
+        keywords: getKeywords(tag.name),
         popularity: tag.count,
       });
     }
@@ -444,245 +106,54 @@ export class StackOverflowParserService {
     return parsed;
   }
 
-  /**
-   * Normalize tag name to slug
-   */
-  private normalizeSlug(name: string): string {
-    return name
-      .toLowerCase()
-      .replace(/\./g, '-')
-      .replace(/\s+/g, '-')
-      .replace(/[^a-z0-9-]/g, '')
-      .replace(/-+/g, '-')
-      .replace(/^-|-$/g, '');
-  }
-
-  /**
-   * Format tag name for display
-   */
-  private formatDisplayName(name: string): string {
-    const specialCases: Record<string, string> = {
-      javascript: 'JavaScript',
-      typescript: 'TypeScript',
-      nodejs: 'Node.js',
-      'node.js': 'Node.js',
-      reactjs: 'React',
-      vuejs: 'Vue.js',
-      angularjs: 'AngularJS',
-      nextjs: 'Next.js',
-      nuxtjs: 'Nuxt.js',
-      expressjs: 'Express',
-      nestjs: 'NestJS',
-      graphql: 'GraphQL',
-      mongodb: 'MongoDB',
-      postgresql: 'PostgreSQL',
-      mysql: 'MySQL',
-      aws: 'AWS',
-      gcp: 'Google Cloud',
-      css: 'CSS',
-      html: 'HTML',
-      sql: 'SQL',
-      api: 'API',
-      rest: 'REST',
-      oauth: 'OAuth',
-      jwt: 'JWT',
-      'ci-cd': 'CI/CD',
-      devops: 'DevOps',
-      ios: 'iOS',
-      macos: 'macOS',
-    };
-
-    const lower = name.toLowerCase();
-    if (Object.prototype.hasOwnProperty.call(specialCases, lower)) {
-      return specialCases[lower];
-    }
-
-    // Title case
-    return name
-      .split(/[-_\s]/)
-      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
-      .join(' ');
-  }
-
-  /**
-   * Check if tag is a programming language (handled by GitHub Linguist)
-   */
-  private isProgrammingLanguage(name: string): boolean {
-    const languages = new Set([
-      'javascript',
-      'typescript',
-      'python',
-      'java',
-      'c#',
-      'c++',
-      'c',
-      'go',
-      'rust',
-      'ruby',
-      'php',
-      'swift',
-      'kotlin',
-      'scala',
-      'r',
-      'perl',
-      'haskell',
-      'elixir',
-      'erlang',
-      'clojure',
-      'f#',
-      'lua',
-      'dart',
-      'julia',
-      'matlab',
-      'fortran',
-      'cobol',
-      'pascal',
-      'assembly',
-      'bash',
-      'powershell',
-      'shell',
-      'objective-c',
-      'groovy',
-      'visual-basic',
-      'vba',
-      'delphi',
-      'zig',
-      'nim',
-      'crystal',
-      'v',
-      'solidity',
-    ]);
-
-    return languages.has(name.toLowerCase());
-  }
-
-  /**
-   * Check if tag should be skipped (generic/non-tech)
-   */
-  private shouldSkipTag(name: string): boolean {
-    const skipTags = new Set([
-      'arrays',
-      'string',
-      'list',
-      'dictionary',
-      'object',
-      'function',
-      'class',
-      'loops',
-      'if-statement',
-      'variables',
-      'sorting',
-      'regex',
-      'date',
-      'datetime',
-      'file',
-      'json',
-      'xml',
-      'csv',
-      'image',
-      'video',
-      'audio',
-      'math',
-      'algorithm',
-      'recursion',
-      'debugging',
-      'performance',
-      'memory',
-      'multithreading',
-      'asynchronous',
-      'oop',
-      'inheritance',
-      'polymorphism',
-      'exception',
-      'error-handling',
-      'unit-testing',
-      'logging',
-      'authentication',
-      'authorization',
-      'encryption',
-      'hashing',
-      'http',
-      'https',
-      'tcp',
-      'udp',
-      'websocket',
-      'cors',
-      'cookies',
-      'session',
-      'cache',
-      'optimization',
-      'deployment',
-      'documentation',
-      'version-control',
-      'code-review',
-      // Too generic
-      'android',
-      'ios',
-      'windows',
-      'macos',
-      'ubuntu',
-      'debian',
-      'web',
-      'mobile',
-      'desktop',
-      'server',
-      'client',
-      'browser',
-      'database',
-      'frontend',
-      'backend',
-      'fullstack',
-    ]);
-
-    return skipTags.has(name.toLowerCase());
+  private getCategory(
+    tagLower: string,
+    slug: string,
+    hasOwn: (obj: Record<string, unknown>, key: string) => boolean,
+  ): { type: SkillType; niche: string | null } {
+    return (
+      (hasOwn(STACKOVERFLOW_CATEGORIES, tagLower)
+        ? STACKOVERFLOW_CATEGORIES[tagLower]
+        : null) ??
+      (hasOwn(STACKOVERFLOW_CATEGORIES, slug)
+        ? STACKOVERFLOW_CATEGORIES[slug]
+        : null) ?? {
+        type: 'OTHER' as SkillType,
+        niche: null,
+      }
+    );
   }
 
-  /**
-   * Get aliases for a skill
-   */
-  private getAliases(name: string): string[] {
-    const aliasMap: Record<string, string[]> = {
-      react: ['reactjs', 'react.js'],
-      'vue.js': ['vuejs', 'vue'],
-      'node.js': ['nodejs', 'node'],
-      'next.js': ['nextjs', 'next'],
-      angular: ['angularjs', 'ng'],
-      express: ['expressjs', 'express.js'],
-      typescript: ['ts'],
-      javascript: ['js', 'es6', 'ecmascript'],
-      kubernetes: ['k8s'],
-      postgresql: ['postgres', 'psql'],
-      mongodb: ['mongo'],
-      elasticsearch: ['elastic', 'es'],
-      tailwindcss: ['tailwind', 'tailwind-css'],
-    };
-
-    const lower = name.toLowerCase();
-    return Object.prototype.hasOwnProperty.call(aliasMap, lower)
-      ? aliasMap[lower]
-      : [];
+  private getTranslation(
+    tagLower: string,
+    slug: string,
+    name: string,
+    hasOwn: (obj: Record<string, unknown>, key: string) => boolean,
+  ): string {
+    return (
+      (hasOwn(STACKOVERFLOW_TRANSLATIONS, tagLower)
+        ? STACKOVERFLOW_TRANSLATIONS[tagLower]
+        : null) ??
+      (hasOwn(STACKOVERFLOW_TRANSLATIONS, slug)
+        ? STACKOVERFLOW_TRANSLATIONS[slug]
+        : null) ??
+      formatDisplayName(name)
+    );
   }
 
-  /**
-   * Get search keywords for a skill
-   */
-  private getKeywords(name: string): string[] {
-    const keywordMap: Record<string, string[]> = {
-      react: ['ui', 'components', 'hooks', 'jsx', 'frontend'],
-      'node.js': ['server', 'backend', 'runtime', 'npm'],
-      docker: ['container', 'containerization', 'devops'],
-      kubernetes: ['orchestration', 'container', 'cluster', 'devops'],
-      aws: ['cloud', 'amazon', 'infrastructure'],
-      postgresql: ['database', 'sql', 'relational'],
-      mongodb: ['database', 'nosql', 'document'],
-      graphql: ['api', 'query', 'schema'],
-      tensorflow: ['ai', 'ml', 'deep-learning', 'neural-network'],
-      figma: ['design', 'ui', 'ux', 'prototype'],
-    };
-
-    const lower = name.toLowerCase();
-    return Object.prototype.hasOwnProperty.call(keywordMap, lower)
-      ? keywordMap[lower]
-      : [];
+  private getColor(
+    tagLower: string,
+    slug: string,
+    hasOwn: (obj: Record<string, unknown>, key: string) => boolean,
+  ): string | null {
+    return (
+      (hasOwn(STACKOVERFLOW_COLORS, tagLower)
+        ? STACKOVERFLOW_COLORS[tagLower]
+        : null) ??
+      (hasOwn(STACKOVERFLOW_COLORS, slug)
+        ? STACKOVERFLOW_COLORS[slug]
+        : null) ??
+      null
+    );
   }
 }
diff --git a/src/tech-skills/services/tech-areas-sync.service.ts b/src/tech-skills/services/tech-areas-sync.service.ts
new file mode 100644
index 0000000..6e95603
--- /dev/null
+++ b/src/tech-skills/services/tech-areas-sync.service.ts
@@ -0,0 +1,40 @@
+/**
+ * Tech Areas Sync Service
+ * Single Responsibility: Sync tech areas to database
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { TECH_AREAS } from '../data';
+
+@Injectable()
+export class TechAreasSyncService {
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly logger: AppLoggerService,
+  ) {}
+
+  async syncAreas(): Promise<number> {
+    let count = 0;
+
+    for (const area of TECH_AREAS) {
+      await this.prisma.techArea.upsert({
+        where: { type: area.type },
+        create: area,
+        update: {
+          nameEn: area.nameEn,
+          namePtBr: area.namePtBr,
+          descriptionEn: area.descriptionEn,
+          descriptionPtBr: area.descriptionPtBr,
+          icon: area.icon,
+          color: area.color,
+          order: area.order,
+        },
+      });
+      count++;
+    }
+
+    return count;
+  }
+}
diff --git a/src/tech-skills/services/tech-niches-sync.service.ts b/src/tech-skills/services/tech-niches-sync.service.ts
new file mode 100644
index 0000000..0ac89b8
--- /dev/null
+++ b/src/tech-skills/services/tech-niches-sync.service.ts
@@ -0,0 +1,62 @@
+/**
+ * Tech Niches Sync Service
+ * Single Responsibility: Sync tech niches to database
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { TECH_NICHES } from '../data';
+
+@Injectable()
+export class TechNichesSyncService {
+  constructor(
+    private readonly prisma: PrismaService,
+    private readonly logger: AppLoggerService,
+  ) {}
+
+  async syncNiches(): Promise<number> {
+    let count = 0;
+
+    for (const niche of TECH_NICHES) {
+      const area = await this.prisma.techArea.findUnique({
+        where: { type: niche.areaType },
+      });
+
+      if (!area) {
+        this.logger.warn(
+          `Area not found for niche ${niche.slug}: ${niche.areaType}`,
+        );
+        continue;
+      }
+
+      await this.prisma.techNiche.upsert({
+        where: { slug: niche.slug },
+        create: {
+          slug: niche.slug,
+          nameEn: niche.nameEn,
+          namePtBr: niche.namePtBr,
+          descriptionEn: niche.descriptionEn,
+          descriptionPtBr: niche.descriptionPtBr,
+          icon: niche.icon,
+          color: niche.color,
+          order: niche.order,
+          areaId: area.id,
+        },
+        update: {
+          nameEn: niche.nameEn,
+          namePtBr: niche.namePtBr,
+          descriptionEn: niche.descriptionEn,
+          descriptionPtBr: niche.descriptionPtBr,
+          icon: niche.icon,
+          color: niche.color,
+          order: niche.order,
+          areaId: area.id,
+        },
+      });
+      count++;
+    }
+
+    return count;
+  }
+}
diff --git a/src/tech-skills/services/tech-skills-query.service.ts b/src/tech-skills/services/tech-skills-query.service.ts
index e7ba4e9..412333c 100644
--- a/src/tech-skills/services/tech-skills-query.service.ts
+++ b/src/tech-skills/services/tech-skills-query.service.ts
@@ -1,495 +1,90 @@
 /**
- * Tech Skills Query Service
- * Provides cached queries for tech skills, languages, areas, and niches
+ * Tech Skills Query Service (Facade)
+ * Provides unified interface for tech skills queries
+ * Delegates to specialized services for each domain
  */
 
 import { Injectable } from '@nestjs/common';
-import { PrismaService } from '../../prisma/prisma.service';
-import { CacheService } from '../../common/cache/cache.service';
-import { AppLoggerService } from '../../common/logger/logger.service';
-import { TECH_SKILLS_CACHE_KEYS, TECH_SKILLS_CACHE_TTL } from '../interfaces';
 import type { TechAreaType, SkillType } from '../interfaces';
-import * as crypto from 'crypto';
-
-// DTOs for frontend consumption
-export interface TechAreaDto {
-  id: string;
-  type: TechAreaType;
-  nameEn: string;
-  namePtBr: string;
-  descriptionEn: string | null;
-  descriptionPtBr: string | null;
-  icon: string | null;
-  color: string | null;
-  order: number;
-}
-
-export interface TechNicheDto {
-  id: string;
-  slug: string;
-  nameEn: string;
-  namePtBr: string;
-  descriptionEn: string | null;
-  descriptionPtBr: string | null;
-  icon: string | null;
-  color: string | null;
-  order: number;
-  areaType: TechAreaType;
-}
-
-export interface TechSkillDto {
-  id: string;
-  slug: string;
-  nameEn: string;
-  namePtBr: string;
-  type: SkillType;
-  icon: string | null;
-  color: string | null;
-  website: string | null;
-  aliases: string[];
-  popularity: number;
-  niche: {
-    slug: string;
-    nameEn: string;
-    namePtBr: string;
-  } | null;
-}
-
-export interface ProgrammingLanguageDto {
-  id: string;
-  slug: string;
-  nameEn: string;
-  namePtBr: string;
-  color: string | null;
-  website: string | null;
-  aliases: string[];
-  fileExtensions: string[];
-  paradigms: string[];
-  typing: string | null;
-  popularity: number;
-}
+import {
+  type TechAreaDto,
+  type TechNicheDto,
+  type TechSkillDto,
+  type ProgrammingLanguageDto,
+} from '../dtos';
+import { TechAreaQueryService } from './area-query.service';
+import { TechNicheQueryService } from './niche-query.service';
+import { LanguageQueryService } from './language-query.service';
+import { SkillQueryService } from './skill-query.service';
+import { SkillSearchService } from './skill-search.service';
+
+// Re-export DTOs for backward compatibility
+export {
+  TechAreaDto,
+  TechNicheDto,
+  TechSkillDto,
+  ProgrammingLanguageDto,
+} from '../dtos';
 
 @Injectable()
 export class TechSkillsQueryService {
   constructor(
-    private readonly prisma: PrismaService,
-    private readonly cache: CacheService,
-    private readonly logger: AppLoggerService,
+    private readonly areaQuery: TechAreaQueryService,
+    private readonly nicheQuery: TechNicheQueryService,
+    private readonly languageQuery: LanguageQueryService,
+    private readonly skillQuery: SkillQueryService,
+    private readonly skillSearch: SkillSearchService,
   ) {}
 
-  /**
-   * Get all tech areas
-   */
+  /** Get all tech areas */
   async getAllAreas(): Promise<TechAreaDto[]> {
-    const cacheKey = TECH_SKILLS_CACHE_KEYS.AREAS_LIST;
-
-    const cached = await this.cache.get<TechAreaDto[]>(cacheKey);
-    if (cached) return cached;
-
-    const areas = await this.prisma.techArea.findMany({
-      where: { isActive: true },
-      orderBy: { order: 'asc' },
-      select: {
-        id: true,
-        type: true,
-        nameEn: true,
-        namePtBr: true,
-        descriptionEn: true,
-        descriptionPtBr: true,
-        icon: true,
-        color: true,
-        order: true,
-      },
-    });
-
-    await this.cache.set(cacheKey, areas, TECH_SKILLS_CACHE_TTL.AREAS_LIST);
-    return areas as TechAreaDto[];
+    return this.areaQuery.getAllAreas();
   }
 
-  /**
-   * Get all niches
-   */
+  /** Get all niches */
   async getAllNiches(): Promise<TechNicheDto[]> {
-    const cacheKey = TECH_SKILLS_CACHE_KEYS.NICHES_LIST;
-
-    const cached = await this.cache.get<TechNicheDto[]>(cacheKey);
-    if (cached) return cached;
-
-    const niches = await this.prisma.techNiche.findMany({
-      where: { isActive: true },
-      orderBy: [{ area: { order: 'asc' } }, { order: 'asc' }],
-      include: {
-        area: {
-          select: { type: true },
-        },
-      },
-    });
-
-    const result: TechNicheDto[] = niches.map((n) => ({
-      id: n.id,
-      slug: n.slug,
-      nameEn: n.nameEn,
-      namePtBr: n.namePtBr,
-      descriptionEn: n.descriptionEn,
-      descriptionPtBr: n.descriptionPtBr,
-      icon: n.icon,
-      color: n.color,
-      order: n.order,
-      areaType: n.area.type as TechAreaType,
-    }));
-
-    await this.cache.set(cacheKey, result, TECH_SKILLS_CACHE_TTL.NICHES_LIST);
-    return result;
+    return this.nicheQuery.getAllNiches();
   }
 
-  /**
-   * Get niches by area
-   */
+  /** Get niches by area */
   async getNichesByArea(areaType: TechAreaType): Promise<TechNicheDto[]> {
-    const cacheKey = `${TECH_SKILLS_CACHE_KEYS.SKILLS_BY_AREA}${areaType}`;
-
-    const cached = await this.cache.get<TechNicheDto[]>(cacheKey);
-    if (cached) return cached;
-
-    const niches = await this.prisma.techNiche.findMany({
-      where: {
-        isActive: true,
-        area: { type: areaType },
-      },
-      orderBy: { order: 'asc' },
-      include: {
-        area: {
-          select: { type: true },
-        },
-      },
-    });
-
-    const result: TechNicheDto[] = niches.map((n) => ({
-      id: n.id,
-      slug: n.slug,
-      nameEn: n.nameEn,
-      namePtBr: n.namePtBr,
-      descriptionEn: n.descriptionEn,
-      descriptionPtBr: n.descriptionPtBr,
-      icon: n.icon,
-      color: n.color,
-      order: n.order,
-      areaType: n.area.type as TechAreaType,
-    }));
-
-    await this.cache.set(
-      cacheKey,
-      result,
-      TECH_SKILLS_CACHE_TTL.SKILLS_BY_AREA,
-    );
-    return result;
+    return this.nicheQuery.getNichesByArea(areaType);
   }
 
-  /**
-   * Get all programming languages
-   */
+  /** Get all programming languages */
   async getAllLanguages(): Promise<ProgrammingLanguageDto[]> {
-    const cacheKey = TECH_SKILLS_CACHE_KEYS.LANGUAGES_LIST;
-
-    const cached = await this.cache.get<ProgrammingLanguageDto[]>(cacheKey);
-    if (cached) return cached;
-
-    const languages = await this.prisma.programmingLanguage.findMany({
-      where: { isActive: true },
-      orderBy: { popularity: 'desc' },
-      select: {
-        id: true,
-        slug: true,
-        nameEn: true,
-        namePtBr: true,
-        color: true,
-        website: true,
-        aliases: true,
-        fileExtensions: true,
-        paradigms: true,
-        typing: true,
-        popularity: true,
-      },
-    });
-
-    await this.cache.set(
-      cacheKey,
-      languages,
-      TECH_SKILLS_CACHE_TTL.LANGUAGES_LIST,
-    );
-    return languages;
+    return this.languageQuery.getAllLanguages();
   }
 
-  /**
-   * Search programming languages
-   */
+  /** Search programming languages */
   async searchLanguages(
     query: string,
     limit = 20,
   ): Promise<ProgrammingLanguageDto[]> {
-    const normalizedQuery = query.toLowerCase().trim();
-    if (normalizedQuery.length < 1) return [];
-
-    const queryHash = crypto
-      .createHash('md5')
-      .update(`lang:${normalizedQuery}`)
-      .digest('hex')
-      .slice(0, 8);
-    const cacheKey = `${TECH_SKILLS_CACHE_KEYS.SKILLS_SEARCH}${queryHash}`;
-
-    const cached = await this.cache.get<ProgrammingLanguageDto[]>(cacheKey);
-    if (cached) return cached;
-
-    // Search using unaccent for accent-insensitive search
-    const languages = await this.prisma.$queryRaw<ProgrammingLanguageDto[]>`
-      SELECT 
-        id,
-        slug,
-        "nameEn",
-        "namePtBr",
-        color,
-        website,
-        aliases,
-        "fileExtensions",
-        paradigms,
-        typing,
-        popularity
-      FROM "ProgrammingLanguage"
-      WHERE "isActive" = true
-        AND (
-          immutable_unaccent(lower("nameEn")) LIKE '%' || immutable_unaccent(lower(${normalizedQuery})) || '%'
-          OR immutable_unaccent(lower("namePtBr")) LIKE '%' || immutable_unaccent(lower(${normalizedQuery})) || '%'
-          OR slug LIKE '%' || ${normalizedQuery} || '%'
-          OR ${normalizedQuery} = ANY(aliases)
-        )
-      ORDER BY popularity DESC
-      LIMIT ${limit}
-    `;
-
-    await this.cache.set(
-      cacheKey,
-      languages,
-      TECH_SKILLS_CACHE_TTL.SKILLS_SEARCH,
-    );
-    return languages;
+    return this.languageQuery.searchLanguages(query, limit);
   }
 
-  /**
-   * Get all skills
-   */
+  /** Get all skills */
   async getAllSkills(): Promise<TechSkillDto[]> {
-    const cacheKey = TECH_SKILLS_CACHE_KEYS.SKILLS_LIST;
-
-    const cached = await this.cache.get<TechSkillDto[]>(cacheKey);
-    if (cached) return cached;
-
-    const skills = await this.prisma.techSkill.findMany({
-      where: { isActive: true },
-      orderBy: { popularity: 'desc' },
-      include: {
-        niche: {
-          select: {
-            slug: true,
-            nameEn: true,
-            namePtBr: true,
-          },
-        },
-      },
-    });
-
-    const result: TechSkillDto[] = skills.map((s) => ({
-      id: s.id,
-      slug: s.slug,
-      nameEn: s.nameEn,
-      namePtBr: s.namePtBr,
-      type: s.type as SkillType,
-      icon: s.icon,
-      color: s.color,
-      website: s.website,
-      aliases: s.aliases,
-      popularity: s.popularity,
-      niche: s.niche,
-    }));
-
-    await this.cache.set(cacheKey, result, TECH_SKILLS_CACHE_TTL.SKILLS_LIST);
-    return result;
+    return this.skillQuery.getAllSkills();
   }
 
-  /**
-   * Get skills by niche
-   */
+  /** Get skills by niche */
   async getSkillsByNiche(nicheSlug: string): Promise<TechSkillDto[]> {
-    const cacheKey = `${TECH_SKILLS_CACHE_KEYS.SKILLS_BY_NICHE}${nicheSlug}`;
-
-    const cached = await this.cache.get<TechSkillDto[]>(cacheKey);
-    if (cached) return cached;
-
-    const skills = await this.prisma.techSkill.findMany({
-      where: {
-        isActive: true,
-        niche: { slug: nicheSlug },
-      },
-      orderBy: { popularity: 'desc' },
-      include: {
-        niche: {
-          select: {
-            slug: true,
-            nameEn: true,
-            namePtBr: true,
-          },
-        },
-      },
-    });
-
-    const result: TechSkillDto[] = skills.map((s) => ({
-      id: s.id,
-      slug: s.slug,
-      nameEn: s.nameEn,
-      namePtBr: s.namePtBr,
-      type: s.type as SkillType,
-      icon: s.icon,
-      color: s.color,
-      website: s.website,
-      aliases: s.aliases,
-      popularity: s.popularity,
-      niche: s.niche,
-    }));
-
-    await this.cache.set(
-      cacheKey,
-      result,
-      TECH_SKILLS_CACHE_TTL.SKILLS_BY_NICHE,
-    );
-    return result;
+    return this.skillQuery.getSkillsByNiche(nicheSlug);
   }
 
-  /**
-   * Get skills by type
-   */
+  /** Get skills by type */
   async getSkillsByType(type: SkillType, limit = 50): Promise<TechSkillDto[]> {
-    const skills = await this.prisma.techSkill.findMany({
-      where: {
-        isActive: true,
-        type,
-      },
-      take: limit,
-      orderBy: { popularity: 'desc' },
-      include: {
-        niche: {
-          select: {
-            slug: true,
-            nameEn: true,
-            namePtBr: true,
-          },
-        },
-      },
-    });
-
-    return skills.map((s) => ({
-      id: s.id,
-      slug: s.slug,
-      nameEn: s.nameEn,
-      namePtBr: s.namePtBr,
-      type: s.type as SkillType,
-      icon: s.icon,
-      color: s.color,
-      website: s.website,
-      aliases: s.aliases,
-      popularity: s.popularity,
-      niche: s.niche,
-    }));
+    return this.skillQuery.getSkillsByType(type, limit);
   }
 
-  /**
-   * Search skills
-   */
+  /** Search skills */
   async searchSkills(query: string, limit = 20): Promise<TechSkillDto[]> {
-    const normalizedQuery = query.toLowerCase().trim();
-    if (normalizedQuery.length < 1) return [];
-
-    const queryHash = crypto
-      .createHash('md5')
-      .update(`skill:${normalizedQuery}`)
-      .digest('hex')
-      .slice(0, 8);
-    const cacheKey = `${TECH_SKILLS_CACHE_KEYS.SKILLS_SEARCH}${queryHash}`;
-
-    const cached = await this.cache.get<TechSkillDto[]>(cacheKey);
-    if (cached) return cached;
-
-    // Search using unaccent for accent-insensitive search
-    const skills = await this.prisma.$queryRaw<
-      Array<{
-        id: string;
-        slug: string;
-        nameEn: string;
-        namePtBr: string;
-        type: string;
-        icon: string | null;
-        color: string | null;
-        website: string | null;
-        aliases: string[];
-        popularity: number;
-        niche_slug: string | null;
-        niche_nameEn: string | null;
-        niche_namePtBr: string | null;
-      }>
-    >`
-      SELECT 
-        s.id,
-        s.slug,
-        s."nameEn",
-        s."namePtBr",
-        s.type,
-        s.icon,
-        s.color,
-        s.website,
-        s.aliases,
-        s.popularity,
-        n.slug as niche_slug,
-        n."nameEn" as "niche_nameEn",
-        n."namePtBr" as "niche_namePtBr"
-      FROM "TechSkill" s
-      LEFT JOIN "TechNiche" n ON s."nicheId" = n.id
-      WHERE s."isActive" = true
-        AND (
-          immutable_unaccent(lower(s."nameEn")) LIKE '%' || immutable_unaccent(lower(${normalizedQuery})) || '%'
-          OR immutable_unaccent(lower(s."namePtBr")) LIKE '%' || immutable_unaccent(lower(${normalizedQuery})) || '%'
-          OR s.slug LIKE '%' || ${normalizedQuery} || '%'
-          OR ${normalizedQuery} = ANY(s.aliases)
-          OR ${normalizedQuery} = ANY(s.keywords)
-        )
-      ORDER BY s.popularity DESC
-      LIMIT ${limit}
-    `;
-
-    const result: TechSkillDto[] = skills.map((s) => ({
-      id: s.id,
-      slug: s.slug,
-      nameEn: s.nameEn,
-      namePtBr: s.namePtBr,
-      type: s.type as SkillType,
-      icon: s.icon,
-      color: s.color,
-      website: s.website,
-      aliases: s.aliases,
-      popularity: s.popularity,
-      niche: s.niche_slug
-        ? {
-            slug: s.niche_slug,
-            nameEn: s.niche_nameEn!,
-            namePtBr: s.niche_namePtBr!,
-          }
-        : null,
-    }));
-
-    await this.cache.set(cacheKey, result, TECH_SKILLS_CACHE_TTL.SKILLS_SEARCH);
-    return result;
+    return this.skillSearch.searchSkills(query, limit);
   }
 
-  /**
-   * Combined search for languages and skills
-   */
+  /** Combined search for languages and skills */
   async searchAll(
     query: string,
     limit = 20,
diff --git a/src/tech-skills/services/tech-skills-sync.service.ts b/src/tech-skills/services/tech-skills-sync.service.ts
index f72bbdf..e20dbca 100644
--- a/src/tech-skills/services/tech-skills-sync.service.ts
+++ b/src/tech-skills/services/tech-skills-sync.service.ts
@@ -1,395 +1,33 @@
 /**
- * Tech Skills Sync Service
- * Synchronizes tech skills from external sources (GitHub Linguist, Stack Overflow)
+ * Tech Skills Sync Service (Facade)
+ * Orchestrates synchronization of tech skills from external sources
+ * Delegates to specialized services for implementation
  */
 
 import { Injectable } from '@nestjs/common';
-import { PrismaService } from '../../prisma/prisma.service';
 import { CacheService } from '../../common/cache/cache.service';
 import { AppLoggerService } from '../../common/logger/logger.service';
 import { GithubLinguistParserService } from './github-linguist-parser.service';
 import { StackOverflowParserService } from './stackoverflow-parser.service';
-import type {
-  TechSkillsSyncResult,
-  ParsedLanguage,
-  ParsedSkill,
-  TechAreaType,
-} from '../interfaces';
-
-// Predefined tech areas and niches
-const TECH_AREAS: Array<{
-  type: TechAreaType;
-  nameEn: string;
-  namePtBr: string;
-  descriptionEn: string;
-  descriptionPtBr: string;
-  icon: string;
-  color: string;
-  order: number;
-}> = [
-  {
-    type: 'DEVELOPMENT',
-    nameEn: 'Development',
-    namePtBr: 'Desenvolvimento',
-    descriptionEn: 'Software development and programming',
-    descriptionPtBr: 'Desenvolvimento de software e programação',
-    icon: 'code',
-    color: '#3B82F6',
-    order: 1,
-  },
-  {
-    type: 'DEVOPS',
-    nameEn: 'DevOps & Infrastructure',
-    namePtBr: 'DevOps e Infraestrutura',
-    descriptionEn: 'DevOps, cloud infrastructure, and operations',
-    descriptionPtBr: 'DevOps, infraestrutura cloud e operações',
-    icon: 'server',
-    color: '#8B5CF6',
-    order: 2,
-  },
-  {
-    type: 'DATA',
-    nameEn: 'Data & AI',
-    namePtBr: 'Dados e IA',
-    descriptionEn: 'Data science, analytics, machine learning, and AI',
-    descriptionPtBr: 'Ciência de dados, analytics, machine learning e IA',
-    icon: 'database',
-    color: '#10B981',
-    order: 3,
-  },
-  {
-    type: 'SECURITY',
-    nameEn: 'Security',
-    namePtBr: 'Segurança',
-    descriptionEn: 'Cybersecurity, penetration testing, and compliance',
-    descriptionPtBr: 'Cibersegurança, testes de penetração e conformidade',
-    icon: 'shield',
-    color: '#EF4444',
-    order: 4,
-  },
-  {
-    type: 'DESIGN',
-    nameEn: 'Design',
-    namePtBr: 'Design',
-    descriptionEn: 'UI/UX design, product design, and visual design',
-    descriptionPtBr: 'Design UI/UX, design de produto e design visual',
-    icon: 'palette',
-    color: '#EC4899',
-    order: 5,
-  },
-  {
-    type: 'PRODUCT',
-    nameEn: 'Product',
-    namePtBr: 'Produto',
-    descriptionEn: 'Product management, strategy, and growth',
-    descriptionPtBr: 'Gestão de produto, estratégia e crescimento',
-    icon: 'lightbulb',
-    color: '#F59E0B',
-    order: 6,
-  },
-  {
-    type: 'QA',
-    nameEn: 'Quality Assurance',
-    namePtBr: 'Qualidade',
-    descriptionEn: 'Testing, quality assurance, and automation',
-    descriptionPtBr: 'Testes, garantia de qualidade e automação',
-    icon: 'check-circle',
-    color: '#14B8A6',
-    order: 7,
-  },
-  {
-    type: 'INFRASTRUCTURE',
-    nameEn: 'Infrastructure',
-    namePtBr: 'Infraestrutura',
-    descriptionEn: 'Networks, systems administration, and hardware',
-    descriptionPtBr: 'Redes, administração de sistemas e hardware',
-    icon: 'network',
-    color: '#6366F1',
-    order: 8,
-  },
-  {
-    type: 'OTHER',
-    nameEn: 'Other',
-    namePtBr: 'Outros',
-    descriptionEn: 'Other tech skills and tools',
-    descriptionPtBr: 'Outras habilidades e ferramentas tech',
-    icon: 'more-horizontal',
-    color: '#64748B',
-    order: 99,
-  },
-];
-
-// Predefined niches
-const TECH_NICHES: Array<{
-  slug: string;
-  areaType: TechAreaType;
-  nameEn: string;
-  namePtBr: string;
-  descriptionEn: string;
-  descriptionPtBr: string;
-  icon: string;
-  color: string;
-  order: number;
-}> = [
-  // Development niches
-  {
-    slug: 'frontend',
-    areaType: 'DEVELOPMENT',
-    nameEn: 'Frontend',
-    namePtBr: 'Frontend',
-    descriptionEn: 'User interface and client-side development',
-    descriptionPtBr: 'Interface do usuário e desenvolvimento client-side',
-    icon: 'layout',
-    color: '#3B82F6',
-    order: 1,
-  },
-  {
-    slug: 'backend',
-    areaType: 'DEVELOPMENT',
-    nameEn: 'Backend',
-    namePtBr: 'Backend',
-    descriptionEn: 'Server-side development and APIs',
-    descriptionPtBr: 'Desenvolvimento server-side e APIs',
-    icon: 'server',
-    color: '#10B981',
-    order: 2,
-  },
-  {
-    slug: 'fullstack',
-    areaType: 'DEVELOPMENT',
-    nameEn: 'Fullstack',
-    namePtBr: 'Fullstack',
-    descriptionEn: 'Full-stack web development',
-    descriptionPtBr: 'Desenvolvimento web full-stack',
-    icon: 'layers',
-    color: '#8B5CF6',
-    order: 3,
-  },
-  {
-    slug: 'mobile',
-    areaType: 'DEVELOPMENT',
-    nameEn: 'Mobile',
-    namePtBr: 'Mobile',
-    descriptionEn: 'iOS, Android, and cross-platform mobile development',
-    descriptionPtBr: 'Desenvolvimento mobile iOS, Android e multiplataforma',
-    icon: 'smartphone',
-    color: '#F59E0B',
-    order: 4,
-  },
-  {
-    slug: 'game-dev',
-    areaType: 'DEVELOPMENT',
-    nameEn: 'Game Development',
-    namePtBr: 'Desenvolvimento de Jogos',
-    descriptionEn: 'Video game development',
-    descriptionPtBr: 'Desenvolvimento de jogos',
-    icon: 'gamepad',
-    color: '#EF4444',
-    order: 5,
-  },
-  {
-    slug: 'embedded',
-    areaType: 'DEVELOPMENT',
-    nameEn: 'Embedded Systems',
-    namePtBr: 'Sistemas Embarcados',
-    descriptionEn: 'Embedded and IoT development',
-    descriptionPtBr: 'Desenvolvimento embarcado e IoT',
-    icon: 'cpu',
-    color: '#6366F1',
-    order: 6,
-  },
-  {
-    slug: 'blockchain',
-    areaType: 'DEVELOPMENT',
-    nameEn: 'Blockchain',
-    namePtBr: 'Blockchain',
-    descriptionEn: 'Blockchain and Web3 development',
-    descriptionPtBr: 'Desenvolvimento blockchain e Web3',
-    icon: 'link',
-    color: '#14B8A6',
-    order: 7,
-  },
-
-  // DevOps niches
-  {
-    slug: 'devops',
-    areaType: 'DEVOPS',
-    nameEn: 'DevOps',
-    namePtBr: 'DevOps',
-    descriptionEn: 'CI/CD, automation, and DevOps practices',
-    descriptionPtBr: 'CI/CD, automação e práticas DevOps',
-    icon: 'git-branch',
-    color: '#8B5CF6',
-    order: 1,
-  },
-  {
-    slug: 'cloud',
-    areaType: 'DEVOPS',
-    nameEn: 'Cloud',
-    namePtBr: 'Cloud',
-    descriptionEn: 'Cloud platforms and services',
-    descriptionPtBr: 'Plataformas e serviços cloud',
-    icon: 'cloud',
-    color: '#3B82F6',
-    order: 2,
-  },
-  {
-    slug: 'sre',
-    areaType: 'DEVOPS',
-    nameEn: 'Site Reliability',
-    namePtBr: 'Confiabilidade de Site',
-    descriptionEn: 'Site reliability engineering and monitoring',
-    descriptionPtBr: 'Engenharia de confiabilidade e monitoramento',
-    icon: 'activity',
-    color: '#EF4444',
-    order: 3,
-  },
-
-  // Data niches
-  {
-    slug: 'data-science',
-    areaType: 'DATA',
-    nameEn: 'Data Science',
-    namePtBr: 'Ciência de Dados',
-    descriptionEn: 'Data analysis and statistical modeling',
-    descriptionPtBr: 'Análise de dados e modelagem estatística',
-    icon: 'bar-chart',
-    color: '#10B981',
-    order: 1,
-  },
-  {
-    slug: 'machine-learning',
-    areaType: 'DATA',
-    nameEn: 'Machine Learning',
-    namePtBr: 'Machine Learning',
-    descriptionEn: 'Machine learning and deep learning',
-    descriptionPtBr: 'Machine learning e deep learning',
-    icon: 'brain',
-    color: '#8B5CF6',
-    order: 2,
-  },
-  {
-    slug: 'data-engineering',
-    areaType: 'DATA',
-    nameEn: 'Data Engineering',
-    namePtBr: 'Engenharia de Dados',
-    descriptionEn: 'Data pipelines and infrastructure',
-    descriptionPtBr: 'Pipelines de dados e infraestrutura',
-    icon: 'database',
-    color: '#F59E0B',
-    order: 3,
-  },
-  {
-    slug: 'data-analytics',
-    areaType: 'DATA',
-    nameEn: 'Data Analytics',
-    namePtBr: 'Análise de Dados',
-    descriptionEn: 'Business intelligence and analytics',
-    descriptionPtBr: 'Business intelligence e analytics',
-    icon: 'pie-chart',
-    color: '#3B82F6',
-    order: 4,
-  },
-
-  // Security niches
-  {
-    slug: 'security',
-    areaType: 'SECURITY',
-    nameEn: 'Security',
-    namePtBr: 'Segurança',
-    descriptionEn: 'Application and infrastructure security',
-    descriptionPtBr: 'Segurança de aplicações e infraestrutura',
-    icon: 'shield',
-    color: '#EF4444',
-    order: 1,
-  },
-  {
-    slug: 'pentesting',
-    areaType: 'SECURITY',
-    nameEn: 'Penetration Testing',
-    namePtBr: 'Teste de Penetração',
-    descriptionEn: 'Ethical hacking and vulnerability assessment',
-    descriptionPtBr: 'Hacking ético e avaliação de vulnerabilidades',
-    icon: 'target',
-    color: '#DC2626',
-    order: 2,
-  },
-
-  // Design niches
-  {
-    slug: 'design',
-    areaType: 'DESIGN',
-    nameEn: 'UI/UX Design',
-    namePtBr: 'Design UI/UX',
-    descriptionEn: 'User interface and experience design',
-    descriptionPtBr: 'Design de interface e experiência do usuário',
-    icon: 'figma',
-    color: '#EC4899',
-    order: 1,
-  },
-
-  // QA niches
-  {
-    slug: 'qa',
-    areaType: 'QA',
-    nameEn: 'QA Testing',
-    namePtBr: 'Testes QA',
-    descriptionEn: 'Manual and automated testing',
-    descriptionPtBr: 'Testes manuais e automatizados',
-    icon: 'check-square',
-    color: '#14B8A6',
-    order: 1,
-  },
-  {
-    slug: 'test-automation',
-    areaType: 'QA',
-    nameEn: 'Test Automation',
-    namePtBr: 'Automação de Testes',
-    descriptionEn: 'Test automation frameworks and tools',
-    descriptionPtBr: 'Frameworks e ferramentas de automação de testes',
-    icon: 'play-circle',
-    color: '#10B981',
-    order: 2,
-  },
-
-  // Infrastructure niches
-  {
-    slug: 'networks',
-    areaType: 'INFRASTRUCTURE',
-    nameEn: 'Networks',
-    namePtBr: 'Redes',
-    descriptionEn: 'Network administration and architecture',
-    descriptionPtBr: 'Administração e arquitetura de redes',
-    icon: 'wifi',
-    color: '#6366F1',
-    order: 1,
-  },
-  {
-    slug: 'sysadmin',
-    areaType: 'INFRASTRUCTURE',
-    nameEn: 'System Administration',
-    namePtBr: 'Administração de Sistemas',
-    descriptionEn: 'Server and system administration',
-    descriptionPtBr: 'Administração de servidores e sistemas',
-    icon: 'terminal',
-    color: '#64748B',
-    order: 2,
-  },
-];
+import { TechAreasSyncService } from './tech-areas-sync.service';
+import { TechNichesSyncService } from './tech-niches-sync.service';
+import { LanguagesSyncService } from './languages-sync.service';
+import { SkillsDataSyncService } from './skills-data-sync.service';
+import type { TechSkillsSyncResult } from '../interfaces';
 
 @Injectable()
 export class TechSkillsSyncService {
   constructor(
-    private readonly prisma: PrismaService,
     private readonly cache: CacheService,
     private readonly logger: AppLoggerService,
     private readonly linguistParser: GithubLinguistParserService,
     private readonly stackOverflowParser: StackOverflowParserService,
+    private readonly techAreasSync: TechAreasSyncService,
+    private readonly techNichesSync: TechNichesSyncService,
+    private readonly languagesSync: LanguagesSyncService,
+    private readonly skillsDataSync: SkillsDataSyncService,
   ) {}
 
-  /**
-   * Run full sync of tech skills from external sources
-   */
   async runSync(): Promise<TechSkillsSyncResult> {
     this.logger.log('Starting tech skills sync...');
 
@@ -404,242 +42,44 @@ export class TechSkillsSyncService {
     };
 
     try {
-      // 1. Create/update tech areas
-      result.areasCreated = await this.syncTechAreas();
+      result.areasCreated = await this.techAreasSync.syncAreas();
       this.logger.log(
         `Tech areas synced: ${result.areasCreated} created/updated`,
       );
 
-      // 2. Create/update tech niches
-      result.nichesCreated = await this.syncTechNiches();
+      result.nichesCreated = await this.techNichesSync.syncNiches();
       this.logger.log(
         `Tech niches synced: ${result.nichesCreated} created/updated`,
       );
 
-      // 3. Fetch and sync programming languages from GitHub Linguist
       const languages = await this.linguistParser.fetchAndParse();
-      const langResult = await this.syncLanguages(languages);
+      const langResult = await this.languagesSync.syncLanguages(languages);
       result.languagesInserted = langResult.inserted;
       result.languagesUpdated = langResult.updated;
       this.logger.log(
         `Languages synced: ${langResult.inserted} inserted, ${langResult.updated} updated`,
       );
 
-      // 4. Fetch and sync skills from Stack Overflow
       const skills = await this.stackOverflowParser.fetchAndParse();
-      const skillResult = await this.syncSkills(skills);
+      const skillResult = await this.skillsDataSync.syncSkills(skills);
       result.skillsInserted = skillResult.inserted;
       result.skillsUpdated = skillResult.updated;
       this.logger.log(
         `Skills synced: ${skillResult.inserted} inserted, ${skillResult.updated} updated`,
       );
 
-      // 5. Clear cache
       await this.clearCache();
-
       this.logger.log('Tech skills sync completed successfully');
     } catch (error) {
-      this.logger.error('Tech skills sync failed', error);
-      result.errors.push(
-        error instanceof Error ? error.message : String(error),
-      );
+      const errorMessage =
+        error instanceof Error ? error.message : String(error);
+      this.logger.error('Tech skills sync failed', errorMessage);
+      result.errors.push(errorMessage);
     }
 
     return result;
   }
 
-  /**
-   * Sync tech areas
-   */
-  private async syncTechAreas(): Promise<number> {
-    let count = 0;
-
-    for (const area of TECH_AREAS) {
-      await this.prisma.techArea.upsert({
-        where: { type: area.type },
-        create: area,
-        update: {
-          nameEn: area.nameEn,
-          namePtBr: area.namePtBr,
-          descriptionEn: area.descriptionEn,
-          descriptionPtBr: area.descriptionPtBr,
-          icon: area.icon,
-          color: area.color,
-          order: area.order,
-        },
-      });
-      count++;
-    }
-
-    return count;
-  }
-
-  /**
-   * Sync tech niches
-   */
-  private async syncTechNiches(): Promise<number> {
-    let count = 0;
-
-    for (const niche of TECH_NICHES) {
-      const area = await this.prisma.techArea.findUnique({
-        where: { type: niche.areaType },
-      });
-
-      if (!area) {
-        this.logger.warn(
-          `Area not found for niche ${niche.slug}: ${niche.areaType}`,
-        );
-        continue;
-      }
-
-      await this.prisma.techNiche.upsert({
-        where: { slug: niche.slug },
-        create: {
-          slug: niche.slug,
-          nameEn: niche.nameEn,
-          namePtBr: niche.namePtBr,
-          descriptionEn: niche.descriptionEn,
-          descriptionPtBr: niche.descriptionPtBr,
-          icon: niche.icon,
-          color: niche.color,
-          order: niche.order,
-          areaId: area.id,
-        },
-        update: {
-          nameEn: niche.nameEn,
-          namePtBr: niche.namePtBr,
-          descriptionEn: niche.descriptionEn,
-          descriptionPtBr: niche.descriptionPtBr,
-          icon: niche.icon,
-          color: niche.color,
-          order: niche.order,
-          areaId: area.id,
-        },
-      });
-      count++;
-    }
-
-    return count;
-  }
-
-  /**
-   * Sync programming languages
-   */
-  private async syncLanguages(
-    languages: ParsedLanguage[],
-  ): Promise<{ inserted: number; updated: number }> {
-    let inserted = 0;
-    let updated = 0;
-
-    for (const lang of languages) {
-      const existing = await this.prisma.programmingLanguage.findUnique({
-        where: { slug: lang.slug },
-      });
-
-      if (existing) {
-        await this.prisma.programmingLanguage.update({
-          where: { slug: lang.slug },
-          data: {
-            nameEn: lang.nameEn,
-            namePtBr: lang.namePtBr,
-            color: lang.color,
-            website: lang.website,
-            aliases: lang.aliases,
-            fileExtensions: lang.extensions,
-            paradigms: lang.paradigms,
-            typing: lang.typing,
-            popularity: lang.popularity,
-          },
-        });
-        updated++;
-      } else {
-        await this.prisma.programmingLanguage.create({
-          data: {
-            slug: lang.slug,
-            nameEn: lang.nameEn,
-            namePtBr: lang.namePtBr,
-            color: lang.color,
-            website: lang.website,
-            aliases: lang.aliases,
-            fileExtensions: lang.extensions,
-            paradigms: lang.paradigms,
-            typing: lang.typing,
-            popularity: lang.popularity,
-          },
-        });
-        inserted++;
-      }
-    }
-
-    return { inserted, updated };
-  }
-
-  /**
-   * Sync tech skills
-   */
-  private async syncSkills(
-    skills: ParsedSkill[],
-  ): Promise<{ inserted: number; updated: number }> {
-    let inserted = 0;
-    let updated = 0;
-
-    for (const skill of skills) {
-      // Find niche if specified
-      let nicheId: string | null = null;
-      if (skill.nicheSlug) {
-        const niche = await this.prisma.techNiche.findUnique({
-          where: { slug: skill.nicheSlug },
-        });
-        nicheId = niche?.id || null;
-      }
-
-      const existing = await this.prisma.techSkill.findUnique({
-        where: { slug: skill.slug },
-      });
-
-      if (existing) {
-        await this.prisma.techSkill.update({
-          where: { slug: skill.slug },
-          data: {
-            nameEn: skill.nameEn,
-            namePtBr: skill.namePtBr,
-            type: skill.type,
-            nicheId,
-            color: skill.color,
-            icon: skill.icon,
-            website: skill.website,
-            aliases: skill.aliases,
-            keywords: skill.keywords,
-            popularity: skill.popularity,
-          },
-        });
-        updated++;
-      } else {
-        await this.prisma.techSkill.create({
-          data: {
-            slug: skill.slug,
-            nameEn: skill.nameEn,
-            namePtBr: skill.namePtBr,
-            type: skill.type,
-            nicheId,
-            color: skill.color,
-            icon: skill.icon,
-            website: skill.website,
-            aliases: skill.aliases,
-            keywords: skill.keywords,
-            popularity: skill.popularity,
-          },
-        });
-        inserted++;
-      }
-    }
-
-    return { inserted, updated };
-  }
-
-  /**
-   * Clear all tech skills cache
-   */
   private async clearCache(): Promise<void> {
     await Promise.all([
       this.cache.delete('tech:languages:list'),
diff --git a/src/tech-skills/tech-skills.controller.ts b/src/tech-skills/tech-skills.controller.ts
index 40d73c0..99035c2 100644
--- a/src/tech-skills/tech-skills.controller.ts
+++ b/src/tech-skills/tech-skills.controller.ts
@@ -1,160 +1,8 @@
 /**
  * Tech Skills Controller
- * API endpoints for tech skills, languages, areas, and niches
+ * Re-exports for backward compatibility
+ * @deprecated Import from controllers/ directory instead
  */
 
-import {
-  Controller,
-  Get,
-  Post,
-  Query,
-  Param,
-  UseGuards,
-  HttpCode,
-  HttpStatus,
-} from '@nestjs/common';
-import { TechSkillsSyncService } from './services/tech-skills-sync.service';
-import { TechSkillsQueryService } from './services/tech-skills-query.service';
-import { InternalAuthGuard } from '../mec-sync/guards/internal-auth.guard';
-import { Public } from '../auth/decorators/public.decorator';
-import type { TechAreaType, SkillType } from './interfaces';
-
-@Controller('tech-skills')
-export class TechSkillsController {
-  constructor(
-    private readonly syncService: TechSkillsSyncService,
-    private readonly queryService: TechSkillsQueryService,
-  ) {}
-
-  // =========================================
-  // Sync Endpoints (Internal/Admin only)
-  // =========================================
-
-  /**
-   * Trigger manual sync of tech skills from external sources
-   * Requires internal API token (bypasses JWT auth)
-   */
-  @Post('sync')
-  @Public() // Bypass global JWT guard
-  @UseGuards(InternalAuthGuard) // Use internal token instead
-  @HttpCode(HttpStatus.OK)
-  async triggerSync() {
-    const result = await this.syncService.runSync();
-    return {
-      message: 'Tech skills sync completed',
-      result,
-    };
-  }
-
-  // =========================================
-  // Public Query Endpoints
-  // =========================================
-
-  /**
-   * Get all tech areas
-   */
-  @Get('areas')
-  @Public()
-  async getAreas() {
-    return this.queryService.getAllAreas();
-  }
-
-  /**
-   * Get all tech niches
-   */
-  @Get('niches')
-  @Public()
-  async getNiches() {
-    return this.queryService.getAllNiches();
-  }
-
-  /**
-   * Get niches by area type
-   */
-  @Get('areas/:areaType/niches')
-  @Public()
-  async getNichesByArea(@Param('areaType') areaType: TechAreaType) {
-    return this.queryService.getNichesByArea(areaType);
-  }
-
-  /**
-   * Get all programming languages
-   */
-  @Get('languages')
-  @Public()
-  async getLanguages() {
-    return this.queryService.getAllLanguages();
-  }
-
-  /**
-   * Search programming languages
-   */
-  @Get('languages/search')
-  @Public()
-  async searchLanguages(
-    @Query('q') query: string,
-    @Query('limit') limit?: string,
-  ) {
-    return this.queryService.searchLanguages(
-      query,
-      limit ? parseInt(limit, 10) : 20,
-    );
-  }
-
-  /**
-   * Get all skills
-   */
-  @Get('skills')
-  @Public()
-  async getSkills() {
-    return this.queryService.getAllSkills();
-  }
-
-  /**
-   * Search skills
-   */
-  @Get('skills/search')
-  @Public()
-  async searchSkills(
-    @Query('q') query: string,
-    @Query('limit') limit?: string,
-  ) {
-    return this.queryService.searchSkills(
-      query,
-      limit ? parseInt(limit, 10) : 20,
-    );
-  }
-
-  /**
-   * Get skills by niche
-   */
-  @Get('niches/:nicheSlug/skills')
-  @Public()
-  async getSkillsByNiche(@Param('nicheSlug') nicheSlug: string) {
-    return this.queryService.getSkillsByNiche(nicheSlug);
-  }
-
-  /**
-   * Get skills by type
-   */
-  @Get('skills/type/:type')
-  @Public()
-  async getSkillsByType(
-    @Param('type') type: SkillType,
-    @Query('limit') limit?: string,
-  ) {
-    return this.queryService.getSkillsByType(
-      type,
-      limit ? parseInt(limit, 10) : 50,
-    );
-  }
-
-  /**
-   * Combined search (languages + skills)
-   */
-  @Get('search')
-  @Public()
-  async searchAll(@Query('q') query: string, @Query('limit') limit?: string) {
-    return this.queryService.searchAll(query, limit ? parseInt(limit, 10) : 20);
-  }
-}
+export { TechSkillsSyncController } from './controllers/tech-skills-sync.controller';
+export { TechSkillsQueryController } from './controllers/tech-skills-query.controller';
diff --git a/src/tech-skills/tech-skills.module.ts b/src/tech-skills/tech-skills.module.ts
index 9310c0c..9924fc5 100644
--- a/src/tech-skills/tech-skills.module.ts
+++ b/src/tech-skills/tech-skills.module.ts
@@ -5,22 +5,56 @@
 
 import { Module } from '@nestjs/common';
 import { ConfigModule } from '@nestjs/config';
-import { TechSkillsController } from './tech-skills.controller';
+import {
+  TechSkillsSyncController,
+  TechSkillsQueryController,
+  TechAreaController,
+  TechNicheController,
+  TechSkillController,
+} from './controllers';
 import { TechSkillsSyncService } from './services/tech-skills-sync.service';
 import { TechSkillsQueryService } from './services/tech-skills-query.service';
+import { TechAreaQueryService } from './services/area-query.service';
+import { TechNicheQueryService } from './services/niche-query.service';
+import { LanguageQueryService } from './services/language-query.service';
+import { SkillQueryService } from './services/skill-query.service';
+import { SkillSearchService } from './services/skill-search.service';
 import { GithubLinguistParserService } from './services/github-linguist-parser.service';
 import { StackOverflowParserService } from './services/stackoverflow-parser.service';
+import { TechAreasSyncService } from './services/tech-areas-sync.service';
+import { TechNichesSyncService } from './services/tech-niches-sync.service';
+import { LanguagesSyncService } from './services/languages-sync.service';
+import { SkillsDataSyncService } from './services/skills-data-sync.service';
 import { PrismaModule } from '../prisma/prisma.module';
 import { InternalAuthGuard } from '../mec-sync/guards/internal-auth.guard';
 
 @Module({
   imports: [ConfigModule, PrismaModule],
-  controllers: [TechSkillsController],
+  controllers: [
+    TechSkillsSyncController,
+    TechSkillsQueryController,
+    TechAreaController,
+    TechNicheController,
+    TechSkillController,
+  ],
   providers: [
+    // Sync services
+    TechAreasSyncService,
+    TechNichesSyncService,
+    LanguagesSyncService,
+    SkillsDataSyncService,
     TechSkillsSyncService,
+    // Query services
     TechSkillsQueryService,
+    TechAreaQueryService,
+    TechNicheQueryService,
+    LanguageQueryService,
+    SkillQueryService,
+    SkillSearchService,
+    // Parser services
     GithubLinguistParserService,
     StackOverflowParserService,
+    // Guards
     InternalAuthGuard,
   ],
   exports: [TechSkillsSyncService, TechSkillsQueryService],
diff --git a/src/tech-skills/utils/display-name.util.ts b/src/tech-skills/utils/display-name.util.ts
new file mode 100644
index 0000000..0d6f413
--- /dev/null
+++ b/src/tech-skills/utils/display-name.util.ts
@@ -0,0 +1,65 @@
+/**
+ * Display Name Formatter
+ *
+ * Formats skill tags for display with proper capitalization.
+ */
+
+const SPECIAL_CASES: Record<string, string> = {
+  javascript: 'JavaScript',
+  typescript: 'TypeScript',
+  nodejs: 'Node.js',
+  'node.js': 'Node.js',
+  reactjs: 'React',
+  vuejs: 'Vue.js',
+  angularjs: 'AngularJS',
+  nextjs: 'Next.js',
+  nuxtjs: 'Nuxt.js',
+  expressjs: 'Express',
+  nestjs: 'NestJS',
+  graphql: 'GraphQL',
+  mongodb: 'MongoDB',
+  postgresql: 'PostgreSQL',
+  mysql: 'MySQL',
+  aws: 'AWS',
+  gcp: 'Google Cloud',
+  css: 'CSS',
+  html: 'HTML',
+  sql: 'SQL',
+  api: 'API',
+  rest: 'REST',
+  oauth: 'OAuth',
+  jwt: 'JWT',
+  'ci-cd': 'CI/CD',
+  devops: 'DevOps',
+  ios: 'iOS',
+  macos: 'macOS',
+};
+
+/**
+ * Format tag name for display
+ */
+export function formatDisplayName(name: string): string {
+  const lower = name.toLowerCase();
+  if (Object.prototype.hasOwnProperty.call(SPECIAL_CASES, lower)) {
+    return SPECIAL_CASES[lower];
+  }
+
+  // Title case
+  return name
+    .split(/[-_\s]/)
+    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
+    .join(' ');
+}
+
+/**
+ * Normalize tag name to slug
+ */
+export function normalizeSlug(name: string): string {
+  return name
+    .toLowerCase()
+    .replace(/\./g, '-')
+    .replace(/\s+/g, '-')
+    .replace(/[^a-z0-9-]/g, '')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
diff --git a/src/tech-skills/utils/index.ts b/src/tech-skills/utils/index.ts
new file mode 100644
index 0000000..0dfb22d
--- /dev/null
+++ b/src/tech-skills/utils/index.ts
@@ -0,0 +1,10 @@
+/**
+ * Tech Skills Utilities - Barrel Export
+ */
+
+export { formatDisplayName, normalizeSlug } from './display-name.util';
+export { isProgrammingLanguage, shouldSkipTag } from './tag-filter.util';
+export { shouldIncludeStackOverflowTag } from './stackoverflow-tag-filter.util';
+export { getAliases, getKeywords } from './skill-metadata.util';
+export * from './skill-mapper.util';
+export { createLanguageSlug } from './language-slug.util';
diff --git a/src/tech-skills/utils/language-slug.util.ts b/src/tech-skills/utils/language-slug.util.ts
new file mode 100644
index 0000000..ce397bb
--- /dev/null
+++ b/src/tech-skills/utils/language-slug.util.ts
@@ -0,0 +1,23 @@
+/**
+ * Language Slug Utility
+ * Creates URL-safe slugs from language names
+ */
+
+/**
+ * Create URL-safe slug from language name
+ * Handles special characters like # and +
+ */
+export function createLanguageSlug(name: string): string {
+  return name
+    .toLowerCase()
+    .replace(/[#+]+/g, (match) => {
+      if (match === '#') return 'sharp';
+      if (match === '++') return 'plusplus';
+      if (match === '+') return 'plus';
+      return '';
+    })
+    .replace(/\s+/g, '-')
+    .replace(/[^a-z0-9-]/g, '')
+    .replace(/-+/g, '-')
+    .replace(/^-|-$/g, '');
+}
diff --git a/src/tech-skills/utils/skill-mapper.util.ts b/src/tech-skills/utils/skill-mapper.util.ts
new file mode 100644
index 0000000..fd47079
--- /dev/null
+++ b/src/tech-skills/utils/skill-mapper.util.ts
@@ -0,0 +1,69 @@
+/**
+ * Skill Mapper Utility
+ * Maps Prisma skills to DTO format
+ */
+
+import type { SkillType } from '../interfaces';
+import type { TechSkillDto, TechSkillRawQueryResult } from '../dtos';
+
+/** Prisma skill with niche relation */
+export interface PrismaSkillWithNiche {
+  id: string;
+  slug: string;
+  nameEn: string;
+  namePtBr: string;
+  type: string;
+  icon: string | null;
+  color: string | null;
+  website: string | null;
+  aliases: string[];
+  popularity: number;
+  niche: { slug: string; nameEn: string; namePtBr: string } | null;
+}
+
+/**
+ * Map Prisma skills to DTO format
+ */
+export function mapSkillsToDto(skills: PrismaSkillWithNiche[]): TechSkillDto[] {
+  return skills.map((s) => ({
+    id: s.id,
+    slug: s.slug,
+    nameEn: s.nameEn,
+    namePtBr: s.namePtBr,
+    type: s.type as SkillType,
+    icon: s.icon,
+    color: s.color,
+    website: s.website,
+    aliases: s.aliases,
+    popularity: s.popularity,
+    niche: s.niche,
+  }));
+}
+
+/**
+ * Map raw SQL query results to DTO format
+ */
+export function mapRawSkillsToDto(
+  skills: TechSkillRawQueryResult[],
+): TechSkillDto[] {
+  return skills.map((s) => ({
+    id: s.id,
+    slug: s.slug,
+    nameEn: s.nameEn,
+    namePtBr: s.namePtBr,
+    type: s.type as SkillType,
+    icon: s.icon,
+    color: s.color,
+    website: s.website,
+    aliases: s.aliases,
+    popularity: s.popularity,
+    niche:
+      s.niche_slug && s.niche_nameEn && s.niche_namePtBr
+        ? {
+            slug: s.niche_slug,
+            nameEn: s.niche_nameEn,
+            namePtBr: s.niche_namePtBr,
+          }
+        : null,
+  }));
+}
diff --git a/src/tech-skills/utils/skill-metadata.util.ts b/src/tech-skills/utils/skill-metadata.util.ts
new file mode 100644
index 0000000..a0b4714
--- /dev/null
+++ b/src/tech-skills/utils/skill-metadata.util.ts
@@ -0,0 +1,54 @@
+/**
+ * Skill Metadata Utilities
+ *
+ * Functions to get aliases and keywords for skills.
+ */
+
+const ALIAS_MAP: Record<string, string[]> = {
+  react: ['reactjs', 'react.js'],
+  'vue.js': ['vuejs', 'vue'],
+  'node.js': ['nodejs', 'node'],
+  'next.js': ['nextjs', 'next'],
+  angular: ['angularjs', 'ng'],
+  express: ['expressjs', 'express.js'],
+  typescript: ['ts'],
+  javascript: ['js', 'es6', 'ecmascript'],
+  kubernetes: ['k8s'],
+  postgresql: ['postgres', 'psql'],
+  mongodb: ['mongo'],
+  elasticsearch: ['elastic', 'es'],
+  tailwindcss: ['tailwind', 'tailwind-css'],
+};
+
+const KEYWORD_MAP: Record<string, string[]> = {
+  react: ['ui', 'components', 'hooks', 'jsx', 'frontend'],
+  'node.js': ['server', 'backend', 'runtime', 'npm'],
+  docker: ['container', 'containerization', 'devops'],
+  kubernetes: ['orchestration', 'container', 'cluster', 'devops'],
+  aws: ['cloud', 'amazon', 'infrastructure'],
+  postgresql: ['database', 'sql', 'relational'],
+  mongodb: ['database', 'nosql', 'document'],
+  graphql: ['api', 'query', 'schema'],
+  tensorflow: ['ai', 'ml', 'deep-learning', 'neural-network'],
+  figma: ['design', 'ui', 'ux', 'prototype'],
+};
+
+/**
+ * Get aliases for a skill
+ */
+export function getAliases(name: string): string[] {
+  const lower = name.toLowerCase();
+  return Object.prototype.hasOwnProperty.call(ALIAS_MAP, lower)
+    ? ALIAS_MAP[lower]
+    : [];
+}
+
+/**
+ * Get search keywords for a skill
+ */
+export function getKeywords(name: string): string[] {
+  const lower = name.toLowerCase();
+  return Object.prototype.hasOwnProperty.call(KEYWORD_MAP, lower)
+    ? KEYWORD_MAP[lower]
+    : [];
+}
diff --git a/src/tech-skills/utils/stackoverflow-tag-filter.util.ts b/src/tech-skills/utils/stackoverflow-tag-filter.util.ts
new file mode 100644
index 0000000..9ded84a
--- /dev/null
+++ b/src/tech-skills/utils/stackoverflow-tag-filter.util.ts
@@ -0,0 +1,35 @@
+/**
+ * Stack Overflow Tag Filter Utilities
+ * Specific utilities for filtering Stack Overflow tags
+ */
+
+import { isProgrammingLanguage, shouldSkipTag } from './tag-filter.util';
+
+/**
+ * Check if a tag should be included in Stack Overflow parsing
+ */
+export function shouldIncludeStackOverflowTag(tagName: string): boolean {
+  // Skip programming languages (handled by GitHub Linguist)
+  if (isProgrammingLanguage(tagName)) {
+    return false;
+  }
+
+  // Skip tags that should be filtered out
+  if (shouldSkipTag(tagName)) {
+    return false;
+  }
+
+  return true;
+}
+
+/**
+ * Check if a tag is a programming language
+ * Re-exported for convenience
+ */
+export { isProgrammingLanguage };
+
+/**
+ * Check if a tag should be skipped
+ * Re-exported for convenience
+ */
+export { shouldSkipTag };
diff --git a/src/tech-skills/utils/tag-filter.util.ts b/src/tech-skills/utils/tag-filter.util.ts
new file mode 100644
index 0000000..da50730
--- /dev/null
+++ b/src/tech-skills/utils/tag-filter.util.ts
@@ -0,0 +1,143 @@
+/**
+ * Tag Filter Utilities
+ *
+ * Functions to filter and validate Stack Overflow tags.
+ */
+
+/**
+ * Programming languages handled by GitHub Linguist (not Stack Overflow)
+ */
+const PROGRAMMING_LANGUAGES = new Set([
+  'javascript',
+  'typescript',
+  'python',
+  'java',
+  'c#',
+  'c++',
+  'c',
+  'go',
+  'rust',
+  'ruby',
+  'php',
+  'swift',
+  'kotlin',
+  'scala',
+  'r',
+  'perl',
+  'haskell',
+  'elixir',
+  'erlang',
+  'clojure',
+  'f#',
+  'lua',
+  'dart',
+  'julia',
+  'matlab',
+  'fortran',
+  'cobol',
+  'pascal',
+  'assembly',
+  'bash',
+  'powershell',
+  'shell',
+  'objective-c',
+  'groovy',
+  'visual-basic',
+  'vba',
+  'delphi',
+  'zig',
+  'nim',
+  'crystal',
+  'v',
+  'solidity',
+]);
+
+/**
+ * Generic/non-tech tags to skip
+ */
+const SKIP_TAGS = new Set([
+  'arrays',
+  'string',
+  'list',
+  'dictionary',
+  'object',
+  'function',
+  'class',
+  'loops',
+  'if-statement',
+  'variables',
+  'sorting',
+  'regex',
+  'date',
+  'datetime',
+  'file',
+  'json',
+  'xml',
+  'csv',
+  'image',
+  'video',
+  'audio',
+  'math',
+  'algorithm',
+  'recursion',
+  'debugging',
+  'performance',
+  'memory',
+  'multithreading',
+  'asynchronous',
+  'oop',
+  'inheritance',
+  'polymorphism',
+  'exception',
+  'error-handling',
+  'unit-testing',
+  'logging',
+  'authentication',
+  'authorization',
+  'encryption',
+  'hashing',
+  'http',
+  'https',
+  'tcp',
+  'udp',
+  'websocket',
+  'cors',
+  'cookies',
+  'session',
+  'cache',
+  'optimization',
+  'deployment',
+  'documentation',
+  'version-control',
+  'code-review',
+  'android',
+  'ios',
+  'windows',
+  'macos',
+  'ubuntu',
+  'debian',
+  'web',
+  'mobile',
+  'desktop',
+  'server',
+  'client',
+  'browser',
+  'database',
+  'frontend',
+  'backend',
+  'fullstack',
+]);
+
+/**
+ * Check if tag is a programming language
+ */
+export function isProgrammingLanguage(name: string): boolean {
+  return PROGRAMMING_LANGUAGES.has(name.toLowerCase());
+}
+
+/**
+ * Check if tag should be skipped
+ */
+export function shouldSkipTag(name: string): boolean {
+  return SKIP_TAGS.has(name.toLowerCase());
+}
diff --git a/src/themes/services/resume-config.repository.ts b/src/themes/services/resume-config.repository.ts
index 335c2c8..61e4a44 100644
--- a/src/themes/services/resume-config.repository.ts
+++ b/src/themes/services/resume-config.repository.ts
@@ -6,6 +6,7 @@
 import { Injectable, ForbiddenException } from '@nestjs/common';
 import { PrismaService } from '../../prisma/prisma.service';
 import { Prisma } from '@prisma/client';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
 
 export interface ResumeConfig {
   sections: Array<{
@@ -32,17 +33,17 @@ export class ResumeConfigRepository {
     });
 
     if (!resume || resume.userId !== userId) {
-      throw new ForbiddenException('Resume not found');
+      throw new ForbiddenException(ERROR_MESSAGES.RESUME_NOT_FOUND);
     }
 
-    const base = (resume.activeTheme?.styleConfig || {}) as ResumeConfig;
-    const custom = (resume.customTheme || {}) as Partial<ResumeConfig>;
+    const base = (resume.activeTheme?.styleConfig ?? {}) as ResumeConfig;
+    const custom = (resume.customTheme ?? {}) as Partial<ResumeConfig>;
 
     return {
       ...base,
       ...custom,
-      sections: custom.sections || base.sections || [],
-      itemOverrides: custom.itemOverrides || {},
+      sections: custom.sections ?? base.sections,
+      itemOverrides: custom.itemOverrides ?? {},
     };
   }
 
diff --git a/src/themes/services/section-ordering.service.spec.ts b/src/themes/services/section-ordering.service.spec.ts
index cf4be9f..ea439e0 100644
--- a/src/themes/services/section-ordering.service.spec.ts
+++ b/src/themes/services/section-ordering.service.spec.ts
@@ -1,9 +1,3 @@
-/* eslint-disable @typescript-eslint/no-unsafe-assignment */
-/* eslint-disable @typescript-eslint/no-unsafe-member-access */
-/* eslint-disable @typescript-eslint/no-unsafe-return */
-/* eslint-disable @typescript-eslint/no-unsafe-call */
-/* eslint-disable @typescript-eslint/no-unsafe-argument */
-/* eslint-disable @typescript-eslint/no-require-imports */
 /**
  * Section Ordering Service Tests
  * Tests for reordering of sections and items
diff --git a/src/themes/services/section-ordering.service.ts b/src/themes/services/section-ordering.service.ts
index 1805eb0..58663ea 100644
--- a/src/themes/services/section-ordering.service.ts
+++ b/src/themes/services/section-ordering.service.ts
@@ -6,6 +6,7 @@
 import { Injectable, BadRequestException } from '@nestjs/common';
 import { ResumeConfigRepository } from './resume-config.repository';
 import { moveItem, normalizeOrders } from '../utils';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
 
 @Injectable()
 export class SectionOrderingService {
@@ -20,7 +21,8 @@ export class SectionOrderingService {
     const config = await this.repo.get(userId, resumeId);
 
     const idx = config.sections.findIndex((s) => s.id === sectionId);
-    if (idx === -1) throw new BadRequestException('Section not found');
+    if (idx === -1)
+      throw new BadRequestException(ERROR_MESSAGES.SECTION_NOT_FOUND);
 
     config.sections = moveItem(config.sections, idx, newOrder);
 
@@ -38,7 +40,7 @@ export class SectionOrderingService {
     const config = await this.repo.get(userId, resumeId);
 
     const overrides = { ...config.itemOverrides };
-    const items = overrides[sectionId] || [];
+    const items = overrides[sectionId] ?? [];
 
     const idx = items.findIndex((o) => o.itemId === itemId);
     if (idx >= 0) {
diff --git a/src/themes/services/section-visibility.service.spec.ts b/src/themes/services/section-visibility.service.spec.ts
index e4ea2b9..d11d01c 100644
--- a/src/themes/services/section-visibility.service.spec.ts
+++ b/src/themes/services/section-visibility.service.spec.ts
@@ -1,5 +1,3 @@
-/* eslint-disable @typescript-eslint/no-unsafe-assignment */
-/* eslint-disable @typescript-eslint/no-unsafe-member-access */
 /**
  * Section Visibility Service Tests
  * Tests for showing/hiding sections and items
diff --git a/src/themes/services/section-visibility.service.ts b/src/themes/services/section-visibility.service.ts
index d1e7a04..041e18e 100644
--- a/src/themes/services/section-visibility.service.ts
+++ b/src/themes/services/section-visibility.service.ts
@@ -52,7 +52,7 @@ export class SectionVisibilityService {
     update: { visible?: boolean; order?: number },
   ) {
     const overrides = { ...config.itemOverrides };
-    const items = overrides[sectionId] || [];
+    const items = overrides[sectionId] ?? [];
 
     const idx = items.findIndex((o) => o.itemId === itemId);
     if (idx >= 0) {
diff --git a/src/themes/services/theme-application.service.spec.ts b/src/themes/services/theme-application.service.spec.ts
index 65d24dd..a3be530 100644
--- a/src/themes/services/theme-application.service.spec.ts
+++ b/src/themes/services/theme-application.service.spec.ts
@@ -1,9 +1,5 @@
-/* eslint-disable @typescript-eslint/no-unsafe-assignment */
-/* eslint-disable @typescript-eslint/no-unsafe-return */
-/* eslint-disable @typescript-eslint/no-unsafe-call */
-/* eslint-disable @typescript-eslint/no-unsafe-member-access */
 /* eslint-disable @typescript-eslint/no-unused-vars */
-/* eslint-disable @typescript-eslint/no-require-imports */
+
 /**
  * Theme Application Service Tests
  * Tests for applying themes to resumes and managing customizations
diff --git a/src/themes/services/theme-application.service.ts b/src/themes/services/theme-application.service.ts
index 0fc620f..13290a5 100644
--- a/src/themes/services/theme-application.service.ts
+++ b/src/themes/services/theme-application.service.ts
@@ -14,6 +14,7 @@ import { ThemeCrudService } from './theme-crud.service';
 import { ThemeQueryService } from './theme-query.service';
 import { deepMerge } from '../utils';
 import { ThemeStatus, Prisma } from '@prisma/client';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
 
 @Injectable()
 export class ThemeApplicationService {
@@ -28,14 +29,14 @@ export class ThemeApplicationService {
       where: { id: dto.resumeId },
     });
 
-    if (!resume || resume.userId !== userId) {
-      throw new ForbiddenException('Resume not found or access denied');
+    if (resume?.userId !== userId) {
+      throw new ForbiddenException(ERROR_MESSAGES.RESUME_ACCESS_DENIED);
     }
 
     // Verify theme access
     const theme = await this.query.findOne(dto.themeId, userId);
     if (!theme) {
-      throw new NotFoundException('Theme not found or access denied');
+      throw new NotFoundException(ERROR_MESSAGES.THEME_ACCESS_DENIED);
     }
 
     // Apply theme and increment usage
@@ -44,7 +45,7 @@ export class ThemeApplicationService {
         where: { id: dto.resumeId },
         data: {
           activeThemeId: dto.themeId,
-          customTheme: (dto.customizations ||
+          customTheme: (dto.customizations ??
             Prisma.JsonNull) as Prisma.InputJsonValue,
         },
       }),
@@ -65,7 +66,7 @@ export class ThemeApplicationService {
       original.status !== ThemeStatus.PUBLISHED &&
       original.authorId !== userId
     ) {
-      throw new ForbiddenException('Cannot fork this theme');
+      throw new ForbiddenException(ERROR_MESSAGES.CANNOT_FORK_THEME);
     }
 
     return this.prisma.resumeTheme.create({
@@ -89,7 +90,7 @@ export class ThemeApplicationService {
     });
 
     if (!resume || resume.userId !== userId) {
-      throw new ForbiddenException('Resume not found');
+      throw new ForbiddenException(ERROR_MESSAGES.RESUME_NOT_FOUND);
     }
 
     if (!resume.activeTheme) {
diff --git a/src/themes/services/theme-approval.service.spec.ts b/src/themes/services/theme-approval.service.spec.ts
index 92cf842..040dd1f 100644
--- a/src/themes/services/theme-approval.service.spec.ts
+++ b/src/themes/services/theme-approval.service.spec.ts
@@ -1,5 +1,3 @@
-/* eslint-disable @typescript-eslint/no-unsafe-assignment */
-/* eslint-disable @typescript-eslint/unbound-method */
 /**
  * Theme Approval Service Tests
  * Tests for theme submission and review workflow
diff --git a/src/themes/services/theme-approval.service.ts b/src/themes/services/theme-approval.service.ts
index 2de3986..664f5a6 100644
--- a/src/themes/services/theme-approval.service.ts
+++ b/src/themes/services/theme-approval.service.ts
@@ -12,6 +12,7 @@ import { PrismaService } from '../../prisma/prisma.service';
 import { ThemeStatus, UserRole } from '@prisma/client';
 import { ReviewThemeDto } from '../dto';
 import { ThemeCrudService } from './theme-crud.service';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
 
 @Injectable()
 export class ThemeApprovalService {
@@ -24,7 +25,7 @@ export class ThemeApprovalService {
     const theme = await this.crud.findOrFail(themeId);
 
     if (theme.authorId !== userId) {
-      throw new ForbiddenException('Can only submit own themes');
+      throw new ForbiddenException(ERROR_MESSAGES.CAN_ONLY_SUBMIT_OWN_THEMES);
     }
 
     const validStatuses: ThemeStatus[] = [
@@ -32,7 +33,9 @@ export class ThemeApprovalService {
       ThemeStatus.REJECTED,
     ];
     if (!validStatuses.includes(theme.status)) {
-      throw new BadRequestException('Theme must be private or rejected');
+      throw new BadRequestException(
+        ERROR_MESSAGES.THEME_MUST_BE_PRIVATE_OR_REJECTED,
+      );
     }
 
     return this.prisma.resumeTheme.update({
@@ -47,10 +50,10 @@ export class ThemeApprovalService {
     const theme = await this.crud.findOrFail(dto.themeId);
 
     if (theme.status !== ThemeStatus.PENDING_APPROVAL) {
-      throw new BadRequestException('Theme is not pending approval');
+      throw new BadRequestException(ERROR_MESSAGES.THEME_NOT_PENDING_APPROVAL);
     }
     if (theme.authorId === approverId) {
-      throw new ForbiddenException('Cannot approve own themes');
+      throw new ForbiddenException(ERROR_MESSAGES.CANNOT_APPROVE_OWN_THEMES);
     }
 
     if (dto.approved) {
@@ -84,7 +87,7 @@ export class ThemeApprovalService {
 
   private async reject(themeId: string, approverId: string, reason?: string) {
     if (!reason) {
-      throw new BadRequestException('Rejection reason is required');
+      throw new BadRequestException(ERROR_MESSAGES.REJECTION_REASON_REQUIRED);
     }
 
     return this.prisma.resumeTheme.update({
diff --git a/src/themes/services/theme-crud.service.ts b/src/themes/services/theme-crud.service.ts
index 9eb2000..5860e21 100644
--- a/src/themes/services/theme-crud.service.ts
+++ b/src/themes/services/theme-crud.service.ts
@@ -12,6 +12,7 @@ import { PrismaService } from '../../prisma/prisma.service';
 import { ThemeStatus, UserRole, Prisma } from '@prisma/client';
 import { CreateThemeDto, UpdateThemeDto } from '../dto';
 import { validateLayoutConfig, validateSectionsConfig } from '../validators';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
 
 @Injectable()
 export class ThemeCrudService {
@@ -25,7 +26,7 @@ export class ThemeCrudService {
         name: dto.name,
         description: dto.description,
         category: dto.category,
-        tags: dto.tags || [],
+        tags: dto.tags ?? [],
         styleConfig: dto.styleConfig as Prisma.InputJsonValue,
         parentThemeId: dto.parentThemeId,
         authorId: userId,
@@ -58,10 +59,10 @@ export class ThemeCrudService {
     const theme = await this.findOrFail(themeId);
 
     if (theme.isSystemTheme) {
-      throw new ForbiddenException('Cannot delete system themes');
+      throw new ForbiddenException(ERROR_MESSAGES.CANNOT_DELETE_SYSTEM_THEMES);
     }
     if (theme.authorId !== userId) {
-      throw new ForbiddenException('Can only delete own themes');
+      throw new ForbiddenException(ERROR_MESSAGES.CAN_ONLY_DELETE_OWN_THEMES);
     }
 
     return this.prisma.resumeTheme.delete({ where: { id: themeId } });
@@ -69,7 +70,7 @@ export class ThemeCrudService {
 
   async findOrFail(id: string) {
     const theme = await this.prisma.resumeTheme.findUnique({ where: { id } });
-    if (!theme) throw new NotFoundException('Theme not found');
+    if (!theme) throw new NotFoundException(ERROR_MESSAGES.THEME_NOT_FOUND);
     return theme;
   }
 
@@ -85,10 +86,12 @@ export class ThemeCrudService {
     if (theme.isSystemTheme) {
       const user = await this.prisma.user.findUnique({ where: { id: userId } });
       if (user?.role !== UserRole.ADMIN) {
-        throw new ForbiddenException('Only admins can edit system themes');
+        throw new ForbiddenException(
+          ERROR_MESSAGES.ONLY_ADMINS_CAN_EDIT_SYSTEM_THEMES,
+        );
       }
     } else if (theme.authorId !== userId) {
-      throw new ForbiddenException('Can only edit own themes');
+      throw new ForbiddenException(ERROR_MESSAGES.CAN_ONLY_EDIT_OWN_THEMES);
     }
   }
 }
diff --git a/src/themes/services/theme-query.service.ts b/src/themes/services/theme-query.service.ts
index 049dc30..9806c28 100644
--- a/src/themes/services/theme-query.service.ts
+++ b/src/themes/services/theme-query.service.ts
@@ -7,6 +7,7 @@ import { Injectable } from '@nestjs/common';
 import { PrismaService } from '../../prisma/prisma.service';
 import { ThemeStatus, Prisma } from '@prisma/client';
 import { QueryThemesDto } from '../dto';
+import { APP_CONSTANTS } from '../../common/constants/app.constants';
 
 @Injectable()
 export class ThemeQueryService {
@@ -18,7 +19,7 @@ export class ThemeQueryService {
       sortBy = 'createdAt',
       sortDir = 'desc',
       page = 1,
-      limit = 20,
+      limit = APP_CONSTANTS.DEFAULT_PAGE_SIZE,
     } = query;
 
     const [data, total] = await Promise.all([
@@ -58,7 +59,7 @@ export class ThemeQueryService {
     return theme;
   }
 
-  async getPopular(limit = 10) {
+  async getPopular(limit: number = APP_CONSTANTS.SEARCH_AUTOCOMPLETE_LIMIT) {
     return this.prisma.resumeTheme.findMany({
       where: { status: ThemeStatus.PUBLISHED },
       orderBy: [{ usageCount: 'desc' }, { rating: 'desc' }],
diff --git a/src/themes/utils/deep-merge.util.spec.ts b/src/themes/utils/deep-merge.util.spec.ts
index 4c50536..73788b5 100644
--- a/src/themes/utils/deep-merge.util.spec.ts
+++ b/src/themes/utils/deep-merge.util.spec.ts
@@ -1,4 +1,3 @@
-/* eslint-disable @typescript-eslint/no-unsafe-argument */
 /**
  * Deep Merge Utility Tests
  * Tests for merging nested config objects
diff --git a/src/themes/validators/config.validator.ts b/src/themes/validators/config.validator.ts
index 56ff098..35303d7 100644
--- a/src/themes/validators/config.validator.ts
+++ b/src/themes/validators/config.validator.ts
@@ -3,6 +3,7 @@
  */
 
 import { BadRequestException } from '@nestjs/common';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
 
 const VALID_LAYOUT_TYPES = [
   'single-column',
@@ -35,33 +36,38 @@ const VALID_SECTION_IDS = [
 
 export function validateLayoutConfig(layout: unknown): void {
   if (!layout || typeof layout !== 'object') {
-    throw new BadRequestException('Layout config is required');
+    throw new BadRequestException(ERROR_MESSAGES.LAYOUT_CONFIG_REQUIRED);
   }
 
   const l = layout as Record<string, unknown>;
 
-  if (l.type && !VALID_LAYOUT_TYPES.includes(l.type as string)) {
-    throw new BadRequestException(`Invalid layout type: ${l.type}`);
+  if (
+    l.type &&
+    typeof l.type === 'string' &&
+    !VALID_LAYOUT_TYPES.includes(l.type)
+  ) {
+    throw new BadRequestException(`Invalid layout type: ${String(l.type)}`);
   }
 }
 
 export function validateSectionsConfig(sections: unknown): void {
   if (!Array.isArray(sections)) {
-    throw new BadRequestException('Sections must be an array');
+    throw new BadRequestException(ERROR_MESSAGES.SECTIONS_MUST_BE_ARRAY);
   }
 
-  for (const section of sections) {
-    if (!section.id || !VALID_SECTION_IDS.includes(section.id)) {
-      throw new BadRequestException(`Invalid section id: ${section.id}`);
+  for (const section of sections as Array<Record<string, unknown>>) {
+    const sectionId = section.id as string;
+    if (!sectionId || !VALID_SECTION_IDS.includes(sectionId)) {
+      throw new BadRequestException(`Invalid section id: ${String(sectionId)}`);
     }
     if (typeof section.visible !== 'boolean') {
       throw new BadRequestException(
-        `Section ${section.id} must have visible property`,
+        `Section ${sectionId} must have visible property`,
       );
     }
     if (typeof section.order !== 'number') {
       throw new BadRequestException(
-        `Section ${section.id} must have order property`,
+        `Section ${sectionId} must have order property`,
       );
     }
   }
@@ -71,7 +77,7 @@ export function validateItemOverrides(overrides: unknown): void {
   if (!overrides) return;
 
   if (typeof overrides !== 'object') {
-    throw new BadRequestException('Item overrides must be an object');
+    throw new BadRequestException(ERROR_MESSAGES.ITEM_OVERRIDES_MUST_BE_OBJECT);
   }
 
   for (const [sectionId, items] of Object.entries(overrides)) {
diff --git a/src/translation/services/index.ts b/src/translation/services/index.ts
new file mode 100644
index 0000000..3197160
--- /dev/null
+++ b/src/translation/services/index.ts
@@ -0,0 +1,7 @@
+/**
+ * Translation Services Barrel Export
+ */
+
+export { TranslationCoreService } from './translation-core.service';
+export { TranslationBatchService } from './translation-batch.service';
+export { ResumeTranslationService } from './resume-translation.service';
diff --git a/src/translation/services/resume-translation.service.ts b/src/translation/services/resume-translation.service.ts
new file mode 100644
index 0000000..f016a90
--- /dev/null
+++ b/src/translation/services/resume-translation.service.ts
@@ -0,0 +1,96 @@
+/**
+ * Resume Translation Service
+ * Handles translation of resume objects
+ */
+
+import { Injectable } from '@nestjs/common';
+import { TranslationCoreService } from './translation-core.service';
+import { TranslationLanguage } from '../types/translation.types';
+
+const TRANSLATABLE_FIELDS = [
+  'summary',
+  'headline',
+  'title',
+  'description',
+  'responsibilities',
+  'achievements',
+  'skills',
+  'interests',
+];
+
+@Injectable()
+export class ResumeTranslationService {
+  constructor(private readonly coreService: TranslationCoreService) {}
+
+  async translateToEnglish(
+    resumeData: Record<string, unknown>,
+  ): Promise<Record<string, unknown>> {
+    return this.translateFields(resumeData, 'pt', 'en');
+  }
+
+  async translateToPortuguese(
+    resumeData: Record<string, unknown>,
+  ): Promise<Record<string, unknown>> {
+    return this.translateFields(resumeData, 'en', 'pt');
+  }
+
+  private async translateFields(
+    data: Record<string, unknown>,
+    source: TranslationLanguage,
+    target: TranslationLanguage,
+  ): Promise<Record<string, unknown>> {
+    const result = { ...data };
+
+    for (const field of TRANSLATABLE_FIELDS) {
+      if (typeof result[field] === 'string' && result[field]) {
+        const translation = await this.coreService.translate(
+          result[field],
+          source,
+          target,
+        );
+        result[field] = translation.translated;
+      } else if (Array.isArray(result[field])) {
+        result[field] = await this.translateArray(
+          result[field] as unknown[],
+          source,
+          target,
+        );
+      } else if (typeof result[field] === 'object' && result[field] !== null) {
+        result[field] = await this.translateFields(
+          result[field] as Record<string, unknown>,
+          source,
+          target,
+        );
+      }
+    }
+
+    return result;
+  }
+
+  private async translateArray(
+    array: unknown[],
+    source: TranslationLanguage,
+    target: TranslationLanguage,
+  ): Promise<unknown[]> {
+    return Promise.all(
+      array.map(async (item) => {
+        if (typeof item === 'string') {
+          const translation = await this.coreService.translate(
+            item,
+            source,
+            target,
+          );
+          return translation.translated;
+        }
+        if (typeof item === 'object' && item !== null) {
+          return this.translateFields(
+            item as Record<string, unknown>,
+            source,
+            target,
+          );
+        }
+        return item;
+      }),
+    );
+  }
+}
diff --git a/src/translation/services/translation-batch.service.ts b/src/translation/services/translation-batch.service.ts
new file mode 100644
index 0000000..eae0a78
--- /dev/null
+++ b/src/translation/services/translation-batch.service.ts
@@ -0,0 +1,51 @@
+/**
+ * Batch Translation Service
+ * Handles batch translation operations
+ */
+
+import { Injectable } from '@nestjs/common';
+import { TranslationCoreService } from './translation-core.service';
+import {
+  TranslationLanguage,
+  TranslationResult,
+  BatchTranslationResult,
+} from '../types/translation.types';
+
+const BATCH_SIZE = 5;
+
+@Injectable()
+export class TranslationBatchService {
+  constructor(private readonly coreService: TranslationCoreService) {}
+
+  async translateBatch(
+    texts: string[],
+    sourceLanguage: TranslationLanguage,
+    targetLanguage: TranslationLanguage,
+  ): Promise<BatchTranslationResult> {
+    const translations: TranslationResult[] = [];
+    const failed: Array<{ text: string; error: string }> = [];
+
+    for (let i = 0; i < texts.length; i += BATCH_SIZE) {
+      const batch = texts.slice(i, i + BATCH_SIZE);
+      const results = await Promise.allSettled(
+        batch.map((text) =>
+          this.coreService.translate(text, sourceLanguage, targetLanguage),
+        ),
+      );
+
+      results.forEach((result, index) => {
+        if (result.status === 'fulfilled') {
+          translations.push(result.value);
+        } else {
+          const error = result.reason as Error | undefined;
+          failed.push({
+            text: batch[index],
+            error: error?.message ?? 'Unknown error',
+          });
+        }
+      });
+    }
+
+    return { translations, failed };
+  }
+}
diff --git a/src/translation/services/translation-core.service.ts b/src/translation/services/translation-core.service.ts
new file mode 100644
index 0000000..7753fd8
--- /dev/null
+++ b/src/translation/services/translation-core.service.ts
@@ -0,0 +1,129 @@
+/**
+ * Core Translation Service
+ * Handles basic translation operations using LibreTranslate
+ */
+
+import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
+import { ConfigService } from '@nestjs/config';
+import { HttpService } from '@nestjs/axios';
+import { firstValueFrom, catchError, timeout } from 'rxjs';
+import { AxiosError } from 'axios';
+import {
+  TranslationLanguage,
+  TranslationResult,
+} from '../types/translation.types';
+
+@Injectable()
+export class TranslationCoreService implements OnModuleInit {
+  private readonly logger = new Logger(TranslationCoreService.name);
+  private readonly libreTranslateUrl: string;
+  private isServiceAvailable = false;
+
+  constructor(
+    private readonly configService: ConfigService,
+    private readonly httpService: HttpService,
+  ) {
+    this.libreTranslateUrl = this.configService.get<string>(
+      'LIBRETRANSLATE_URL',
+      'http://localhost:5000',
+    );
+  }
+
+  async onModuleInit() {
+    await this.checkServiceHealth();
+  }
+
+  async checkServiceHealth(): Promise<boolean> {
+    try {
+      const response = await firstValueFrom(
+        this.httpService.get(`${this.libreTranslateUrl}/languages`).pipe(
+          timeout(5000),
+          catchError((error: AxiosError) => {
+            throw error;
+          }),
+        ),
+      );
+      this.isServiceAvailable = response.status === 200;
+      this.logger.log(
+        `LibreTranslate service is ${this.isServiceAvailable ? 'available' : 'unavailable'}`,
+      );
+      return this.isServiceAvailable;
+    } catch {
+      this.isServiceAvailable = false;
+      this.logger.warn(
+        'LibreTranslate service is not available. Translation features will be disabled.',
+      );
+      return false;
+    }
+  }
+
+  async translate(
+    text: string,
+    sourceLanguage: TranslationLanguage,
+    targetLanguage: TranslationLanguage,
+  ): Promise<TranslationResult> {
+    if (!text || text.trim().length === 0) {
+      return {
+        original: text,
+        translated: text,
+        sourceLanguage,
+        targetLanguage,
+      };
+    }
+
+    if (!this.isServiceAvailable) {
+      this.logger.warn(
+        'Translation service unavailable, returning original text',
+      );
+      return {
+        original: text,
+        translated: text,
+        sourceLanguage,
+        targetLanguage,
+      };
+    }
+
+    try {
+      const response = await firstValueFrom(
+        this.httpService
+          .post(`${this.libreTranslateUrl}/translate`, {
+            q: text,
+            source: sourceLanguage,
+            target: targetLanguage,
+            format: 'text',
+          })
+          .pipe(
+            timeout(15000),
+            catchError((error: AxiosError) => {
+              throw error;
+            }),
+          ),
+      );
+
+      const responseData = response.data as
+        | { translatedText?: string }
+        | undefined;
+      const translatedText = responseData?.translatedText ?? text;
+      return {
+        original: text,
+        translated: translatedText,
+        sourceLanguage,
+        targetLanguage,
+      };
+    } catch (error) {
+      this.logger.error(
+        `Translation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
+      );
+      return {
+        original: text,
+        translated: text,
+        sourceLanguage,
+        targetLanguage,
+      };
+    }
+  }
+
+  isAvailable(): boolean {
+    return this.isServiceAvailable;
+  }
+}
diff --git a/src/translation/translation.module.ts b/src/translation/translation.module.ts
index 8d03013..d5db13b 100644
--- a/src/translation/translation.module.ts
+++ b/src/translation/translation.module.ts
@@ -7,6 +7,11 @@ import { Module } from '@nestjs/common';
 import { HttpModule } from '@nestjs/axios';
 import { TranslationService } from './translation.service';
 import { TranslationController } from './translation.controller';
+import {
+  TranslationCoreService,
+  TranslationBatchService,
+  ResumeTranslationService,
+} from './services';
 
 @Module({
   imports: [
@@ -16,7 +21,12 @@ import { TranslationController } from './translation.controller';
     }),
   ],
   controllers: [TranslationController],
-  providers: [TranslationService],
+  providers: [
+    TranslationCoreService,
+    TranslationBatchService,
+    ResumeTranslationService,
+    TranslationService,
+  ],
   exports: [TranslationService],
 })
 export class TranslationModule {}
diff --git a/src/translation/translation.service.ts b/src/translation/translation.service.ts
index c7e633a..6b3fb80 100644
--- a/src/translation/translation.service.ts
+++ b/src/translation/translation.service.ts
@@ -1,275 +1,81 @@
 /**
- * Translation Service
- * Handles text translation using LibreTranslate server
+ * Translation Service (Facade)
+ * Provides unified API for translation operations
+ * Delegates to specialized services for implementation
  */
 
-import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
-import { ConfigService } from '@nestjs/config';
-import { HttpService } from '@nestjs/axios';
-import { firstValueFrom, catchError, timeout } from 'rxjs';
-import { AxiosError } from 'axios';
-
-export type TranslationLanguage = 'pt' | 'en';
-
-export interface TranslationResult {
-  original: string;
-  translated: string;
-  sourceLanguage: TranslationLanguage;
-  targetLanguage: TranslationLanguage;
-}
-
-export interface BatchTranslationResult {
-  translations: TranslationResult[];
-  failed: Array<{ text: string; error: string }>;
-}
+import { Injectable, OnModuleInit } from '@nestjs/common';
+import {
+  TranslationCoreService,
+  TranslationBatchService,
+  ResumeTranslationService,
+} from './services';
+import {
+  TranslationLanguage,
+  TranslationResult,
+  BatchTranslationResult,
+} from './types/translation.types';
+
+// Re-export types for backward compatibility
+export { TranslationLanguage, TranslationResult, BatchTranslationResult };
 
 @Injectable()
 export class TranslationService implements OnModuleInit {
-  private readonly logger = new Logger(TranslationService.name);
-  private readonly libreTranslateUrl: string;
-  private isServiceAvailable = false;
-
   constructor(
-    private readonly configService: ConfigService,
-    private readonly httpService: HttpService,
-  ) {
-    this.libreTranslateUrl = this.configService.get<string>(
-      'LIBRETRANSLATE_URL',
-      'http://localhost:5000',
-    );
-  }
+    private readonly coreService: TranslationCoreService,
+    private readonly batchService: TranslationBatchService,
+    private readonly resumeService: ResumeTranslationService,
+  ) {}
 
   async onModuleInit() {
-    await this.checkServiceHealth();
+    await this.coreService.checkServiceHealth();
   }
 
-  /**
-   * Check if LibreTranslate service is available
-   */
   async checkServiceHealth(): Promise<boolean> {
-    try {
-      const response = await firstValueFrom(
-        this.httpService.get(`${this.libreTranslateUrl}/languages`).pipe(
-          timeout(5000),
-          catchError((error: AxiosError) => {
-            throw error;
-          }),
-        ),
-      );
-      this.isServiceAvailable = response.status === 200;
-      this.logger.log(
-        `LibreTranslate service is ${this.isServiceAvailable ? 'available' : 'unavailable'}`,
-      );
-      return this.isServiceAvailable;
-    } catch (error) {
-      this.isServiceAvailable = false;
-      this.logger.warn(
-        'LibreTranslate service is not available. Translation features will be disabled.',
-      );
-      return false;
-    }
+    return this.coreService.checkServiceHealth();
   }
 
-  /**
-   * Translate text from Portuguese to English
-   */
   async translatePtToEn(text: string): Promise<TranslationResult> {
-    return this.translate(text, 'pt', 'en');
+    return this.coreService.translate(text, 'pt', 'en');
   }
 
-  /**
-   * Translate text from English to Portuguese
-   */
   async translateEnToPt(text: string): Promise<TranslationResult> {
-    return this.translate(text, 'en', 'pt');
+    return this.coreService.translate(text, 'en', 'pt');
   }
 
-  /**
-   * Translate text between languages
-   */
   async translate(
     text: string,
     sourceLanguage: TranslationLanguage,
     targetLanguage: TranslationLanguage,
   ): Promise<TranslationResult> {
-    if (!text || text.trim().length === 0) {
-      return {
-        original: text,
-        translated: text,
-        sourceLanguage,
-        targetLanguage,
-      };
-    }
-
-    if (!this.isServiceAvailable) {
-      // Fallback: return original text if service is unavailable
-      this.logger.warn(
-        'Translation service unavailable, returning original text',
-      );
-      return {
-        original: text,
-        translated: text,
-        sourceLanguage,
-        targetLanguage,
-      };
-    }
-
-    try {
-      const response = await firstValueFrom(
-        this.httpService
-          .post(`${this.libreTranslateUrl}/translate`, {
-            q: text,
-            source: sourceLanguage,
-            target: targetLanguage,
-            format: 'text',
-          })
-          .pipe(
-            timeout(15000),
-            catchError((error: AxiosError) => {
-              throw error;
-            }),
-          ),
-      );
-
-      const translatedText = response.data?.translatedText || text;
-
-      return {
-        original: text,
-        translated: translatedText,
-        sourceLanguage,
-        targetLanguage,
-      };
-    } catch (error) {
-      this.logger.error(
-        `Translation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
-      );
-      // Fallback to original text
-      return {
-        original: text,
-        translated: text,
-        sourceLanguage,
-        targetLanguage,
-      };
-    }
+    return this.coreService.translate(text, sourceLanguage, targetLanguage);
   }
 
-  /**
-   * Translate multiple texts in batch
-   */
   async translateBatch(
     texts: string[],
     sourceLanguage: TranslationLanguage,
     targetLanguage: TranslationLanguage,
   ): Promise<BatchTranslationResult> {
-    const translations: TranslationResult[] = [];
-    const failed: Array<{ text: string; error: string }> = [];
-
-    // Process in parallel with a concurrency limit
-    const BATCH_SIZE = 5;
-    for (let i = 0; i < texts.length; i += BATCH_SIZE) {
-      const batch = texts.slice(i, i + BATCH_SIZE);
-      const results = await Promise.allSettled(
-        batch.map((text) =>
-          this.translate(text, sourceLanguage, targetLanguage),
-        ),
-      );
-
-      results.forEach((result, index) => {
-        if (result.status === 'fulfilled') {
-          translations.push(result.value);
-        } else {
-          failed.push({
-            text: batch[index],
-            error: result.reason?.message || 'Unknown error',
-          });
-        }
-      });
-    }
-
-    return { translations, failed };
+    return this.batchService.translateBatch(
+      texts,
+      sourceLanguage,
+      targetLanguage,
+    );
   }
 
-  /**
-   * Translate a resume object from PT to EN
-   */
   async translateResumeToEnglish(
     resumeData: Record<string, unknown>,
   ): Promise<Record<string, unknown>> {
-    return this.translateResumeFields(resumeData, 'pt', 'en');
+    return this.resumeService.translateToEnglish(resumeData);
   }
 
-  /**
-   * Translate a resume object from EN to PT
-   */
   async translateResumeToPortuguese(
     resumeData: Record<string, unknown>,
   ): Promise<Record<string, unknown>> {
-    return this.translateResumeFields(resumeData, 'en', 'pt');
-  }
-
-  /**
-   * Translate specific resume fields
-   */
-  private async translateResumeFields(
-    data: Record<string, unknown>,
-    source: TranslationLanguage,
-    target: TranslationLanguage,
-  ): Promise<Record<string, unknown>> {
-    const translatableFields = [
-      'summary',
-      'headline',
-      'title',
-      'description',
-      'responsibilities',
-      'achievements',
-      'skills',
-      'interests',
-    ];
-
-    const result = { ...data };
-
-    for (const field of translatableFields) {
-      if (typeof result[field] === 'string' && result[field]) {
-        const translation = await this.translate(
-          result[field] as string,
-          source,
-          target,
-        );
-        result[field] = translation.translated;
-      } else if (Array.isArray(result[field])) {
-        const arrayField = result[field] as unknown[];
-        result[field] = await Promise.all(
-          arrayField.map(async (item) => {
-            if (typeof item === 'string') {
-              const translation = await this.translate(item, source, target);
-              return translation.translated;
-            }
-            if (typeof item === 'object' && item !== null) {
-              return this.translateResumeFields(
-                item as Record<string, unknown>,
-                source,
-                target,
-              );
-            }
-            return item;
-          }),
-        );
-      } else if (typeof result[field] === 'object' && result[field] !== null) {
-        result[field] = await this.translateResumeFields(
-          result[field] as Record<string, unknown>,
-          source,
-          target,
-        );
-      }
-    }
-
-    return result;
+    return this.resumeService.translateToPortuguese(resumeData);
   }
 
-  /**
-   * Check if translation service is available
-   */
   isAvailable(): boolean {
-    return this.isServiceAvailable;
+    return this.coreService.isAvailable();
   }
 }
diff --git a/src/translation/types/translation.types.ts b/src/translation/types/translation.types.ts
new file mode 100644
index 0000000..a778264
--- /dev/null
+++ b/src/translation/types/translation.types.ts
@@ -0,0 +1,17 @@
+/**
+ * Translation Types
+ */
+
+export type TranslationLanguage = 'pt' | 'en';
+
+export interface TranslationResult {
+  original: string;
+  translated: string;
+  sourceLanguage: TranslationLanguage;
+  targetLanguage: TranslationLanguage;
+}
+
+export interface BatchTranslationResult {
+  translations: TranslationResult[];
+  failed: Array<{ text: string; error: string }>;
+}
diff --git a/src/upload/upload.controller.ts b/src/upload/upload.controller.ts
index bef50b4..d89e721 100644
--- a/src/upload/upload.controller.ts
+++ b/src/upload/upload.controller.ts
@@ -8,7 +8,6 @@ import {
   Param,
   HttpCode,
   HttpStatus,
-  BadRequestException,
 } from '@nestjs/common';
 import { FileInterceptor } from '@nestjs/platform-express';
 import {
@@ -65,10 +64,6 @@ export class UploadController {
     @CurrentUser() user: UserPayload,
     @UploadedFile() file: Express.Multer.File,
   ) {
-    if (!file) {
-      throw new BadRequestException('No file provided');
-    }
-
     return this.uploadService.uploadProfileImage(user.userId, {
       buffer: file.buffer,
       originalname: file.originalname,
@@ -112,10 +107,6 @@ export class UploadController {
     @Param('resumeId') resumeId: string,
     @UploadedFile() file: Express.Multer.File,
   ) {
-    if (!file) {
-      throw new BadRequestException('No file provided');
-    }
-
     return this.uploadService.uploadCompanyLogo(user.userId, resumeId, {
       buffer: file.buffer,
       originalname: file.originalname,
diff --git a/src/upload/upload.service.ts b/src/upload/upload.service.ts
index cd42274..083771e 100644
--- a/src/upload/upload.service.ts
+++ b/src/upload/upload.service.ts
@@ -1,7 +1,10 @@
 import { Injectable, BadRequestException } from '@nestjs/common';
 import { S3UploadService } from '../common/services/s3-upload.service';
 import { AppLoggerService } from '../common/logger/logger.service';
-import { APP_CONSTANTS } from '../common/constants/app.constants';
+import {
+  APP_CONSTANTS,
+  ERROR_MESSAGES,
+} from '../common/constants/app.constants';
 import { v4 as uuidv4 } from 'uuid';
 
 export interface FileUpload {
@@ -34,7 +37,7 @@ export class UploadService {
     );
 
     if (!result) {
-      throw new BadRequestException('File upload service unavailable');
+      throw new BadRequestException(ERROR_MESSAGES.FILE_UPLOAD_UNAVAILABLE);
     }
 
     this.logger.log('Profile image uploaded', 'UploadService', {
@@ -59,7 +62,7 @@ export class UploadService {
     );
 
     if (!result) {
-      throw new BadRequestException('File upload service unavailable');
+      throw new BadRequestException(ERROR_MESSAGES.FILE_UPLOAD_UNAVAILABLE);
     }
 
     this.logger.log('Company logo uploaded', 'UploadService', {
diff --git a/src/users/controllers/index.ts b/src/users/controllers/index.ts
new file mode 100644
index 0000000..4b2de5c
--- /dev/null
+++ b/src/users/controllers/index.ts
@@ -0,0 +1,6 @@
+/**
+ * Users Controllers - Barrel Export
+ */
+
+export { UsersProfileController } from './users-profile.controller';
+export { UsersPreferencesController } from './users-preferences.controller';
diff --git a/src/users/controllers/users-preferences.controller.ts b/src/users/controllers/users-preferences.controller.ts
new file mode 100644
index 0000000..f2a3dac
--- /dev/null
+++ b/src/users/controllers/users-preferences.controller.ts
@@ -0,0 +1,100 @@
+/**
+ * Users Preferences Controller
+ * Handles user preferences operations
+ */
+
+import {
+  Controller,
+  Get,
+  Patch,
+  Body,
+  UseGuards,
+  HttpCode,
+  HttpStatus,
+} from '@nestjs/common';
+import {
+  ApiTags,
+  ApiOperation,
+  ApiResponse,
+  ApiBearerAuth,
+} from '@nestjs/swagger';
+import { UsersService } from '../users.service';
+import { UpdatePreferencesDto } from '../dto/update-preferences.dto';
+import { UpdateFullPreferencesDto } from '../dto/update-full-preferences.dto';
+import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
+import { CurrentUser } from '../../common/decorators/current-user.decorator';
+import { UserPayload } from '../../auth/interfaces/auth-request.interface';
+
+@ApiTags('users')
+@ApiBearerAuth('JWT-auth')
+@Controller('users')
+export class UsersPreferencesController {
+  constructor(private readonly usersService: UsersService) {}
+
+  @UseGuards(JwtAuthGuard)
+  @Get('preferences')
+  @ApiOperation({ summary: 'Get user preferences (basic)' })
+  @ApiResponse({
+    status: 200,
+    description: 'Preferences retrieved successfully',
+  })
+  @ApiResponse({ status: 401, description: 'Unauthorized' })
+  @ApiResponse({ status: 404, description: 'User not found' })
+  async getPreferences(@CurrentUser() user: UserPayload) {
+    return this.usersService.getPreferences(user.userId);
+  }
+
+  @UseGuards(JwtAuthGuard)
+  @Patch('preferences')
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({ summary: 'Update user preferences (basic)' })
+  @ApiResponse({
+    status: 200,
+    description: 'Preferences updated successfully',
+  })
+  @ApiResponse({ status: 401, description: 'Unauthorized' })
+  @ApiResponse({ status: 404, description: 'User not found' })
+  @ApiResponse({ status: 400, description: 'Invalid input data' })
+  async updatePreferences(
+    @CurrentUser() user: UserPayload,
+    @Body() updatePreferencesDto: UpdatePreferencesDto,
+  ) {
+    return this.usersService.updatePreferences(
+      user.userId,
+      updatePreferencesDto,
+    );
+  }
+
+  @UseGuards(JwtAuthGuard)
+  @Get('preferences/full')
+  @ApiOperation({ summary: 'Get all user preferences' })
+  @ApiResponse({
+    status: 200,
+    description: 'Full preferences retrieved successfully',
+  })
+  @ApiResponse({ status: 401, description: 'Unauthorized' })
+  async getFullPreferences(@CurrentUser() user: UserPayload) {
+    return this.usersService.getFullPreferences(user.userId);
+  }
+
+  @UseGuards(JwtAuthGuard)
+  @Patch('preferences/full')
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({ summary: 'Update all user preferences' })
+  @ApiResponse({
+    status: 200,
+    description: 'Full preferences updated successfully',
+  })
+  @ApiResponse({ status: 401, description: 'Unauthorized' })
+  @ApiResponse({ status: 404, description: 'User not found' })
+  @ApiResponse({ status: 400, description: 'Invalid input data' })
+  async updateFullPreferences(
+    @CurrentUser() user: UserPayload,
+    @Body() updateFullPreferencesDto: UpdateFullPreferencesDto,
+  ) {
+    return this.usersService.updateFullPreferences(
+      user.userId,
+      updateFullPreferencesDto,
+    );
+  }
+}
diff --git a/src/users/controllers/users-profile.controller.ts b/src/users/controllers/users-profile.controller.ts
new file mode 100644
index 0000000..cb81bbe
--- /dev/null
+++ b/src/users/controllers/users-profile.controller.ts
@@ -0,0 +1,130 @@
+/**
+ * Users Profile Controller
+ * Handles user profile operations
+ */
+
+import {
+  Controller,
+  Get,
+  Patch,
+  Body,
+  UseGuards,
+  HttpCode,
+  HttpStatus,
+  Param,
+  Query,
+} from '@nestjs/common';
+import {
+  ApiTags,
+  ApiOperation,
+  ApiResponse,
+  ApiBearerAuth,
+  ApiQuery,
+} from '@nestjs/swagger';
+import { UsersService } from '../users.service';
+import { UpdateProfileDto } from '../dto/update-profile.dto';
+import { UpdateUsernameDto } from '../dto/update-username.dto';
+import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';
+import { Public } from '../../auth/decorators/public.decorator';
+import { CurrentUser } from '../../common/decorators/current-user.decorator';
+import { UserPayload } from '../../auth/interfaces/auth-request.interface';
+
+@ApiTags('users')
+@ApiBearerAuth('JWT-auth')
+@Controller('users')
+export class UsersProfileController {
+  constructor(private readonly usersService: UsersService) {}
+
+  @Public()
+  @Get(':username/profile')
+  @ApiOperation({ summary: "Get a user's public profile by username" })
+  @ApiResponse({ status: 200, description: 'Public profile retrieved' })
+  @ApiResponse({ status: 404, description: 'Public profile not found' })
+  async getPublicProfileByUsername(@Param('username') username: string) {
+    return this.usersService.getPublicProfileByUsername(username);
+  }
+
+  @UseGuards(JwtAuthGuard)
+  @Get('profile')
+  @ApiOperation({ summary: 'Get current user profile' })
+  @ApiResponse({
+    status: 200,
+    description: 'User profile retrieved successfully',
+  })
+  @ApiResponse({ status: 401, description: 'Unauthorized' })
+  @ApiResponse({ status: 404, description: 'User not found' })
+  async getProfile(@CurrentUser() user: UserPayload) {
+    return this.usersService.getProfile(user.userId);
+  }
+
+  @UseGuards(JwtAuthGuard)
+  @Patch('profile')
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({ summary: 'Update current user profile' })
+  @ApiResponse({ status: 200, description: 'Profile updated successfully' })
+  @ApiResponse({ status: 401, description: 'Unauthorized' })
+  @ApiResponse({ status: 404, description: 'User not found' })
+  @ApiResponse({ status: 400, description: 'Invalid input data' })
+  async updateProfile(
+    @CurrentUser() user: UserPayload,
+    @Body() updateProfileDto: UpdateProfileDto,
+  ) {
+    return this.usersService.updateProfile(user.userId, updateProfileDto);
+  }
+
+  @UseGuards(JwtAuthGuard)
+  @Patch('username')
+  @HttpCode(HttpStatus.OK)
+  @ApiOperation({ summary: 'Update username (once every 30 days)' })
+  @ApiResponse({
+    status: 200,
+    description: 'Username updated successfully',
+    schema: {
+      example: {
+        success: true,
+        message: 'Username updated successfully',
+        username: 'new_username',
+      },
+    },
+  })
+  @ApiResponse({
+    status: 400,
+    description: 'Invalid username or cooldown period active',
+  })
+  @ApiResponse({ status: 401, description: 'Unauthorized' })
+  @ApiResponse({ status: 404, description: 'User not found' })
+  @ApiResponse({ status: 409, description: 'Username already taken' })
+  async updateUsername(
+    @CurrentUser() user: UserPayload,
+    @Body() updateUsernameDto: UpdateUsernameDto,
+  ) {
+    return this.usersService.updateUsername(user.userId, updateUsernameDto);
+  }
+
+  @UseGuards(JwtAuthGuard)
+  @Get('username/check')
+  @ApiOperation({ summary: 'Check if a username is available' })
+  @ApiQuery({
+    name: 'username',
+    required: true,
+    description: 'Username to check',
+    example: 'john_doe',
+  })
+  @ApiResponse({
+    status: 200,
+    description: 'Username availability status',
+    schema: {
+      example: {
+        username: 'john_doe',
+        available: true,
+      },
+    },
+  })
+  @ApiResponse({ status: 401, description: 'Unauthorized' })
+  async checkUsernameAvailability(
+    @CurrentUser() user: UserPayload,
+    @Query('username') username: string,
+  ) {
+    return this.usersService.checkUsernameAvailability(username, user.userId);
+  }
+}
diff --git a/src/users/dto/update-username.dto.ts b/src/users/dto/update-username.dto.ts
index 368bda5..43235c1 100644
--- a/src/users/dto/update-username.dto.ts
+++ b/src/users/dto/update-username.dto.ts
@@ -1,9 +1,4 @@
-import {
-  IsString,
-  MinLength,
-  MaxLength,
-  Matches,
-} from 'class-validator';
+import { IsString, MinLength, MaxLength, Matches } from 'class-validator';
 import { ApiProperty } from '@nestjs/swagger';
 import {
   STRING_LENGTH,
@@ -25,7 +20,8 @@ export class UpdateUsernameDto {
     message: `Username must be at most ${STRING_LENGTH.MAX.USERNAME} characters`,
   })
   @Matches(REGEX.USERNAME, {
-    message: 'Username can only contain letters, numbers, underscores, and hyphens',
+    message:
+      'Username can only contain letters, numbers, underscores, and hyphens',
   })
   username: string;
 }
diff --git a/src/users/repositories/index.ts b/src/users/repositories/index.ts
new file mode 100644
index 0000000..9721579
--- /dev/null
+++ b/src/users/repositories/index.ts
@@ -0,0 +1,6 @@
+/**
+ * User Repositories Barrel Export
+ */
+
+export { UserQueryRepository } from './user-query.repository';
+export { UserMutationRepository } from './user-mutation.repository';
diff --git a/src/users/repositories/user-mutation.repository.ts b/src/users/repositories/user-mutation.repository.ts
new file mode 100644
index 0000000..40387bc
--- /dev/null
+++ b/src/users/repositories/user-mutation.repository.ts
@@ -0,0 +1,109 @@
+/**
+ * User Mutation Repository
+ * Single Responsibility: Write operations for user data
+ */
+
+import { Injectable, Logger } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { User, UserPreferences } from '@prisma/client';
+import { UpdateProfileDto } from '../dto/update-profile.dto';
+import { UpdatePreferencesDto } from '../dto/update-preferences.dto';
+import { UpdateFullPreferencesDto } from '../dto/update-full-preferences.dto';
+
+@Injectable()
+export class UserMutationRepository {
+  private readonly logger = new Logger(UserMutationRepository.name);
+
+  constructor(private readonly prisma: PrismaService) {}
+
+  async createUser(userData: {
+    id: string;
+    email: string;
+    displayName?: string;
+    photoURL?: string;
+  }): Promise<User> {
+    this.logger.log(`Creating user: ${userData.email}`);
+    return await this.prisma.user.create({ data: userData });
+  }
+
+  async updateUser(userId: string, userData: Partial<User>): Promise<User> {
+    this.logger.log(`Updating user: ${userId}`);
+    return await this.prisma.user.update({
+      where: { id: userId },
+      data: userData,
+    });
+  }
+
+  async deleteUser(userId: string): Promise<void> {
+    this.logger.log(`Deleting user: ${userId}`);
+    await this.prisma.user.delete({ where: { id: userId } });
+  }
+
+  async updateUserProfile(
+    userId: string,
+    profile: UpdateProfileDto,
+  ): Promise<User> {
+    this.logger.log(`Updating profile for user: ${userId}`);
+    return await this.prisma.user.update({
+      where: { id: userId },
+      data: profile,
+    });
+  }
+
+  async updateUserPreferences(
+    userId: string,
+    preferences: UpdatePreferencesDto,
+  ): Promise<void> {
+    this.logger.log(`Updating preferences for user: ${userId}`);
+    await this.prisma.user.update({
+      where: { id: userId },
+      data: preferences,
+    });
+  }
+
+  async upsertFullUserPreferences(
+    userId: string,
+    preferences: UpdateFullPreferencesDto,
+  ): Promise<UserPreferences> {
+    this.logger.log(`Upserting full preferences for user: ${userId}`);
+    return await this.prisma.userPreferences.upsert({
+      where: { userId },
+      create: { userId, ...preferences },
+      update: preferences,
+    });
+  }
+
+  async updatePalette(userId: string, palette: string): Promise<void> {
+    this.logger.log(`Updating palette for user: ${userId}`);
+    await this.prisma.user.update({
+      where: { id: userId },
+      data: { palette },
+    });
+    await this.prisma.userPreferences.upsert({
+      where: { userId },
+      create: { userId, palette },
+      update: { palette },
+    });
+  }
+
+  async updateBannerColor(userId: string, bannerColor: string): Promise<void> {
+    this.logger.log(`Updating banner color for user: ${userId}`);
+    await this.prisma.user.update({
+      where: { id: userId },
+      data: { bannerColor },
+    });
+    await this.prisma.userPreferences.upsert({
+      where: { userId },
+      create: { userId, bannerColor },
+      update: { bannerColor },
+    });
+  }
+
+  async updateUsername(userId: string, username: string): Promise<User> {
+    this.logger.log(`Updating username for user: ${userId}`);
+    return await this.prisma.user.update({
+      where: { id: userId },
+      data: { username, usernameUpdatedAt: new Date() },
+    });
+  }
+}
diff --git a/src/users/repositories/user-query.repository.ts b/src/users/repositories/user-query.repository.ts
new file mode 100644
index 0000000..cdddd2a
--- /dev/null
+++ b/src/users/repositories/user-query.repository.ts
@@ -0,0 +1,97 @@
+/**
+ * User Query Repository
+ * Single Responsibility: Read operations for user data
+ */
+
+import { Injectable } from '@nestjs/common';
+import { PrismaService } from '../../prisma/prisma.service';
+import { User, UserPreferences } from '@prisma/client';
+
+@Injectable()
+export class UserQueryRepository {
+  constructor(private readonly prisma: PrismaService) {}
+
+  async getUser(userId: string): Promise<User | null> {
+    return await this.prisma.user.findUnique({
+      where: { id: userId },
+    });
+  }
+
+  async getUserWithPreferences(
+    userId: string,
+  ): Promise<(User & { preferences: UserPreferences | null }) | null> {
+    return await this.prisma.user.findUnique({
+      where: { id: userId },
+      include: { preferences: true },
+    });
+  }
+
+  async findByUsername(
+    username: string,
+  ): Promise<(User & { preferences: UserPreferences | null }) | null> {
+    return await this.prisma.user.findUnique({
+      where: { username },
+      include: { preferences: true },
+    });
+  }
+
+  async getUserProfile(userId: string): Promise<Partial<User> | null> {
+    return await this.prisma.user.findUnique({
+      where: { id: userId },
+      select: {
+        username: true,
+        usernameUpdatedAt: true,
+        displayName: true,
+        photoURL: true,
+        bio: true,
+        location: true,
+        phone: true,
+        website: true,
+        linkedin: true,
+        github: true,
+      },
+    });
+  }
+
+  async getUserPreferences(userId: string): Promise<Partial<User> | null> {
+    return await this.prisma.user.findUnique({
+      where: { id: userId },
+      select: {
+        palette: true,
+        bannerColor: true,
+        displayName: true,
+        photoURL: true,
+      },
+    });
+  }
+
+  async getFullUserPreferences(
+    userId: string,
+  ): Promise<UserPreferences | null> {
+    return await this.prisma.userPreferences.findUnique({
+      where: { userId },
+    });
+  }
+
+  async isUsernameTaken(
+    username: string,
+    excludeUserId?: string,
+  ): Promise<boolean> {
+    const user = await this.prisma.user.findUnique({
+      where: { username },
+      select: { id: true },
+    });
+
+    if (!user) return false;
+    if (excludeUserId && user.id === excludeUserId) return false;
+    return true;
+  }
+
+  async getLastUsernameUpdate(userId: string): Promise<Date | null> {
+    const user = await this.prisma.user.findUnique({
+      where: { id: userId },
+      select: { usernameUpdatedAt: true },
+    });
+    return user?.usernameUpdatedAt ?? null;
+  }
+}
diff --git a/src/users/services/index.ts b/src/users/services/index.ts
new file mode 100644
index 0000000..846643e
--- /dev/null
+++ b/src/users/services/index.ts
@@ -0,0 +1,7 @@
+/**
+ * Users Services - Barrel Export
+ */
+
+export { UserProfileService } from './user-profile.service';
+export { UserPreferencesService } from './user-preferences.service';
+export { UsernameService } from './username.service';
diff --git a/src/users/services/user-preferences.service.ts b/src/users/services/user-preferences.service.ts
new file mode 100644
index 0000000..dd69562
--- /dev/null
+++ b/src/users/services/user-preferences.service.ts
@@ -0,0 +1,88 @@
+/**
+ * User Preferences Service
+ * Handles user preferences operations
+ */
+
+import { Injectable, NotFoundException } from '@nestjs/common';
+import { UsersRepository } from '../users.repository';
+import { UpdatePreferencesDto } from '../dto/update-preferences.dto';
+import { UpdateFullPreferencesDto } from '../dto/update-full-preferences.dto';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
+
+@Injectable()
+export class UserPreferencesService {
+  constructor(
+    private readonly usersRepository: UsersRepository,
+    private readonly logger: AppLoggerService,
+  ) {}
+
+  async getPreferences(userId: string) {
+    const preferences = await this.usersRepository.getUserPreferences(userId);
+
+    if (!preferences) {
+      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
+    }
+
+    return preferences;
+  }
+
+  async updatePreferences(
+    userId: string,
+    updatePreferencesDto: UpdatePreferencesDto,
+  ) {
+    const user = await this.usersRepository.getUser(userId);
+    if (!user) {
+      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
+    }
+
+    await this.usersRepository.updateUserPreferences(
+      userId,
+      updatePreferencesDto,
+    );
+
+    this.logger.debug(`User preferences updated`, 'UserPreferencesService', {
+      userId,
+    });
+
+    return {
+      success: true,
+      message: 'Preferences updated successfully',
+    };
+  }
+
+  async getFullPreferences(userId: string) {
+    const preferences =
+      await this.usersRepository.getFullUserPreferences(userId);
+
+    return preferences ?? {};
+  }
+
+  async updateFullPreferences(
+    userId: string,
+    updateFullPreferencesDto: UpdateFullPreferencesDto,
+  ) {
+    const user = await this.usersRepository.getUser(userId);
+    if (!user) {
+      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
+    }
+
+    const preferences = await this.usersRepository.upsertFullUserPreferences(
+      userId,
+      updateFullPreferencesDto,
+    );
+
+    this.logger.debug(
+      `User full preferences updated`,
+      'UserPreferencesService',
+      {
+        userId,
+      },
+    );
+
+    return {
+      success: true,
+      preferences,
+    };
+  }
+}
diff --git a/src/users/services/user-profile.service.ts b/src/users/services/user-profile.service.ts
new file mode 100644
index 0000000..efc01f4
--- /dev/null
+++ b/src/users/services/user-profile.service.ts
@@ -0,0 +1,81 @@
+/**
+ * User Profile Service
+ * Handles profile-related operations
+ */
+
+import { Injectable, NotFoundException } from '@nestjs/common';
+import { UsersRepository } from '../users.repository';
+import { ResumesRepository } from '../../resumes/resumes.repository';
+import { UpdateProfileDto } from '../dto/update-profile.dto';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
+
+@Injectable()
+export class UserProfileService {
+  constructor(
+    private readonly usersRepository: UsersRepository,
+    private readonly resumesRepository: ResumesRepository,
+    private readonly logger: AppLoggerService,
+  ) {}
+
+  async getPublicProfileByUsername(username: string) {
+    const user = await this.usersRepository.findByUsername(username);
+
+    if (!user || user.preferences?.profileVisibility !== 'public') {
+      throw new NotFoundException(ERROR_MESSAGES.PUBLIC_PROFILE_NOT_FOUND);
+    }
+
+    const resume = await this.resumesRepository.findByUserId(user.id);
+
+    return {
+      user: {
+        displayName: user.displayName,
+        photoURL: user.photoURL,
+        bio: user.bio,
+        location: user.location,
+        website: user.website,
+        linkedin: user.linkedin,
+        github: user.github,
+      },
+      resume,
+    };
+  }
+
+  async getProfile(userId: string) {
+    const profile = await this.usersRepository.getUserProfile(userId);
+
+    if (!profile) {
+      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
+    }
+
+    return profile;
+  }
+
+  async updateProfile(userId: string, updateProfileDto: UpdateProfileDto) {
+    const user = await this.usersRepository.getUser(userId);
+    if (!user) {
+      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
+    }
+
+    const updatedUser = await this.usersRepository.updateUserProfile(
+      userId,
+      updateProfileDto,
+    );
+
+    this.logger.debug(`User profile updated`, 'UserProfileService', { userId });
+
+    return {
+      success: true,
+      user: {
+        displayName: updatedUser.displayName,
+        photoURL: updatedUser.photoURL,
+        bio: updatedUser.bio,
+        location: updatedUser.location,
+        phone: updatedUser.phone,
+        website: updatedUser.website,
+        linkedin: updatedUser.linkedin,
+        github: updatedUser.github,
+      },
+    };
+  }
+}
diff --git a/src/users/services/username.service.ts b/src/users/services/username.service.ts
new file mode 100644
index 0000000..5ddf720
--- /dev/null
+++ b/src/users/services/username.service.ts
@@ -0,0 +1,104 @@
+/**
+ * Username Service
+ * Handles username operations with cooldown
+ */
+
+import {
+  Injectable,
+  NotFoundException,
+  ConflictException,
+  BadRequestException,
+} from '@nestjs/common';
+import { UsersRepository } from '../users.repository';
+import { UpdateUsernameDto } from '../dto/update-username.dto';
+import { AppLoggerService } from '../../common/logger/logger.service';
+import { ERROR_MESSAGES } from '../../common/constants/app.constants';
+
+const USERNAME_UPDATE_COOLDOWN_DAYS = 30;
+
+@Injectable()
+export class UsernameService {
+  constructor(
+    private readonly usersRepository: UsersRepository,
+    private readonly logger: AppLoggerService,
+  ) {}
+
+  async updateUsername(userId: string, updateUsernameDto: UpdateUsernameDto) {
+    const user = await this.usersRepository.getUser(userId);
+    if (!user) {
+      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
+    }
+
+    const newUsername = updateUsernameDto.username.toLowerCase();
+
+    if (user.username === newUsername) {
+      return {
+        success: true,
+        message: 'Username unchanged',
+        username: user.username,
+      };
+    }
+
+    await this.checkCooldownPeriod(userId);
+    await this.ensureUsernameAvailable(newUsername, userId);
+
+    const updatedUser = await this.usersRepository.updateUsername(
+      userId,
+      newUsername,
+    );
+
+    this.logger.debug(`Username updated`, 'UsernameService', {
+      userId,
+      oldUsername: user.username,
+      newUsername,
+    });
+
+    return {
+      success: true,
+      message: 'Username updated successfully',
+      username: updatedUser.username,
+    };
+  }
+
+  async checkUsernameAvailability(username: string, userId?: string) {
+    const normalizedUsername = username.toLowerCase();
+    const isTaken = await this.usersRepository.isUsernameTaken(
+      normalizedUsername,
+      userId,
+    );
+
+    return {
+      username: normalizedUsername,
+      available: !isTaken,
+    };
+  }
+
+  private async checkCooldownPeriod(userId: string): Promise<void> {
+    const lastUpdate = await this.usersRepository.getLastUsernameUpdate(userId);
+    if (!lastUpdate) return;
+
+    const daysSinceLastUpdate = Math.floor(
+      (Date.now() - lastUpdate.getTime()) / (1000 * 60 * 60 * 24),
+    );
+
+    if (daysSinceLastUpdate < USERNAME_UPDATE_COOLDOWN_DAYS) {
+      const daysRemaining = USERNAME_UPDATE_COOLDOWN_DAYS - daysSinceLastUpdate;
+      throw new BadRequestException(
+        `You can only change your username once every ${USERNAME_UPDATE_COOLDOWN_DAYS} days. Please wait ${daysRemaining} more day(s).`,
+      );
+    }
+  }
+
+  private async ensureUsernameAvailable(
+    username: string,
+    userId: string,
+  ): Promise<void> {
+    const isTaken = await this.usersRepository.isUsernameTaken(
+      username,
+      userId,
+    );
+    if (isTaken) {
+      throw new ConflictException(ERROR_MESSAGES.USERNAME_ALREADY_IN_USE);
+    }
+  }
+}
diff --git a/src/users/users.controller.ts b/src/users/users.controller.ts
index 28d2327..ea619d7 100644
--- a/src/users/users.controller.ts
+++ b/src/users/users.controller.ts
@@ -151,7 +151,10 @@ export class UsersController {
       },
     },
   })
-  @ApiResponse({ status: 400, description: 'Invalid username or cooldown period active' })
+  @ApiResponse({
+    status: 400,
+    description: 'Invalid username or cooldown period active',
+  })
   @ApiResponse({ status: 401, description: 'Unauthorized' })
   @ApiResponse({ status: 404, description: 'User not found' })
   @ApiResponse({ status: 409, description: 'Username already taken' })
diff --git a/src/users/users.module.ts b/src/users/users.module.ts
index 44a415d..326a880 100644
--- a/src/users/users.module.ts
+++ b/src/users/users.module.ts
@@ -1,14 +1,32 @@
 import { Module } from '@nestjs/common';
 import { UsersService } from './users.service';
-import { UsersController } from './users.controller';
+import {
+  UsersProfileController,
+  UsersPreferencesController,
+} from './controllers';
 import { UsersRepository } from './users.repository';
+import {
+  UserProfileService,
+  UserPreferencesService,
+  UsernameService,
+} from './services';
+import { UserQueryRepository, UserMutationRepository } from './repositories';
 import { PrismaModule } from '../prisma/prisma.module';
 import { ResumesModule } from '../resumes/resumes.module';
+import { LoggerModule } from '../common/logger/logger.module';
 
 @Module({
-  imports: [PrismaModule, ResumesModule],
-  controllers: [UsersController],
-  providers: [UsersService, UsersRepository],
+  imports: [PrismaModule, ResumesModule, LoggerModule],
+  controllers: [UsersProfileController, UsersPreferencesController],
+  providers: [
+    UsersService,
+    UsersRepository,
+    UserQueryRepository,
+    UserMutationRepository,
+    UserProfileService,
+    UserPreferencesService,
+    UsernameService,
+  ],
   exports: [UsersService, UsersRepository],
 })
 export class UsersModule {}
diff --git a/src/users/users.repository.ts b/src/users/users.repository.ts
index 1b074cd..57e283d 100644
--- a/src/users/users.repository.ts
+++ b/src/users/users.repository.ts
@@ -1,210 +1,113 @@
-import { Injectable, Logger } from '@nestjs/common';
-import { PrismaService } from '../prisma/prisma.service';
+/**
+ * Users Repository Facade
+ * Delegates to specialized query and mutation repositories
+ * Maintains backward compatibility with existing code
+ */
+
+import { Injectable } from '@nestjs/common';
 import { User, UserPreferences } from '@prisma/client';
 import { UpdateProfileDto } from './dto/update-profile.dto';
 import { UpdatePreferencesDto } from './dto/update-preferences.dto';
 import { UpdateFullPreferencesDto } from './dto/update-full-preferences.dto';
+import { UserQueryRepository, UserMutationRepository } from './repositories';
 
 @Injectable()
 export class UsersRepository {
-  private readonly logger = new Logger(UsersRepository.name);
-
-  constructor(private readonly prisma: PrismaService) {}
+  constructor(
+    private readonly queryRepo: UserQueryRepository,
+    private readonly mutationRepo: UserMutationRepository,
+  ) {}
 
+  // Query operations
   async getUser(userId: string): Promise<User | null> {
-    return await this.prisma.user.findUnique({
-      where: { id: userId },
-    });
+    return this.queryRepo.getUser(userId);
   }
 
   async getUserWithPreferences(
     userId: string,
   ): Promise<(User & { preferences: UserPreferences | null }) | null> {
-    return await this.prisma.user.findUnique({
-      where: { id: userId },
-      include: {
-        preferences: true,
-      },
-    });
+    return this.queryRepo.getUserWithPreferences(userId);
   }
 
   async findByUsername(
     username: string,
   ): Promise<(User & { preferences: UserPreferences | null }) | null> {
-    return await this.prisma.user.findUnique({
-      where: { username },
-      include: {
-        preferences: true,
-      },
-    });
+    return this.queryRepo.findByUsername(username);
   }
 
   async getUserProfile(userId: string): Promise<Partial<User> | null> {
-    const user = await this.prisma.user.findUnique({
-      where: { id: userId },
-      select: {
-        username: true,
-        usernameUpdatedAt: true,
-        displayName: true,
-        photoURL: true,
-        bio: true,
-        location: true,
-        phone: true,
-        website: true,
-        linkedin: true,
-        github: true,
-      },
-    });
-
-    return user;
-  }
-
-  async updateUserProfile(
-    userId: string,
-    profile: UpdateProfileDto,
-  ): Promise<User> {
-    this.logger.log(`Updating profile for user: ${userId}`);
-    return await this.prisma.user.update({
-      where: { id: userId },
-      data: profile,
-    });
+    return this.queryRepo.getUserProfile(userId);
   }
 
   async getUserPreferences(userId: string): Promise<Partial<User> | null> {
-    const user = await this.prisma.user.findUnique({
-      where: { id: userId },
-      select: {
-        palette: true,
-        bannerColor: true,
-        displayName: true,
-        photoURL: true,
-      },
-    });
-
-    return user;
+    return this.queryRepo.getUserPreferences(userId);
   }
 
   async getFullUserPreferences(
     userId: string,
   ): Promise<UserPreferences | null> {
-    return await this.prisma.userPreferences.findUnique({
-      where: { userId },
-    });
-  }
-
-  async updateUserPreferences(
-    userId: string,
-    preferences: UpdatePreferencesDto,
-  ): Promise<void> {
-    this.logger.log(`Updating preferences for user: ${userId}`);
-    await this.prisma.user.update({
-      where: { id: userId },
-      data: preferences,
-    });
-  }
-
-  async upsertFullUserPreferences(
-    userId: string,
-    preferences: UpdateFullPreferencesDto,
-  ): Promise<UserPreferences> {
-    this.logger.log(`Upserting full preferences for user: ${userId}`);
-    return await this.prisma.userPreferences.upsert({
-      where: { userId },
-      create: {
-        userId,
-        ...preferences,
-      },
-      update: preferences,
-    });
+    return this.queryRepo.getFullUserPreferences(userId);
   }
 
-  async updatePalette(userId: string, palette: string): Promise<void> {
-    this.logger.log(`Updating palette for user: ${userId}`);
-    await this.prisma.user.update({
-      where: { id: userId },
-      data: { palette },
-    });
-
-    // Also update in preferences table
-    await this.prisma.userPreferences.upsert({
-      where: { userId },
-      create: { userId, palette },
-      update: { palette },
-    });
+  async isUsernameTaken(
+    username: string,
+    excludeUserId?: string,
+  ): Promise<boolean> {
+    return this.queryRepo.isUsernameTaken(username, excludeUserId);
   }
 
-  async updateBannerColor(userId: string, bannerColor: string): Promise<void> {
-    this.logger.log(`Updating banner color for user: ${userId}`);
-    await this.prisma.user.update({
-      where: { id: userId },
-      data: { bannerColor },
-    });
-
-    // Also update in preferences table
-    await this.prisma.userPreferences.upsert({
-      where: { userId },
-      create: { userId, bannerColor },
-      update: { bannerColor },
-    });
+  async getLastUsernameUpdate(userId: string): Promise<Date | null> {
+    return this.queryRepo.getLastUsernameUpdate(userId);
   }
 
+  // Mutation operations
   async createUser(userData: {
     id: string;
     email: string;
     displayName?: string;
     photoURL?: string;
   }): Promise<User> {
-    this.logger.log(`Creating user: ${userData.email}`);
-    return await this.prisma.user.create({
-      data: userData,
-    });
+    return this.mutationRepo.createUser(userData);
   }
 
   async updateUser(userId: string, userData: Partial<User>): Promise<User> {
-    this.logger.log(`Updating user: ${userId}`);
-    return await this.prisma.user.update({
-      where: { id: userId },
-      data: userData,
-    });
+    return this.mutationRepo.updateUser(userId, userData);
   }
 
   async deleteUser(userId: string): Promise<void> {
-    this.logger.log(`Deleting user: ${userId}`);
-    await this.prisma.user.delete({
-      where: { id: userId },
-    });
+    return this.mutationRepo.deleteUser(userId);
   }
 
-  async isUsernameTaken(username: string, excludeUserId?: string): Promise<boolean> {
-    const user = await this.prisma.user.findUnique({
-      where: { username },
-      select: { id: true },
-    });
+  async updateUserProfile(
+    userId: string,
+    profile: UpdateProfileDto,
+  ): Promise<User> {
+    return this.mutationRepo.updateUserProfile(userId, profile);
+  }
 
-    if (!user) return false;
-    if (excludeUserId && user.id === excludeUserId) return false;
-    return true;
+  async updateUserPreferences(
+    userId: string,
+    preferences: UpdatePreferencesDto,
+  ): Promise<void> {
+    return this.mutationRepo.updateUserPreferences(userId, preferences);
   }
 
-  async updateUsername(
+  async upsertFullUserPreferences(
     userId: string,
-    username: string,
-  ): Promise<User> {
-    this.logger.log(`Updating username for user: ${userId}`);
-    return await this.prisma.user.update({
-      where: { id: userId },
-      data: {
-        username,
-        usernameUpdatedAt: new Date(),
-      },
-    });
+    preferences: UpdateFullPreferencesDto,
+  ): Promise<UserPreferences> {
+    return this.mutationRepo.upsertFullUserPreferences(userId, preferences);
   }
 
-  async getLastUsernameUpdate(userId: string): Promise<Date | null> {
-    const user = await this.prisma.user.findUnique({
-      where: { id: userId },
-      select: { usernameUpdatedAt: true },
-    });
-    return user?.usernameUpdatedAt ?? null;
+  async updatePalette(userId: string, palette: string): Promise<void> {
+    return this.mutationRepo.updatePalette(userId, palette);
+  }
+
+  async updateBannerColor(userId: string, bannerColor: string): Promise<void> {
+    return this.mutationRepo.updateBannerColor(userId, bannerColor);
+  }
+
+  async updateUsername(userId: string, username: string): Promise<User> {
+    return this.mutationRepo.updateUsername(userId, username);
   }
 }
diff --git a/src/users/users.service.spec.ts b/src/users/users.service.spec.ts
index 3c3f4b4..4a24b87 100644
--- a/src/users/users.service.spec.ts
+++ b/src/users/users.service.spec.ts
@@ -1,34 +1,30 @@
 import { Test, TestingModule } from '@nestjs/testing';
-import { NotFoundException } from '@nestjs/common';
 import { UsersService } from './users.service';
-import { UsersRepository } from './users.repository';
-import { ResumesRepository } from '../resumes/resumes.repository';
-import { AppLoggerService } from '../common/logger/logger.service';
-import { ERROR_MESSAGES } from '../common/constants/app.constants';
+import { UserProfileService } from './services/user-profile.service';
+import { UserPreferencesService } from './services/user-preferences.service';
+import { UsernameService } from './services/username.service';
 
 describe('UsersService', () => {
   let service: UsersService;
-
-  const mockUsersRepository = {
-    getUser: jest.fn(),
-    getUserProfile: jest.fn(),
-    updateUserProfile: jest.fn(),
-    getUserPreferences: jest.fn(),
-    updateUserPreferences: jest.fn(),
-    getFullUserPreferences: jest.fn(),
-    upsertFullUserPreferences: jest.fn(),
-    findByUsername: jest.fn(),
+  let profileService: jest.Mocked<UserProfileService>;
+  let preferencesService: jest.Mocked<UserPreferencesService>;
+  let usernameService: jest.Mocked<UsernameService>;
+
+  const mockProfileService = {
+    getPublicProfileByUsername: jest.fn(),
+    getProfile: jest.fn(),
+    updateProfile: jest.fn(),
   };
 
-  const mockResumesRepository = {
-    findByUserId: jest.fn(),
+  const mockPreferencesService = {
+    getPreferences: jest.fn(),
+    updatePreferences: jest.fn(),
+    getFullPreferences: jest.fn(),
+    updateFullPreferences: jest.fn(),
   };
 
-  const mockLoggerService = {
-    log: jest.fn(),
-    warn: jest.fn(),
-    error: jest.fn(),
-    debug: jest.fn(),
+  const mockUsernameService = {
+    updateUsername: jest.fn(),
   };
 
   beforeEach(async () => {
@@ -36,21 +32,24 @@ describe('UsersService', () => {
       providers: [
         UsersService,
         {
-          provide: UsersRepository,
-          useValue: mockUsersRepository,
+          provide: UserProfileService,
+          useValue: mockProfileService,
         },
         {
-          provide: ResumesRepository,
-          useValue: mockResumesRepository,
+          provide: UserPreferencesService,
+          useValue: mockPreferencesService,
         },
         {
-          provide: AppLoggerService,
-          useValue: mockLoggerService,
+          provide: UsernameService,
+          useValue: mockUsernameService,
         },
       ],
     }).compile();
 
     service = module.get<UsersService>(UsersService);
+    profileService = module.get(UserProfileService);
+    preferencesService = module.get(UserPreferencesService);
+    usernameService = module.get(UsernameService);
   });
 
   afterEach(() => {
@@ -58,299 +57,142 @@ describe('UsersService', () => {
   });
 
   describe('getPublicProfileByUsername', () => {
-    it('should return public profile and resume if user found and public', async () => {
+    it('should delegate to profileService', async () => {
       const username = 'publicuser';
-      const mockUser = {
-        id: 'user-1',
-        preferences: { profileVisibility: 'public' },
-        displayName: 'Public User',
+      const mockResult = {
+        user: { id: 'user-1', displayName: 'Public User' },
+        resume: { id: 'resume-1', title: 'Public Resume' },
       };
-      const mockResume = { id: 'resume-1', title: 'Public Resume' };
-
-      mockUsersRepository.findByUsername.mockResolvedValue(mockUser);
-      mockResumesRepository.findByUserId.mockResolvedValue(mockResume);
+      mockProfileService.getPublicProfileByUsername.mockResolvedValue(
+        mockResult,
+      );
 
       const result = await service.getPublicProfileByUsername(username);
 
-      expect(result.user.displayName).toBe(mockUser.displayName);
-      expect(result.resume).not.toBeNull();
-      if (result.resume) {
-        expect(result.resume.id).toBe(mockResume.id);
-      }
-      expect(mockUsersRepository.findByUsername).toHaveBeenCalledWith(username);
-      expect(mockResumesRepository.findByUserId).toHaveBeenCalledWith(
-        mockUser.id,
+      expect(result).toEqual(mockResult);
+      expect(profileService.getPublicProfileByUsername).toHaveBeenCalledWith(
+        username,
       );
     });
-
-    it('should throw NotFoundException if user not found', async () => {
-      const username = 'notfound';
-      mockUsersRepository.findByUsername.mockResolvedValue(null);
-
-      await expect(() =>
-        service.getPublicProfileByUsername(username),
-      ).rejects.toThrow(new NotFoundException('Public profile not found'));
-    });
-
-    it('should throw NotFoundException if profile is private', async () => {
-      const username = 'privateuser';
-      const mockUser = {
-        id: 'user-2',
-        preferences: { profileVisibility: 'private' },
-      };
-      mockUsersRepository.findByUsername.mockResolvedValue(mockUser);
-
-      await expect(() =>
-        service.getPublicProfileByUsername(username),
-      ).rejects.toThrow(new NotFoundException('Public profile not found'));
-    });
   });
 
   describe('getProfile', () => {
-    it('should successfully get user profile', async () => {
+    it('should delegate to profileService', async () => {
       const userId = 'user-123';
       const mockProfile = {
         id: userId,
         email: 'test@example.com',
         name: 'Test User',
         displayName: 'Test',
-        bio: 'Test bio',
-        location: 'Test Location',
-        phone: '1234567890',
-        website: 'https://example.com',
-        linkedin: 'testuser',
-        github: 'testuser',
-        photoURL: 'https://example.com/photo.jpg',
       };
-
-      mockUsersRepository.getUserProfile.mockResolvedValue(mockProfile);
+      mockProfileService.getProfile.mockResolvedValue(mockProfile);
 
       const result = await service.getProfile(userId);
 
       expect(result).toEqual(mockProfile);
-      expect(mockUsersRepository.getUserProfile).toHaveBeenCalledWith(userId);
-    });
-
-    it('should throw NotFoundException if user profile not found', async () => {
-      const userId = 'invalid-user';
-      mockUsersRepository.getUserProfile.mockResolvedValue(null);
-
-      await expect(() => service.getProfile(userId)).rejects.toThrow(
-        NotFoundException,
-      );
-      await expect(() => service.getProfile(userId)).rejects.toThrow(
-        ERROR_MESSAGES.USER_NOT_FOUND,
-      );
+      expect(profileService.getProfile).toHaveBeenCalledWith(userId);
     });
   });
 
   describe('updateProfile', () => {
-    it('should successfully update user profile', async () => {
+    it('should delegate to profileService', async () => {
       const userId = 'user-123';
       const updateProfileDto = {
         displayName: 'Updated Name',
         bio: 'Updated bio',
-        location: 'Updated Location',
-        phone: '9876543210',
-        website: 'https://updated.com',
-        linkedin: 'updateduser',
-        github: 'updateduser',
       };
-
-      const mockUser = { id: userId, email: 'test@example.com' };
-      const mockUpdatedProfile = {
-        ...mockUser,
-        ...updateProfileDto,
-        photoURL: 'https://example.com/photo.jpg',
+      const mockResult = {
+        success: true,
+        user: { displayName: 'Updated Name' },
       };
-
-      mockUsersRepository.getUser.mockResolvedValue(mockUser);
-      mockUsersRepository.updateUserProfile.mockResolvedValue(
-        mockUpdatedProfile,
-      );
+      mockProfileService.updateProfile.mockResolvedValue(mockResult);
 
       const result = await service.updateProfile(userId, updateProfileDto);
 
-      expect(result).toEqual({
-        success: true,
-        user: {
-          displayName: mockUpdatedProfile.displayName,
-          photoURL: mockUpdatedProfile.photoURL,
-          bio: mockUpdatedProfile.bio,
-          location: mockUpdatedProfile.location,
-          phone: mockUpdatedProfile.phone,
-          website: mockUpdatedProfile.website,
-          linkedin: mockUpdatedProfile.linkedin,
-          github: mockUpdatedProfile.github,
-        },
-      });
-
-      expect(mockUsersRepository.getUser).toHaveBeenCalledWith(userId);
-      expect(mockUsersRepository.updateUserProfile).toHaveBeenCalledWith(
+      expect(result).toEqual(mockResult);
+      expect(profileService.updateProfile).toHaveBeenCalledWith(
         userId,
         updateProfileDto,
       );
-      expect(mockLoggerService.debug).toHaveBeenCalled();
-    });
-
-    it('should throw NotFoundException if user does not exist', async () => {
-      const userId = 'invalid-user';
-      const updateProfileDto = {
-        displayName: 'Updated Name',
-      };
-
-      mockUsersRepository.getUser.mockResolvedValue(null);
-
-      await expect(() =>
-        service.updateProfile(userId, updateProfileDto),
-      ).rejects.toThrow(NotFoundException);
-      await expect(() =>
-        service.updateProfile(userId, updateProfileDto),
-      ).rejects.toThrow(ERROR_MESSAGES.USER_NOT_FOUND);
-
-      expect(mockUsersRepository.updateUserProfile).not.toHaveBeenCalled();
     });
   });
 
   describe('getPreferences', () => {
-    it('should successfully get user preferences', async () => {
+    it('should delegate to preferencesService', async () => {
       const userId = 'user-123';
       const mockPreferences = {
         palette: 'blue',
         bannerColor: '#1a1a1a',
-        displayName: 'Test User',
-        photoURL: 'https://example.com/photo.jpg',
       };
-
-      mockUsersRepository.getUserPreferences.mockResolvedValue(mockPreferences);
+      mockPreferencesService.getPreferences.mockResolvedValue(mockPreferences);
 
       const result = await service.getPreferences(userId);
 
       expect(result).toEqual(mockPreferences);
-      expect(mockUsersRepository.getUserPreferences).toHaveBeenCalledWith(
-        userId,
-      );
-    });
-
-    it('should throw NotFoundException if preferences not found', async () => {
-      const userId = 'invalid-user';
-      mockUsersRepository.getUserPreferences.mockResolvedValue(null);
-
-      await expect(() => service.getPreferences(userId)).rejects.toThrow(
-        NotFoundException,
-      );
-      await expect(() => service.getPreferences(userId)).rejects.toThrow(
-        ERROR_MESSAGES.USER_NOT_FOUND,
-      );
+      expect(preferencesService.getPreferences).toHaveBeenCalledWith(userId);
     });
   });
 
   describe('updatePreferences', () => {
-    it('should successfully update user preferences', async () => {
+    it('should delegate to preferencesService', async () => {
       const userId = 'user-123';
       const updatePreferencesDto = {
         palette: 'green',
         bannerColor: '#2a2a2a',
-        displayName: 'Updated User',
-        photoURL: 'https://example.com/new-photo.jpg',
       };
-
-      const mockUser = { id: userId, email: 'test@example.com' };
-
-      mockUsersRepository.getUser.mockResolvedValue(mockUser);
-      mockUsersRepository.updateUserPreferences.mockResolvedValue(undefined);
+      const mockResult = {
+        success: true,
+        message: 'Preferences updated successfully',
+      };
+      mockPreferencesService.updatePreferences.mockResolvedValue(mockResult);
 
       const result = await service.updatePreferences(
         userId,
         updatePreferencesDto,
       );
 
-      expect(result).toEqual({
-        success: true,
-        message: 'Preferences updated successfully',
-      });
-
-      expect(mockUsersRepository.getUser).toHaveBeenCalledWith(userId);
-      expect(mockUsersRepository.updateUserPreferences).toHaveBeenCalledWith(
+      expect(result).toEqual(mockResult);
+      expect(preferencesService.updatePreferences).toHaveBeenCalledWith(
         userId,
         updatePreferencesDto,
       );
-      expect(mockLoggerService.debug).toHaveBeenCalled();
-    });
-
-    it('should throw NotFoundException if user does not exist', async () => {
-      const userId = 'invalid-user';
-      const updatePreferencesDto = {
-        palette: 'red',
-      };
-
-      mockUsersRepository.getUser.mockResolvedValue(null);
-
-      await expect(() =>
-        service.updatePreferences(userId, updatePreferencesDto),
-      ).rejects.toThrow(NotFoundException);
-      await expect(() =>
-        service.updatePreferences(userId, updatePreferencesDto),
-      ).rejects.toThrow(ERROR_MESSAGES.USER_NOT_FOUND);
-
-      expect(mockUsersRepository.updateUserPreferences).not.toHaveBeenCalled();
     });
   });
 
   describe('getFullPreferences', () => {
-    it('should successfully get full user preferences', async () => {
+    it('should delegate to preferencesService', async () => {
       const userId = 'user-123';
       const mockFullPreferences = {
         theme: 'dark',
         palette: 'blue',
-        bannerColor: '#1a1a1a',
         language: 'en',
-        emailNotifications: true,
-        marketingEmails: false,
-        timezone: 'America/New_York',
       };
-
-      mockUsersRepository.getFullUserPreferences.mockResolvedValue(
+      mockPreferencesService.getFullPreferences.mockResolvedValue(
         mockFullPreferences,
       );
 
       const result = await service.getFullPreferences(userId);
 
       expect(result).toEqual(mockFullPreferences);
-      expect(mockUsersRepository.getFullUserPreferences).toHaveBeenCalledWith(
+      expect(preferencesService.getFullPreferences).toHaveBeenCalledWith(
         userId,
       );
     });
-
-    it('should return empty object if preferences not found', async () => {
-      const userId = 'user-123';
-      mockUsersRepository.getFullUserPreferences.mockResolvedValue(null);
-
-      const result = await service.getFullPreferences(userId);
-
-      expect(result).toEqual({});
-    });
   });
 
   describe('updateFullPreferences', () => {
-    it('should successfully update full user preferences', async () => {
+    it('should delegate to preferencesService', async () => {
       const userId = 'user-123';
       const updateFullPreferencesDto = {
         theme: 'light',
         palette: 'green',
-        bannerColor: '#2a2a2a',
-        language: 'pt',
-        emailNotifications: false,
-        marketingEmails: true,
-        timezone: 'Europe/London',
       };
-
-      const mockUser = { id: userId, email: 'test@example.com' };
-      const mockUpdatedPreferences = { ...updateFullPreferencesDto };
-
-      mockUsersRepository.getUser.mockResolvedValue(mockUser);
-      mockUsersRepository.upsertFullUserPreferences.mockResolvedValue(
-        mockUpdatedPreferences,
+      const mockResult = {
+        success: true,
+        preferences: updateFullPreferencesDto,
+      };
+      mockPreferencesService.updateFullPreferences.mockResolvedValue(
+        mockResult,
       );
 
       const result = await service.updateFullPreferences(
@@ -358,36 +200,33 @@ describe('UsersService', () => {
         updateFullPreferencesDto,
       );
 
-      expect(result).toEqual({
-        success: true,
-        preferences: mockUpdatedPreferences,
-      });
-
-      expect(mockUsersRepository.getUser).toHaveBeenCalledWith(userId);
-      expect(
-        mockUsersRepository.upsertFullUserPreferences,
-      ).toHaveBeenCalledWith(userId, updateFullPreferencesDto);
-      expect(mockLoggerService.debug).toHaveBeenCalled();
+      expect(result).toEqual(mockResult);
+      expect(preferencesService.updateFullPreferences).toHaveBeenCalledWith(
+        userId,
+        updateFullPreferencesDto,
+      );
     });
+  });
 
-    it('should throw NotFoundException if user does not exist', async () => {
-      const userId = 'invalid-user';
-      const updateFullPreferencesDto = {
-        theme: 'light',
+  describe('updateUsername', () => {
+    it('should delegate to usernameService', async () => {
+      const userId = 'user-123';
+      const updateUsernameDto = {
+        username: 'newusername',
       };
+      const mockResult = {
+        success: true,
+        username: 'newusername',
+      };
+      mockUsernameService.updateUsername.mockResolvedValue(mockResult);
 
-      mockUsersRepository.getUser.mockResolvedValue(null);
-
-      await expect(() =>
-        service.updateFullPreferences(userId, updateFullPreferencesDto),
-      ).rejects.toThrow(NotFoundException);
-      await expect(() =>
-        service.updateFullPreferences(userId, updateFullPreferencesDto),
-      ).rejects.toThrow(ERROR_MESSAGES.USER_NOT_FOUND);
+      const result = await service.updateUsername(userId, updateUsernameDto);
 
-      expect(
-        mockUsersRepository.upsertFullUserPreferences,
-      ).not.toHaveBeenCalled();
+      expect(result).toEqual(mockResult);
+      expect(usernameService.updateUsername).toHaveBeenCalledWith(
+        userId,
+        updateUsernameDto,
+      );
     });
   });
 });
diff --git a/src/users/users.service.ts b/src/users/users.service.ts
index 7387ad8..c5330c8 100644
--- a/src/users/users.service.ts
+++ b/src/users/users.service.ts
@@ -1,227 +1,73 @@
-import {
-  Injectable,
-  NotFoundException,
-  ConflictException,
-  BadRequestException,
-} from '@nestjs/common';
-import { UsersRepository } from './users.repository';
-import { ResumesRepository } from '../resumes/resumes.repository';
+/**
+ * Users Service - Facade
+ * Delegates to specialized services for profile, preferences, and username
+ */
+
+import { Injectable } from '@nestjs/common';
+import { UserProfileService } from './services/user-profile.service';
+import { UserPreferencesService } from './services/user-preferences.service';
+import { UsernameService } from './services/username.service';
 import { UpdateProfileDto } from './dto/update-profile.dto';
 import { UpdatePreferencesDto } from './dto/update-preferences.dto';
 import { UpdateFullPreferencesDto } from './dto/update-full-preferences.dto';
 import { UpdateUsernameDto } from './dto/update-username.dto';
-import { AppLoggerService } from '../common/logger/logger.service';
-import { ERROR_MESSAGES } from '../common/constants/app.constants';
-
-const USERNAME_UPDATE_COOLDOWN_DAYS = 30;
 
 @Injectable()
 export class UsersService {
   constructor(
-    private readonly usersRepository: UsersRepository,
-    private readonly resumesRepository: ResumesRepository,
-    private readonly logger: AppLoggerService,
+    private readonly profileService: UserProfileService,
+    private readonly preferencesService: UserPreferencesService,
+    private readonly usernameService: UsernameService,
   ) {}
 
+  // Profile operations
   async getPublicProfileByUsername(username: string) {
-    const user = await this.usersRepository.findByUsername(username);
-
-    if (
-      !user ||
-      !user.preferences ||
-      user.preferences.profileVisibility !== 'public'
-    ) {
-      throw new NotFoundException('Public profile not found');
-    }
-
-    const resume = await this.resumesRepository.findByUserId(user.id);
-
-    // Return a curated public profile object
-    return {
-      user: {
-        displayName: user.displayName,
-        photoURL: user.photoURL,
-        bio: user.bio,
-        location: user.location,
-        website: user.website,
-        linkedin: user.linkedin,
-        github: user.github,
-      },
-      resume,
-    };
+    return this.profileService.getPublicProfileByUsername(username);
   }
 
   async getProfile(userId: string) {
-    const profile = await this.usersRepository.getUserProfile(userId);
-
-    if (!profile) {
-      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
-    }
-
-    return profile;
+    return this.profileService.getProfile(userId);
   }
 
-  // ... (rest of the file is unchanged)
   async updateProfile(userId: string, updateProfileDto: UpdateProfileDto) {
-    const user = await this.usersRepository.getUser(userId);
-    if (!user) {
-      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
-    }
-
-    const updatedUser = await this.usersRepository.updateUserProfile(
-      userId,
-      updateProfileDto,
-    );
-
-    this.logger.debug(`User profile updated`, 'UsersService', { userId });
-
-    return {
-      success: true,
-      user: {
-        displayName: updatedUser.displayName,
-        photoURL: updatedUser.photoURL,
-        bio: updatedUser.bio,
-        location: updatedUser.location,
-        phone: updatedUser.phone,
-        website: updatedUser.website,
-        linkedin: updatedUser.linkedin,
-        github: updatedUser.github,
-      },
-    };
+    return this.profileService.updateProfile(userId, updateProfileDto);
   }
 
+  // Preferences operations
   async getPreferences(userId: string) {
-    const preferences = await this.usersRepository.getUserPreferences(userId);
-
-    if (!preferences) {
-      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
-    }
-
-    return preferences;
+    return this.preferencesService.getPreferences(userId);
   }
 
   async updatePreferences(
     userId: string,
     updatePreferencesDto: UpdatePreferencesDto,
   ) {
-    const user = await this.usersRepository.getUser(userId);
-    if (!user) {
-      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
-    }
-
-    await this.usersRepository.updateUserPreferences(
+    return this.preferencesService.updatePreferences(
       userId,
       updatePreferencesDto,
     );
-
-    this.logger.debug(`User preferences updated`, 'UsersService', { userId });
-
-    return {
-      success: true,
-      message: 'Preferences updated successfully',
-    };
   }
 
   async getFullPreferences(userId: string) {
-    const preferences =
-      await this.usersRepository.getFullUserPreferences(userId);
-
-    return preferences || {};
+    return this.preferencesService.getFullPreferences(userId);
   }
 
   async updateFullPreferences(
     userId: string,
     updateFullPreferencesDto: UpdateFullPreferencesDto,
   ) {
-    const user = await this.usersRepository.getUser(userId);
-    if (!user) {
-      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
-    }
-
-    const preferences = await this.usersRepository.upsertFullUserPreferences(
+    return this.preferencesService.updateFullPreferences(
       userId,
       updateFullPreferencesDto,
     );
-
-    this.logger.debug(`User full preferences updated`, 'UsersService', {
-      userId,
-    });
-
-    return {
-      success: true,
-      preferences,
-    };
   }
 
+  // Username operations
   async updateUsername(userId: string, updateUsernameDto: UpdateUsernameDto) {
-    const user = await this.usersRepository.getUser(userId);
-    if (!user) {
-      throw new NotFoundException(ERROR_MESSAGES.USER_NOT_FOUND);
-    }
-
-    const newUsername = updateUsernameDto.username.toLowerCase();
-
-    // Check if username is the same
-    if (user.username === newUsername) {
-      return {
-        success: true,
-        message: 'Username unchanged',
-        username: user.username,
-      };
-    }
-
-    // Check cooldown period
-    const lastUpdate =
-      await this.usersRepository.getLastUsernameUpdate(userId);
-    if (lastUpdate) {
-      const daysSinceLastUpdate = Math.floor(
-        (Date.now() - lastUpdate.getTime()) / (1000 * 60 * 60 * 24),
-      );
-      if (daysSinceLastUpdate < USERNAME_UPDATE_COOLDOWN_DAYS) {
-        const daysRemaining = USERNAME_UPDATE_COOLDOWN_DAYS - daysSinceLastUpdate;
-        throw new BadRequestException(
-          `You can only change your username once every ${USERNAME_UPDATE_COOLDOWN_DAYS} days. Please wait ${daysRemaining} more day(s).`,
-        );
-      }
-    }
-
-    // Check if username is already taken
-    const isTaken = await this.usersRepository.isUsernameTaken(
-      newUsername,
-      userId,
-    );
-    if (isTaken) {
-      throw new ConflictException('Username is already taken');
-    }
-
-    const updatedUser = await this.usersRepository.updateUsername(
-      userId,
-      newUsername,
-    );
-
-    this.logger.debug(`Username updated`, 'UsersService', {
-      userId,
-      oldUsername: user.username,
-      newUsername,
-    });
-
-    return {
-      success: true,
-      message: 'Username updated successfully',
-      username: updatedUser.username,
-    };
+    return this.usernameService.updateUsername(userId, updateUsernameDto);
   }
 
   async checkUsernameAvailability(username: string, userId?: string) {
-    const normalizedUsername = username.toLowerCase();
-    const isTaken = await this.usersRepository.isUsernameTaken(
-      normalizedUsername,
-      userId,
-    );
-
-    return {
-      username: normalizedUsername,
-      available: !isTaken,
-    };
+    return this.usernameService.checkUsernameAvailability(username, userId);
   }
 }
diff --git a/test/auth.e2e-spec.ts b/test/auth.e2e-spec.ts
index d131bfe..2743faa 100644
--- a/test/auth.e2e-spec.ts
+++ b/test/auth.e2e-spec.ts
@@ -1,4 +1,3 @@
-/* eslint-disable @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment */
 import { Test, TestingModule } from '@nestjs/testing';
 import { INestApplication, ValidationPipe } from '@nestjs/common';
 import * as request from 'supertest';
diff --git a/test/factories/index.ts b/test/factories/index.ts
new file mode 100644
index 0000000..1bea6ed
--- /dev/null
+++ b/test/factories/index.ts
@@ -0,0 +1,7 @@
+/**
+ * Test Factories - Central export
+ * Provides type-safe mock object creation for tests
+ */
+
+export * from './user.factory';
+export * from './resume.factory';
diff --git a/test/factories/resume.factory.ts b/test/factories/resume.factory.ts
new file mode 100644
index 0000000..4873af9
--- /dev/null
+++ b/test/factories/resume.factory.ts
@@ -0,0 +1,140 @@
+/**
+ * Resume Test Factory
+ * Creates mock Resume objects for testing with proper types
+ */
+
+import { Resume, ResumeStatus, AtsOptimization } from '@prisma/client';
+
+export interface CreateMockResumeOptions {
+  id?: string;
+  userId?: string;
+  title?: string;
+  slug?: string;
+  status?: ResumeStatus;
+  isPublic?: boolean;
+  themeId?: string | null;
+  language?: string | null;
+  jobTitle?: string | null;
+  summary?: string | null;
+  summaryPtBr?: string | null;
+  atsOptimization?: AtsOptimization;
+  targetRole?: string | null;
+  yearsOfExperience?: number | null;
+  githubUsername?: string | null;
+  githubTotalStars?: number;
+  githubLastSyncedAt?: Date | null;
+  sectionOrder?: string[];
+  createdAt?: Date;
+  updatedAt?: Date;
+}
+
+const defaultResume: Resume = {
+  id: 'resume-123',
+  userId: 'user-123',
+  title: 'My Resume',
+  slug: 'my-resume',
+  status: 'DRAFT',
+  isPublic: false,
+  themeId: null,
+  language: 'en',
+  jobTitle: null,
+  summary: null,
+  summaryPtBr: null,
+  atsOptimization: 'BALANCED',
+  targetRole: null,
+  yearsOfExperience: null,
+  githubUsername: null,
+  githubTotalStars: 0,
+  githubLastSyncedAt: null,
+  sectionOrder: [],
+  createdAt: new Date('2024-01-01'),
+  updatedAt: new Date('2024-01-01'),
+};
+
+export function createMockResume(
+  options: CreateMockResumeOptions = {},
+): Resume {
+  return {
+    ...defaultResume,
+    ...options,
+    createdAt: options.createdAt ?? defaultResume.createdAt,
+    updatedAt: options.updatedAt ?? defaultResume.updatedAt,
+  };
+}
+
+export function createMockPublicResume(
+  options: CreateMockResumeOptions = {},
+): Resume {
+  return createMockResume({
+    ...options,
+    isPublic: true,
+    status: 'PUBLISHED',
+  });
+}
+
+/**
+ * Resume with all relations included
+ */
+export interface ResumeWithRelations extends Resume {
+  skills?: Array<{
+    id: string;
+    name: string;
+    category: string;
+    level: number | null;
+    order: number;
+  }>;
+  experiences?: Array<{
+    id: string;
+    company: string;
+    position: string;
+    startDate: Date;
+    endDate: Date | null;
+    current: boolean;
+    description: string | null;
+    order: number;
+  }>;
+  educations?: Array<{
+    id: string;
+    institution: string;
+    degree: string;
+    field: string | null;
+    startDate: Date;
+    endDate: Date | null;
+    current: boolean;
+    order: number;
+  }>;
+  projects?: Array<{
+    id: string;
+    name: string;
+    description: string | null;
+    url: string | null;
+    order: number;
+  }>;
+  languages?: Array<{
+    id: string;
+    name: string;
+    level: string;
+    order: number;
+  }>;
+  certifications?: Array<{
+    id: string;
+    name: string;
+    issuer: string;
+    date: Date | null;
+    order: number;
+  }>;
+}
+
+export function createMockResumeWithRelations(
+  options: Partial<ResumeWithRelations> = {},
+): ResumeWithRelations {
+  return {
+    ...createMockResume(options),
+    skills: options.skills ?? [],
+    experiences: options.experiences ?? [],
+    educations: options.educations ?? [],
+    projects: options.projects ?? [],
+    languages: options.languages ?? [],
+    certifications: options.certifications ?? [],
+  };
+}
diff --git a/test/factories/user.factory.ts b/test/factories/user.factory.ts
new file mode 100644
index 0000000..564d1fd
--- /dev/null
+++ b/test/factories/user.factory.ts
@@ -0,0 +1,99 @@
+/**
+ * User Test Factory
+ * Creates mock User objects for testing with proper types
+ */
+
+import { User, UserRole } from '@prisma/client';
+
+export interface CreateMockUserOptions {
+  id?: string;
+  email?: string;
+  name?: string;
+  username?: string;
+  role?: UserRole;
+  emailVerified?: Date | null;
+  createdAt?: Date;
+  updatedAt?: Date;
+  password?: string;
+  phone?: string | null;
+  location?: string | null;
+  bio?: string | null;
+  avatar?: string | null;
+  website?: string | null;
+  linkedin?: string | null;
+  github?: string | null;
+  twitter?: string | null;
+  subtitle?: string | null;
+  pronouns?: string | null;
+  company?: string | null;
+  companyLogo?: string | null;
+  dateOfBirth?: Date | null;
+  nationality?: string | null;
+  introMessage?: string | null;
+  headline?: string | null;
+  availabilityStatus?: string | null;
+  portfolioUrl?: string | null;
+  cvFileUrl?: string | null;
+  mbtiType?: string | null;
+  preferredWorkStyle?: string | null;
+  communicationStyle?: string | null;
+}
+
+const defaultUser: User = {
+  id: 'user-123',
+  email: 'test@example.com',
+  name: 'Test User',
+  username: 'testuser',
+  role: 'USER',
+  emailVerified: null,
+  createdAt: new Date('2024-01-01'),
+  updatedAt: new Date('2024-01-01'),
+  password: 'hashed-password',
+  phone: null,
+  location: null,
+  bio: null,
+  avatar: null,
+  website: null,
+  linkedin: null,
+  github: null,
+  twitter: null,
+  subtitle: null,
+  pronouns: null,
+  company: null,
+  companyLogo: null,
+  dateOfBirth: null,
+  nationality: null,
+  introMessage: null,
+  headline: null,
+  availabilityStatus: null,
+  portfolioUrl: null,
+  cvFileUrl: null,
+  mbtiType: null,
+  preferredWorkStyle: null,
+  communicationStyle: null,
+};
+
+export function createMockUser(options: CreateMockUserOptions = {}): User {
+  return {
+    ...defaultUser,
+    ...options,
+    createdAt: options.createdAt ?? defaultUser.createdAt,
+    updatedAt: options.updatedAt ?? defaultUser.updatedAt,
+  };
+}
+
+export function createMockAdmin(options: CreateMockUserOptions = {}): User {
+  return createMockUser({
+    ...options,
+    role: 'ADMIN',
+  });
+}
+
+export function createMockVerifiedUser(
+  options: CreateMockUserOptions = {},
+): User {
+  return createMockUser({
+    ...options,
+    emailVerified: new Date(),
+  });
+}
diff --git a/test/smoke/auth.smoke.spec.ts b/test/smoke/auth.smoke.spec.ts
index 0ef2e92..3e8004a 100644
--- a/test/smoke/auth.smoke.spec.ts
+++ b/test/smoke/auth.smoke.spec.ts
@@ -48,11 +48,13 @@ describe('Auth Smoke Tests', () => {
     });
 
     it('should reject weak password', async () => {
-      const res = await getRequest().post('/api/auth/signup').send({
-        email: `weak-pass-${Date.now()}@test.com`,
-        password: '123',
-        name: TEST_USER.name,
-      });
+      const res = await getRequest()
+        .post('/api/auth/signup')
+        .send({
+          email: `weak-pass-${Date.now()}@test.com`,
+          password: '123',
+          name: TEST_USER.name,
+        });
 
       expect(res.status).toBe(400);
     });
diff --git a/test/smoke/setup.ts b/test/smoke/setup.ts
index 661f489..e5b8b67 100644
--- a/test/smoke/setup.ts
+++ b/test/smoke/setup.ts
@@ -108,22 +108,37 @@ export async function createTestUserAndLogin(): Promise<{
     });
 
     if (loginRes.status !== 200 && loginRes.status !== 201) {
-      throw new Error(`Failed to create/login test user: ${JSON.stringify(loginRes.body)}`);
+      throw new Error(
+        `Failed to create/login test user: ${JSON.stringify(loginRes.body)}`,
+      );
     }
 
-    testContext.accessToken = loginRes.body.data?.accessToken || loginRes.body.accessToken;
-    testContext.refreshToken = loginRes.body.data?.refreshToken || loginRes.body.refreshToken;
+    testContext.accessToken =
+      loginRes.body.data?.accessToken || loginRes.body.accessToken;
+    testContext.refreshToken =
+      loginRes.body.data?.refreshToken || loginRes.body.refreshToken;
     testContext.userId = loginRes.body.data?.user?.id || loginRes.body.user?.id;
   } else {
-    testContext.accessToken = signupRes.body.data?.accessToken || signupRes.body.accessToken;
-    testContext.refreshToken = signupRes.body.data?.refreshToken || signupRes.body.refreshToken;
-    testContext.userId = signupRes.body.data?.user?.id || signupRes.body.user?.id;
+    testContext.accessToken =
+      signupRes.body.data?.accessToken || signupRes.body.accessToken;
+    testContext.refreshToken =
+      signupRes.body.data?.refreshToken || signupRes.body.refreshToken;
+    testContext.userId =
+      signupRes.body.data?.user?.id || signupRes.body.user?.id;
+  }
+
+  if (
+    !testContext.accessToken ||
+    !testContext.refreshToken ||
+    !testContext.userId
+  ) {
+    throw new Error('Test context is incomplete - missing tokens or userId');
   }
 
   return {
-    accessToken: testContext.accessToken!,
-    refreshToken: testContext.refreshToken!,
-    userId: testContext.userId!,
+    accessToken: testContext.accessToken,
+    refreshToken: testContext.refreshToken,
+    userId: testContext.userId,
   };
 }
 
diff --git a/tsconfig.json b/tsconfig.json
index 0d3d0b1..b8ca43e 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -6,6 +6,7 @@
     "emitDecoratorMetadata": true,
     "experimentalDecorators": true,
     "allowSyntheticDefaultImports": true,
+    "resolveJsonModule": true,
     "target": "ES2021",
     "useDefineForClassFields": false,
     "sourceMap": true,
